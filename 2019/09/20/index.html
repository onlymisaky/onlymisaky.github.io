<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="his前端重构经验"><meta name="keywords" content="vue,重构"><meta name="author" content="onlymisaky"><meta name="copyright" content="onlymisaky"><title>his前端重构经验 | Mikasa</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '7.3.0'
} </script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Mikasa" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E5%89%8D%E7%9A%84%E7%97%9B%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">重构前的痛点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">重构前的准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.</span> <span class="toc-text">重构中遇到的问题和解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%E5%92%8C%E5%BF%A0%E5%91%8A"><span class="toc-number">4.</span> <span class="toc-text">重构的一些经验和忠告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">5.</span> <span class="toc-text">结语</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/data/img/avatar.png"></div><div class="author-info__name text-center">onlymisaky</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">24</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">20</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Mikasa</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/slides">演讲</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">his前端重构经验</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-20</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>自入职以来，85% 的工作都是在做 HIS:Hospital Information System (医院信息系统)的需求。从前端的角度来看，这是一个很典型的后台管理系统，而且有趣的是，你可以从项目的 git 记录中窥探到近年前端技术的变迁。</p>
<p>在我接手到这项目的时候，它已经稳定运行了有三年多的时间了，而且每月都有至少两个以上新需求需要去完成。这是一个非常好的事情，说明我们一直是稳步前进的，不过对于开发者来说，未必是那么的美好。因为出于项目的稳定性考虑，正在使用的技术可能是很久以前的技术，我并不是狂热新技术推崇者，有经验的人都明白，万金油般的解决方案是不存在的，最优的技术选型还是要由场景来决定。所以这次重构并不是为了重构而重构，而是为了<strong>提高项目的可维护性</strong>和<strong>提升开发效率</strong>而做出的决定，因此专门抽出一段时间来做重构，收益是远远大于付出的。</p>
<h2 id="重构前的痛点"><a href="#重构前的痛点" class="headerlink" title="重构前的痛点"></a>重构前的痛点</h2><p>首先介绍一下重构前的技术方案，当时项目还没有采用目前主流的前后端分离的方式，后端使用的是：Spring Boot + thymeleaf(Java 模板引擎)，前端采用的技术就比较多了：</p>
<ul>
<li>jQuery (操作 Dom，发起 ajax 请求)</li>
<li>基于 jQuery 封装的常用插件(日期选择、表格、select 等等)</li>
<li>Handlebars(老牌的前端模板引擎)</li>
<li>sass</li>
<li>gulp (编译 sass，压缩 js，移动编译后的文件，启动 webpack )</li>
<li>vue1.x</li>
<li>webpack1.x (编译 .vue 文件)</li>
<li>lodash (仅仅是为了使用 lodash 的 template，所以项目中一共有四套模板语法 thymeleaf、Handlebars、template、vue)</li>
</ul>
<p>除了以上列举出的这些，还有其它使用频次不太高的js库没有列出。</p>
<p>那这样一个糅合了多种前端技术方案的项目，要如何启动进行开发调试呢？前面提到项目前后端没有分离，所以要想跑起来就必须要配置java开发环境(jdk, maven, mysql, redis…)，和前端开发环境(node, npm, gulp, webpack…)。首先通过 gulp 和 webpack 编译打包前端代码，移动到后端指定的 resource 目录，然后再通过 mvn 启动后端服务(过程比较漫长)。每当前后端代码有改动的时候，则需要重新执行上线的步骤，等待时间极为漫长。讲到这里你可能已经感受了一些痛点了：</p>
<ol>
<li>上手成本高(前端同学要去了解一些后端，后端同学又要去了解一些前端)</li>
<li>前端部分技术方案老旧(vue1.x, gulp, webpack1.x)</li>
<li>调试成本极高，每当前端代码更新就需要重新打包前端，重启后端服务，无法使用热更新，耗费时间极长</li>
</ol>
<p>为了解决以上这些痛点，在我入职第二周，项目经理便和我聊了重构的问题，重构的目标就是将项目打造成前后端分离，提高以后的开发效率和代码质量。刚接到这个任务的时候还是比较兴奋的，因为一直写业务代码确实有些厌倦了，想接受新的挑战，做一些重构和架构方面的东西。但是也有几分的惆怅，因为当时整个项目组只有我一个前端，而且明确表示不会有专门的开发周期用于重构。如同项目经理多次提到的那样，我们要做的事情是“<strong>给一辆高速行驶中的汽车换轮胎</strong>”。当然在重构的最后阶段还是争取到了一周多宝贵的时间用于全身心投入重构工作。</p>
<h2 id="重构前的准备"><a href="#重构前的准备" class="headerlink" title="重构前的准备"></a>重构前的准备</h2><p>既然没有专门的开发周期用于重构，那只能在日常的需求迭代中一点点做重构，所以技术选型就显得尤为重要。最终在主流的 Angular、React、Vue 三者中选择了 Vue，原因如下：</p>
<ol>
<li>vue使用起来非常灵活。只要在页面中引入 vue.js 即可，然后逐步剥离 jQuery、Handlebars 这些老旧的技术，同时引入 vue 生态内的 router、vuex 等等，项目会向一个单页应用慢慢演变。虽然 Angular 和 React 也可以直接通过 script 标签的方式引入使用，但是这样做的话开发体验上比 vue 差很多。</li>
<li>项目有已经有一下部分页面用使用 vue1.x 编写，如果再选别的框架，在迭代过程中又会加重开发的负担。</li>
</ol>
<p>PS:如果是停掉所有的新需求专门重构的话，我可能不会选择 Vue，具体原因暂且不表，也莫问。</p>
<p>框架敲定之后，就该对重构过程中的方案进行思考了，这里我直接给出方案的结果，这些都是基于个人的经验总结出来的，未必是最优的仅供参考：</p>
<ul>
<li>首先就是创建一个全新的目录，用于存放新的代码，可以很好的隔离新代码和老代码。目录结构和目前主流的前端项目大同小异<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── 老代码文件夹			</span><br><span class="line">├── v2(新代码文件夹)		</span><br><span class="line">│   ├── api		</span><br><span class="line">│   ├── components</span><br><span class="line">│   ├── constants</span><br><span class="line">│   ├── plugins</span><br><span class="line">│   ├── styles</span><br><span class="line">│   ├── util</span><br><span class="line">├── └── views</span><br><span class="line">└── pages(webpack 入口文件)</span><br></pre></td></tr></table></figure></li>
<li>修改打包脚本。<br>在上面的的目录结构中有一个 pages 文件夹，它是用来存放 webpack 入口文件用的。因为没有前后端分离，所以除了公共的静态资源外，不同的页面也会加载各自的 js&#x2F;css 文件，pages 文件夹下存放的就是每个页面对应的 js 文件，v2&#x2F;views 下面的文件则是每个页面对应的 vue 组件，最后借用 webpack 的多入口功能来打包<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;./pages/foo.js&#x27;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;./pages/bar.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是这样做有一个缺点，每当添加新的入口文件时，就需要修改一下入口配置。这里可以采用读取 pages 文件，动态创建 entry 对象的方式来解决这个问题：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">fs.<span class="title function_">readdirSync</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;pages/&#x27;</span>))</span><br><span class="line">  .<span class="title function_">forEach</span>(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fileName.<span class="title function_">endsWith</span>(<span class="string">&#x27;.js&#x27;</span>)) &#123;</span><br><span class="line">      entry[fileName.<span class="title function_">replace</span>(<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;&#x27;</span>)] = <span class="string">`v2/pages/<span class="subst">$&#123;fileName&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不过最终并没有这样做，因为已经用到了 gulp，所以使用了 <code>webpack-stream</code> 这个插件，他的原理是通过 gulp 把文件转成 stream 传给 webpack-stream 打包编译，这样做也不用再单独启动 webpack 了。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack-stream&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> named = <span class="built_in">require</span>(<span class="string">&#x27;vinyl-named&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;webpack&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>([<span class="string">&#x27;js/pages/*.js&#x27;</span>])</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">named</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">webpack</span>(webpackConfig))</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">uglify</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/js/&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>对于全新的需求，一律使用vue开发。<br>首先由后端同学定义好后端路由(页面 url )，并且提供对应的空模板页面。对于前端而言，这个空面便是一个单页应用了，你可以在这里任意发挥，所以在替换为前端路由之前，每一个 url 对应的就是一个 spa，最后只要把后端路由替换成前端路由，就成为一个完整的单页应用了。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hello-world.html  --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:layout</span>=<span class="string">&quot;http://www.ultraq.net.nz/web/thymeleaf/layout&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span> <span class="attr">layout:decorator</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/hello-world.css&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/hello-world.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
然后在 pages 下面创建对应的js文件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** hello-world.js */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;./v2/views/hello-world/index.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">HelloWorld</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">hello-world</span> /&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>对于老页面，如果改动比较小，则继续沿用之前的写法；如果改动较大则需要根据工时、风险性、后期收益来评估是用 Vue 重写还是继续沿用之前的开发方式。不过大部分情况下，两种方式是可以并存的。比如某个页面中一部分需要进行较大的改动，便可以将这一部分用 vue 重写，下次再将另一部分用 vue 重写，最终这个页面中可能会有多个 vue 实例，我们只要吧这些实例以组件的形式组织起来，这个页面就算是重构完成了。当然这还要得益于 vue 的灵活性。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:layout</span>=<span class="string">&quot;http://www.ultraq.net.nz/web/thymeleaf/layout&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span> <span class="attr">layout:decorator</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/other.css&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/hello-world.css&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 老的模板  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 本次的改动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/js/other.js&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/hello-world.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
每次改动只要将老的模板用 vue 的方式重写即可，在这个不断替换的过程中，要注意文件的加载顺序。可能会涉及到老的部分和 vue 部分的交互，一般使用事件订阅和 props 的方式都是可以解决的<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">Foo</span> &#125;,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">bar</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">onXxx</span>=<span class="string">&#123;($event)</span> =&gt;</span> &#123; this.$emit(&#x27;xxx&#x27;, $event); &#125;&#125; bar=&#123;bar&#125;/&gt;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">$(() =&gt; &#123;</span><br><span class="line">  vm.$on(<span class="string">&#x27;xxx&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">  vm.<span class="property">bar</span> = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="重构中遇到的问题和解决方案"><a href="#重构中遇到的问题和解决方案" class="headerlink" title="重构中遇到的问题和解决方案"></a>重构中遇到的问题和解决方案</h2><ul>
<li>让人头疼的版本问题。<br>前面提到部分页面使用了 vue1.x，考虑到 vue1 升级到 vue2 曲线相对平滑一下，所以前期一直想着先把这部分代码升级到 vue2，官方提供了 <code>vue-migration-helper</code> 帮助开发者识别出代码中旧有的特性，并且会告知你给出建议，同时附上关于详细信息的链接。不过当我跑完命令后，这种想法已经减少了一半了，<br><img src="/2019/09/20/01-vue-migration-helper%E6%8F%90%E7%A4%BA%E6%9C%891200%E5%A4%9A%E5%A4%84%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9.png" alt="vue-migration-helper提示有1200多处需要修改"><br>1200多处修改，几乎涉及到了所有的 vue1.x 的代码。即使通过编辑器批量修改，也不能保证修改后可以顺利运行。在我看过部分的代码后，完全取消了直接升级的想法了，原因有二：</li>
</ul>
<ol>
<li>大部分组件都使用事件通讯，事件满天飞，光理清里面的业务(事件流)就需要很长的时间</li>
<li>里面有一部分常用组件是自己开发的，重构的版本引入了 element-ui 组件库，这些老的组件都要替换</li>
<li>没有单元测试，升级后之后的代码无法保障正确性<br>所以最终决定这部分代码不升级，当改到具体页面的时候再进行升级重构，(不过这也引发了我的思考，框架在设计的时候一定要设计好对外暴露的 api，没要每次升级，就改一次 api，开发者很痛苦的，说的就是你，AngularJS)</li>
</ol>
<p>除了框架版本，还有打包工具的版本也困扰着我。项目一开始使用 sass 编写样式的，但是在 vue1.x 中却没有看到使用 sass，所有的样式都是写在单独的 .scss  文件中，然后通过gulp 打包，最后以 link 的方式在页面中引入。为什么不直接写在单文件组件中呢？还可以通过 Scoped CSS 防止样式污染。</p>
<p>于是我就添加了 sass-loader 和 node-sass，但是很遗憾，vue-loader 版本过低，当升级了 vue-loader 后，vue1.x 的代码就无法编译通过了。最后找到了一个可以同时兼容 vue1 和 vue2 的版本，但是他却不支持 webpack1，然后升级 webpack 后，有引发了另外一些问题，我发现版本依赖的问题似乎无法解决了，要么全部升级，包括用 vue1.x 写的代码，这个方案已经在前面被否定调了；要么不用 sass-loader 。最后在尝试使用 less-loader 后，发现没有什问题，最终确定使用 less-loader。</p>
<p>上面所描述的两个版本问题一个没有解决，一个用了替代方案，总体上来说是很失败的，不过倒是从中获取了一些经验：</p>
<ol>
<li>当升级版本的时遇到较多的改动，而时间又不充裕，且没有单测时，最好不要升级</li>
<li>当遇到版本依赖问题时，最好先想想为什么要升级，不升级是否有替代方案，不然会引发一系列连锁反应</li>
</ol>
<ul>
<li><p>记不住的命令<br>每次调试的时候都要敲好多命令，根本记不住，一开始都是把这些命令记在一个地方，用到的时候就复制粘贴一下。但是还是觉得不爽，后来想到可以用 alias 让这些命令更简洁，比如自定义一些 <code>his-build-fe</code>、<code>his-build-be</code> 这样的命令，好用也好记，同时也激发了我对linux命令的兴趣。</p>
</li>
<li><p>一些失败的尝试<br>前面提到每次代码有变动的时候，都要重新编译打包、重启服务，非常浪费时间。尤其是前端代码改动也要重新打包，作为一个前端不允许这种事情发生，所以就尝试用来 webpack 的 watch 来监听代码，但是由于是通过 webpack-stream 启动的，加了 watch 并没有用。于是就用 gulp-watch 来检测文件变更，虽然可以实现功能，但是 cpu 风扇一直嗡嗡的转，机器发热量也比较大，所以最后还是放弃了这种想法。</p>
</li>
</ul>
<h2 id="重构的一些经验和忠告"><a href="#重构的一些经验和忠告" class="headerlink" title="重构的一些经验和忠告"></a>重构的一些经验和忠告</h2><ul>
<li><p>首先就是要有平和的心态。<br>重构的过程中要不可避免的和老代码打交道，你可能会看到令你惊叹的奇巧淫技，但更多的是让你头晕眼花的业务逻辑和满口脏话的代码。当遇到这样的情况时，一定要调整好心态，用足够的耐心去梳理其中的逻辑。</p>
</li>
<li><p>尽可能的做到低耦合<br>这一点可能在初期阶段显得不重要，但是到后面做全局性的改动和替换时，你就能感受到他的好处了。举一个例子，在项目中经常有需要从地址栏获取参数做一些业务逻辑的运算，一开始我是将这些参数在组件内部获取并且保存，到后面替换前端路由的时候，很多地址都变了，参数读取的方式也发生了很大的改变，如果当初是把这些值设计成组件的 props，那后期的工作将会减轻很多；同样的还有地址跳转，全局变量等等这些场景。</p>
</li>
<li><p>要对所使用的技术非常熟悉<br>重构和新开项目、重写项目是不同的，经常会遇到需要新老兼容的场景，如果对项目所使用的技术不熟悉，会很难应付这些问题。</p>
</li>
<li><p>尽早的制定规范<br>重构初期的工作都是我一个人在做，后面随着团队的壮大新加入了一些小伙伴，在和他们介绍项目背景和如何开发之后便做各自的任务了。由于一开始没有制定规范，所以大伙的代码风格，编写方式还是比较多样的，这也为后面统一调整的阶段增加了一些额外的工作量，如果一开始就好的代码规范就不会发生这样的事情了。</p>
</li>
<li><p>不定期重构代码<br>在阅读项目中老代码的时候，会见到一些让人啼笑皆非的代码，我想写这段代码的人看到后也会怀疑自己当初是怎么写出这样的代码的，所以重构不是一次性的工作，好的代码就像粥一样，是熬出来。不定期的去重构整理自己曾经写过的代码和业务，不仅能让代码变得更健壮，每一次也是自我的升华。</p>
</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在写这篇文章的时候，HIS 系统已经重构完成为一个纯粹的单页应用了，并且在线上运行了有一个多月的时间，虽然没有收到用户反馈，但是重构后开发体验和效率确实有了很大的提升，切面切换速度也比以前快了很多，所以重构的结果个人还是十分满意的。</p>
<p>本文并没有太多代码和架构层面描述，如果你想了解这些可以留言讨论，我会尽可能的给予答复。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue/">vue</a><a class="post-meta__tags" href="/tags/%E9%87%8D%E6%9E%84/">重构</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/data/img/wechat.jpeg"><div class="post-qr-code__desc">请我喝杯咖啡</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/data/img/alipay.jpg"><div class="post-qr-code__desc">请我喝杯咖啡</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/12/27/"><i class="fa fa-chevron-left">  </i><span>让vue老项目支持js与ts混用</span></a></div><div class="next-post pull-right"><a href="/2019/07/09/"><span>用vscode remote + wsl在windows上搭建linux开发环境</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'YrE19blOm57GQPNTt88rSVH1-gzGzoHsz',
  appKey:'oRNhpwKhbCysF0mGtcnONIQA',
  placeholder:'快来评论吧',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By onlymisaky</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hey! You Find Me!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>