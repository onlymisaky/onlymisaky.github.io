<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mikasa</title>
  
  
  <link href="http://onlymisaky.github.io/atom.xml" rel="self"/>
  
  <link href="http://onlymisaky.github.io/"/>
  <updated>2024-09-11T03:04:28.942Z</updated>
  <id>http://onlymisaky.github.io/</id>
  
  <author>
    <name>onlymisaky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rollup 快速入门与上手</title>
    <link href="http://onlymisaky.github.io/2022/02/17/"/>
    <id>http://onlymisaky.github.io/2022/02/17/</id>
    <published>2022-02-17T11:40:42.000Z</published>
    <updated>2024-09-11T03:04:28.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前一直用 <code>webpack</code> 来打包前端项目，虽说配置复杂，但用多了也沉淀出了自己的配置，能够应对多数的打包和构建场景。然而最近在折腾一些自己的小项目时，需要打包一些类库发布到 <code>npm</code> 。虽说 <code>webpack</code> 也可以构建 <code>library</code> ，但是打包出的产物体积过大，而且代码也不是那么的“干净”，并且当想通过 <code>webpack</code> 一次打包出不同的版本，比如 <code>esm</code> 、 <code>CommonJS</code> 、 <code>umd</code> 等，<code>webpack</code> 就显得更加难用，于是就把目光锁定到了 <code>rollup</code> 。</p><h2 id="什么是-rollup"><a href="#什么是-rollup" class="headerlink" title="什么是 rollup"></a>什么是 rollup</h2><p><code>rollup</code> 和 <code>webpack</code> 一样，都是 <code>JavaScript 模块打包器</code>，用于打包和构建 <code>JavaScript</code> 应用程序和 <code>library</code> 。而 <code>rollup</code> 则更适合打包 <code>library</code> 且自身更为小巧和简单，所以有些开发应用时需要的功能，<code>rollup</code> 反而不支持，比如<code>模块热更新(HMR)</code>。我们熟知的 <code>Vue</code> 、 <code>React</code> 都是通过 <code>rollup</code> 打包。并且 <code>rollup</code> 进入大多是开发者的视野也要得益于 <code>React</code> 。2017年4月初，Facebook 将一个巨大的 pull 请求 合并到了 React 主分支中，将其现有的构建流程替换为基于 <code>rollup</code> ，这一举动让 <code>rollup</code> 得到了更多开发者的关注。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>首先创建项目，我们将会实现一个计算器类库，用于解决 js 在计算加减乘除时产生的精度丢失问题。项目目录如下:</p><p><strong>仓库地址: <a href="https://github.com/onlymisaky/calculator">https://github.com/onlymisaky/calculator</a></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">calculator</span><br><span class="line">├── src</span><br><span class="line">│   ├── index.js</span><br><span class="line">|   └── utils.js</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><p><code>index.js</code> 文件中包含 <code>加减乘除</code> 四个方法，并通过匿名导出向外部暴露这些方法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  addition, subtraction, multiplication, division</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>utils.js</code> 中则是一些辅助方法，无需多言。</p><p>由于只是一个简单的计算功能，并不设计和平台有关的功能或 <code>API</code> ，所以我们要实现的这个 <code>library</code> 可以在任意的 js 环境下使用，比如<code>浏览器</code>、 <code>node</code> 、 <code>Electron</code> 等等。所以我们也需要构建出不同版本的包。</p><p>接下来就开始正式进入 <code>rollup</code> 的正式使用。首先就是安装 <code>rollup</code> :</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i rollup -D</span><br></pre></td></tr></table></figure><p>和 <code>webpack</code> 一样， <code>rollup</code> 可以通过命令的方式直接使用(需要将 <code>rollup</code> 全局安装):</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rollup src/index.js -f umd -o dist/index.js</span><br></pre></td></tr></table></figure><p>上面的命令表示将 <code>src/index.js</code> 以 umd 形式打包，输出到 <code>dist/index.js</code> 。</p><p>很显然这种方式及其不灵活，所以只提一下不做详细的参数介绍。</p><p>最常用的方法还是使用配置文件的方式，不必担心， <code>rollup</code> 的配置文件比 <code>webpack</code> 简单多了，甚至比 <code>gulp</code> 的还简单。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在介绍如何编写 <code>rollup</code> 的配置文件前，我么需要先了解几个它的核心概念，这有助于我们更好使用。</p><ul><li><code>input</code> : 入口文件，对标 <code>webpack</code> 的 <code>entry</code> ，指明了库文件入口位置</li><li><code>output</code> : 输出文件，对标 <code>webpack</code> 的 <code>output</code> ，指明了打包后输出文件的位置、包名、格式等等</li><li><code>plugins</code> : 插件，在构建过程中，需要一些辅助功能，都通过插件实现，比如语法转换、别名解析</li><li><code>external</code> : 当我们的库是基于另一个库开发时，就需要用到它，比如开发一个基于 <code>Vue</code> 的指令，为了不将 Vue 打包到我们的库中，就需要将 Vue 写在 external 中。</li></ul><p>以上就是 <code>rollup</code> 的一些核心概念，相较于 <code>webpack</code> 确实简化了许多，在了解核心概念后，编写 <code>rollup</code> 配置文件就简单多了。</p><h2 id="编写和使用配置文件"><a href="#编写和使用配置文件" class="headerlink" title="编写和使用配置文件"></a>编写和使用配置文件</h2><p>在项目根目录创建 <code>rollup.config.js</code> 文件，代码内容如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg <span class="keyword">from</span> <span class="string">&#x27;./package.json&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> banner = <span class="string">`</span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * @license</span></span><br><span class="line"><span class="string"> * author: <span class="subst">$&#123;pkg.author&#125;</span></span></span><br><span class="line"><span class="string"> * <span class="subst">$&#123;pkg.name&#125;</span> v<span class="subst">$&#123;pkg.version&#125;</span></span></span><br><span class="line"><span class="string"> * (c) 2022-<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()&#125;</span></span></span><br><span class="line"><span class="string"> * Released under the <span class="subst">$&#123;pkg.license&#125;</span> license.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;rollup&#x27;).RollupOptions</span>&#125; */</span></span><br><span class="line"><span class="keyword">const</span> rollupConfig = &#123;</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">file</span>: pkg.<span class="property">main</span>,</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Calculator&#x27;</span>,</span><br><span class="line">      <span class="attr">exports</span>: <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">      banner,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rollupConfig;</span><br></pre></td></tr></table></figure><p>上面的配置代码中，只涉及到了 <code>input</code> 和 <code>output</code> 两个概念，需要额外解释的是 <code>output</code> 这个选项。</p><p><code>output</code> 允许传入一个对象会数组，当传入数组时，会依次输出多个文件。</p><ul><li><code>output.file</code> : 表示输出的文件路径</li><li><code>output.format</code> : 表示输出文件的格式，可选项有 <code>umd</code> 、 <code>commonjs</code>  、 <code>esm</code>  等。</li><li><code>output.name</code> : 当 <code>format</code> 值为 <code>umd</code> 时，需要设置 <code>output.name</code> ，在浏览器环境下就可通过 <code>name</code> 使用。</li><li><code>output.name</code> : 导出方式，可选值有 <code>default</code> 、 <code>named</code> 、 <code>none</code> 、 <code>auto</code> ，我们是匿名导出，就填写 <code>default</code> 。</li><li><code>output.banner</code> : 文件头部添加的内容，当然也有对应的 <code>output.footer</code> 选项用于文件末尾添加的内容 。</li></ul><p>接下来使用 <code>rollup -c</code> 命令便可以打包，就可以在 <code>dist</code> 文件夹输出 <code>index.js</code> 文件。为了方便，将 <code>rollup -c</code>  加入 <code>npm scripts</code> 中，运行 <code>npm run build</code>，得到的输出文件内容大致如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** banner */</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"><span class="variable language_">global</span>, factory</span>) &#123;</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">module</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>() :</span><br><span class="line">  <span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span> ? <span class="title function_">define</span>(factory) :</span><br><span class="line">  (<span class="variable language_">global</span> = <span class="keyword">typeof</span> globalThis !== <span class="string">&#x27;undefined&#x27;</span> ? globalThis : <span class="variable language_">global</span> || self, <span class="variable language_">global</span>.<span class="property">Calculator</span> = <span class="title function_">factory</span>());</span><br><span class="line">&#125;)(<span class="variable language_">this</span>, (<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** some code  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> index = &#123;</span><br><span class="line">    addition, subtraction, multiplication, division</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>这是一个标准的 <code>umd</code> 格式的包，我们可以在 浏览器环境下通过 <code>Calculator</code> 直接使用，也可以在 <code>node</code> 环境下通过 <code>requrie</code> 调用。</p><h3 id="babel-插件"><a href="#babel-插件" class="headerlink" title="babel 插件"></a>babel 插件</h3><p>大致浏览打包出的代码后，可以发现有些较新的语法被没有转换，比如 <code>模板字符串</code> 、 <code>箭头函数</code> 、 <code>rest参数</code> 等等，这些代码在 <code>es5</code> 环境下是无法运行的。为什么会这样呢？因为 rollup 是不会转换这些的，那么就需要用到 <code>babel</code> 插件，来转换这些新的语法。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @babel/core @babel/preset-env @rollup/plugin-babel -D</span><br></pre></td></tr></table></figure><p><code>rollup.config.js</code> 文件中添加 <code>plugin</code> 配置项: </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-babel&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: [&#123;...&#125;],</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">babel</span>(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>babel.config.js</code> 配置文件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;@babel/core&#x27;).TransformOptions</span>&#125; */</span></span><br><span class="line"><span class="keyword">const</span> transformOptions = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = transformOptions;</span><br></pre></td></tr></table></figure><p>配置好 <code>babel</code> 之后，再次打包，我们以发现一些高级的语法和 <del>API</del> （<strong>这里笔者偷懒了，实际上在没有安装和配置 <code>@babel/runtime</code> 等相关插件前，babel 只能转换语法，不能转化 API ，比如代码中的 includes 就是新的 API 但是并没有被转换，等笔者写完 babel 相关文章后再来更新</strong>） 已经被转换可以在低版本环境中运行了。</p><h3 id="resolve-插件"><a href="#resolve-插件" class="headerlink" title="resolve 插件"></a>resolve 插件</h3><p>在上述场景中，我们并没有引用其他的包，但在实际开发中引用第三方包辅助快速开发是非常常见的场景。</p><p>在默认情况下，如果我们直接导入 <code>node_modules</code> 中的包，打包完成之后，<code>node_modules</code> 中的包并不会和我们编写的库合并。为了举例说明，我们将安装一个用于迭代字符串的包 <code>repeat-string</code> ，然后在 <code>index.js</code> 导入并使用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> repeat <span class="keyword">from</span> <span class="string">&#x27;repeat-string&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">repeat</span>(<span class="number">1</span>, args.<span class="property">length</span>));</span><br></pre></td></tr></table></figure><p>在运行 <code>npm run build</code> 之后可以发现，虽然打包成功了，但是控制台确有一些警告提示: </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(!) Unresolved dependencies</span><br><span class="line">https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency</span><br><span class="line">repeat-string (imported by src/index.js)</span><br></pre></td></tr></table></figure><p>打包后的代码中也可以看到，<code>repeat-string</code> 默认是以参数的形式注入其中，而不是与我们的代码合并。</p><p>为了解决这个问题，就要用到 <code>@rollup/plugin-node-resolve</code> 插件，他可以帮助我们解析 <code>node_modules</code> 中的第三方包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @rollup/plugin-node-resolve -D</span><br></pre></td></tr></table></figure><p><code>rollup.config.js</code> :</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-babel&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: [&#123;...&#125;],</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">resolve</span>(),</span><br><span class="line">    <span class="title function_">babel</span>(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 <code>npm run build</code> 之后，你会惊讶的发现，直接报错了: </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src/index.js → dist/index.js...</span><br><span class="line"></span><br><span class="line">[!] Error: <span class="string">&#x27;default&#x27;</span> is not exported by node_modules/repeat-string/index.js, imported by src/index.js</span><br><span class="line"></span><br><span class="line">https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module</span><br></pre></td></tr></table></figure><p>这是因为 <code>repeat-string</code> 是 <code>commonjs</code> 格式的包，而我们是以 <code>ESModule</code> 的方式引入的，所以就报错了。所以需要继续借助插件将 <code>commonjs</code> 转换为 <code>ESM</code> ，就是接下来要介绍的 commonjs 插件。</p><h3 id="commonjs-插件"><a href="#commonjs-插件" class="headerlink" title="commonjs 插件"></a>commonjs 插件</h3><p>安装和配置:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @rollup/plugin-commonjs -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-babel&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-commonjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: [&#123;...&#125;],</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">resolve</span>(),</span><br><span class="line">    <span class="title function_">commonjs</span>(),</span><br><span class="line">    <span class="title function_">babel</span>(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>npm run build</code> 之后，可以发现不仅正确的解析了 <code>repeat-string</code> ，而且也将代码和我们的库合并了。</p><h3 id="其他常用插件"><a href="#其他常用插件" class="headerlink" title="其他常用插件"></a>其他常用插件</h3><p>除了上述的三个插件之外，还有一些常见的插件:</p><ul><li><code>@rollup/plugin-json</code> : 解析编译源码中的 <code>json</code> 文件，并且配合 <code>rollup</code> 的 <code>Tree Shaking</code> 可只打包 <code>.json</code> 文件中我们真正用到的部分。</li><li><code>@rollup/plugin-typescript</code> : 解析和转换 <code>typescript</code></li><li><code>@rollup/plugin-eslint</code> : eslint 插件</li><li><code>rollup-plugin-terser</code> : 压缩代码</li></ul><p>其它更多插件可以到官方仓库中查找: <a href="https://github.com/rollup/plugins">https://github.com/rollup/plugins</a></p><h3 id="external-属性"><a href="#external-属性" class="headerlink" title="external 属性"></a>external 属性</h3><p>当配置了 <code>@rollup/plugin-node-resolve</code> 和 <code>@rollup/plugin-commonjs</code> 之后， 所有从 <code>node_modules</code> 中导入的包都会合并到我们的库中，有时候我们并不希望如此，比如 <code>Vuex</code> 和 <code>VueRouter</code> 都基于 <code>Vue</code> 开发，但打包出的代码中若包含了 <code>Vue</code> 的源码，那显然不合适，所以需要将 <code>Vue</code> 设置为外部项，也就是通过 <code>external</code> 属性来设置。如果回到我们的案例中，我们想将 <code>repeat-string</code> 也设置为外部项，只需做如下修改:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-commonjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-babel&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: [&#123;...&#125;],</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">resolve</span>(),</span><br><span class="line">    <span class="title function_">commonjs</span>(),</span><br><span class="line">    <span class="title function_">babel</span>(),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">external</span>: [</span><br><span class="line">    <span class="string">&#x27;repeat-string&#x27;</span>, <span class="comment">// 外部依赖的名称</span></span><br><span class="line">    path.<span class="title function_">resolve</span>( <span class="string">&#x27;./src/some-local-file-that-should-not-be-bundled.js&#x27;</span>) <span class="comment">// 一个已被找到路径的ID（文件的绝对路径)</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前一直用 &lt;code&gt;webpack&lt;/code&gt; 来打包前端项目，虽说配置复杂，但用多了也沉淀出了自己的配置，能够应对多数的打包和构建场</summary>
      
    
    
    
    
    <category term="rollup" scheme="http://onlymisaky.github.io/tags/rollup/"/>
    
    <category term="打包" scheme="http://onlymisaky.github.io/tags/%E6%89%93%E5%8C%85/"/>
    
    <category term="构建" scheme="http://onlymisaky.github.io/tags/%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>认识前端脚手架</title>
    <link href="http://onlymisaky.github.io/2021/08/25/"/>
    <id>http://onlymisaky.github.io/2021/08/25/</id>
    <published>2021-08-25T12:32:45.000Z</published>
    <updated>2024-09-11T03:04:29.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-CLI"><a href="#什么是-CLI" class="headerlink" title="什么是 CLI"></a>什么是 CLI</h1><p>CLI (Command Line Interface) ，顾名思义是一种通过命令行来交互的工具或者说应用。前端常用的 CLI 有 <a href="https://angular.cn/cli">@angular&#x2F;cli</a> 、 <a href="https://cli.vuejs.org/zh/">@vue&#x2F;cli</a> 、 <a href="https://create-react-app.dev/">create-react-app</a> 。<br>它们可以帮助开发者减少低级重复劳动，专注业务提高开发效率，规范 develop workflow。</p><h1 id="为什么要用-CLI"><a href="#为什么要用-CLI" class="headerlink" title="为什么要用 CLI"></a>为什么要用 CLI</h1><p>我们可以将工作中繁杂、有规律可循、或者简单重复劳动的工作用 CLI 来完成，只需一些命令，快速完成简单基础劳动。现有工作中的可以用 CLI 完成的工作有：</p><ul><li>快速生成应用模板，创建 module 模板文件</li><li>服务启动，如 ng serve</li><li>eslint ，代码校验</li><li>自动化测试</li><li>编译build</li></ul><p>总体而言就是一些快捷的操作替代人工重复劳动，提升开发效率。</p><h1 id="与-npm-scripts-相比"><a href="#与-npm-scripts-相比" class="headerlink" title="与 npm scripts 相比"></a>与 npm scripts 相比</h1><p>npm scripts 也可以实现开发工作流，通过在 package.json 中配置 scripts 字段，执行相关命令，但 CLI 与 npm scripts 相比仍有自己优势：</p><ul><li>npm scripts 只能在项目中使用， CLI 可以全局安装，到处使用</li><li>npm scripts 与业务耦合度高，而 CLI 可以和业务代码剥离</li><li>CLI 可以单独迭代开发，改进原有功能，增加新特性</li></ul><h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>每一个以 node 为基础为项目，在根目录中都有 package.json 文件，用于存储项目的信息、配置、运行环境和所依赖的模块等。</p><p>接下来介绍一些实现一个 CLI 需要了解的 package.json 中的字段。</p><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>项目名称</p><ul><li>只能是小写字母、数字、~、-、_ 这些内容</li><li>不支持空格，使用连字符区分多个单词</li><li>支持 scope ，以 @name&#x2F; 开头，不过该形式的包托管到npm是收费的 (just 7$)</li></ul><p>在创建 js 项目的时候，我们通常会通过 <code>npm init</code> 来快速初始化 <code>package.json</code> 文件，也可以通过 n<code>pm int -y</code> 使用默认是值，快速创建。</p><p>也可以通过 <code>npm init &lt;initializer&gt;</code> 来快速执行某个包中的脚本创建项目，比如常见的：</p><ul><li><code>npm init react-app project-name</code></li><li><code>npm init vite@latest my-vue-app --template vue</code></li></ul><p>其实背后执行的是 <code>npx create-react-app project-name</code><br>而npx 则相当于执行：</p><ol><li><code>npm i create-react-app</code> 安装到临时目录，使用完之后会删除，不占用户存储空间</li><li><code>create-react-app project-name</code></li></ol><p>所以细心的你也可以发现，如果一个包名以 <code>create</code> 开头，那就可以通过 <code>npm init &lt;initializer&gt;</code> 来快速调用该包提供的脚本命令，创建新项目</p><table><thead><tr><th>命令</th><th>等同</th></tr></thead><tbody><tr><td>npm init foo</td><td>npx create-foo</td></tr><tr><td>npm init @user&#x2F;foo</td><td>npx @user&#x2F;create-foo</td></tr><tr><td>npm init @user</td><td>npx @user&#x2F;create</td></tr></tbody></table><p>我们也可以利用这个形式创建一些简便的脚手架工具</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>指定内部命令所对应可执行文件的位置</p><p>编写一个脚手架，我们肯定需要用户安装好我们的包之后，通过命令行的方式直接使用，那就非常有必要设置该字段了，比如 @vue&#x2F;cli 中：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bin/vue.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在安装 @vue&#x2F;cli 后，就可以通过 <code>vue</code> 命令来使用了。命令对应的可执行文件需要在文件首行设置下面代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br></pre></td></tr></table></figure><p>该行代码告诉操作系统,使用 env 来找到 node，并使用 node 来作为程序的解释程序。</p><h2 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h2><p>这个可能是所有前端使用率最高的一个字段了，开发者通过设置 scripts 字段来自定义一些脚本</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./build.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./server.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这样就可以通过 <code>npm run build</code> 和 <code>npm start</code> 来执行对应的文件了。不过关于 npm-scripts 还有一些容易遗漏的知识点需要知道：</p><ul><li>有些命令是不需要加 run 的，比如 npm start  、npm test 、 npm lint</li><li>使用 &amp; 符号并行执行多个 npm scripts ，使用 &amp;&amp; 符号串行执行脚本</li><li>npm script 也是有钩子，分别是 pre 和 post ，对应执行前和执行后</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prebuild&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./build.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;postbuild&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm start&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./server.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>当执行 <code>npm run build</code> 时，会依次执行 <code>npm run prebuild</code> 、<code>npm run build</code> 、 <code>npm run postbuild</code></p><ul><li>可以通过 process.env.npm_** 来获取一些值<ul><li>process.env.npm_lifecycle_event 获取正在运行的脚本名称</li><li>process.env.npm_package_** 获取 package.json 相关字段的值</li><li>process.env.npm_config_argv 获取参数</li></ul></li></ul><h2 id="npm-scripts-原理"><a href="#npm-scripts-原理" class="headerlink" title="npm scripts 原理"></a>npm scripts 原理</h2><p>在执行 <code>npm run xx</code> 的时候会自动根据不同平台创建一个 <code>shell</code> ， 类 <code>UNIX</code> 中代指 <code>/bin/sh</code> <code>，Windows</code> 中使用的是 <code>cmd.exe</code> ， npm scripts 脚本就在这个新创建的 shell 中被运行。<br>所以可以得出一些结论：</p><ul><li>只要是 shell 可以运行的命令，都可以作为 npm scripts 脚本</li><li>npm 脚本的退出码，也自然遵循 shell 脚本规则</li><li>如果系统里安装了 Python ，可以将 Python 作为 npm scripts</li><li>npm scripts 脚本可以使用 shell 的通配符等常规能力  { “scripts”: { “lint”: “eslint **&#x2F;*.js” } }</li></ul><p>不过 npm scripts 创建的 shell 也有一些特殊之处：</p><p>创建出来的 shell 会将当前目录的 <code>node_modules/.bin</code> 子目录加入 PATH 变量中，执行完成后，再将 PATH 变量恢复。比如我们在项目中安装 webpack 后，不用写出完成整路径便可以使用 webpack：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./node_modules/.bin/webpack&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="dependencies-和-devDependencies"><a href="#dependencies-和-devDependencies" class="headerlink" title="dependencies 和  devDependencies"></a>dependencies 和  devDependencies</h2><p>分别对应项目运行所需依赖和开发所需依赖，这里需要知道依赖版本符号的含义：</p><ul><li>version 完全匹配</li><li><blockquote><p>version 大于该版本</p></blockquote></li><li><blockquote><p>&#x3D;version 大于等于该版本</p></blockquote></li><li>&lt;version 小于该版本</li><li>&lt;&#x3D;version 小于等于该版本</li><li>~version 非常接近该版本</li><li>^version 与该版本兼容 (默认，常用)</li><li><ul><li>任意版本</li></ul></li><li>latest 最新版本</li></ul><p>description、keywords 分别对应项目的描述和关键词，在 npm search 时会用到</p><h1 id="npm-link"><a href="#npm-link" class="headerlink" title="npm link"></a>npm link</h1><p>在开发 npm 包的时候，我们需要调试包的功能是否正确，直接发布到 npm 是不太现实的，直接将包拷贝到项目中这种方式也显得很傻。这时候我们就可以借助 npm link 命令创建软链接，将其链接到全局 node 模块安装路径中，同时也会将 package.json 中的 bin 字段对应的脚本生成一个可执行文件。</p><h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><p>在执行 node 脚本或通过 npm scripts 执行命令的时候，也是可以传递参数的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run serve --prot=80</span><br><span class="line">node serve.js prot=80</span><br></pre></td></tr></table></figure><p>上面两种方式都传入了参数 prot&#x3D;80 ，在 npm 中通过 <code>process.env.npm_config_argv</code> 获取参数，在 node 中通过 process.argv 获取参数。在构建 cli 工具时，我们需要考虑参数风格，常见的参数风格有三种：</p><ul><li>Unix 风格：前面加 -， 后面跟的是单个字符，例如 ls -l , ls -al 则相当于 ls -a -l</li><li>GNU 风格：前面加 – ，例如上面的 npm run serve –prot&#x3D;80</li><li>BSD 风格：前面不叫任何修饰符 例如上面的 node serve.js prot&#x3D;80</li></ul><h1 id="参数别名"><a href="#参数别名" class="headerlink" title="参数别名"></a>参数别名</h1><p>优秀的 cli 工具在参数的解析上都支持设置参数名，例如 <code>--version</code> <code>-V</code> 这种常见的形式。实现别名和很简单，只要创建一个别名映射表，然后转化为双向映射即可：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> alias = &#123;</span><br><span class="line">  <span class="string">&#x27;save-dev&#x27;</span>: <span class="string">&#x27;S&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;S&#x27;</span>: <span class="string">&#x27;save-dev&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>依托于强大的 npm ，我们可以直接使用已有且成熟的额命令行参数解析库，比如 <a href="https://www.npmjs.com/package/nopt">nopt</a> 、<a href="https://www.npmjs.com/package/mri">mri</a> 、<a href="https://www.npmjs.com/package/minimist">minimist</a> 、<a href="https://www.npmjs.com/package/yargs-parser">yargs-parser</a> 等，其中 mri 解析效率最高， minimist 覆盖参数输入形式最全。</p><h1 id="命令行交互"><a href="#命令行交互" class="headerlink" title="命令行交互"></a>命令行交互</h1><p>在 web 开发中，可以使用 prompt 显示对话框进行交互，在 node 中也有类似的功能 readline ，它提供了 question 和 prompt 方法构建命令行界面。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> questions = [<span class="string">&#x27;请输入姓名:&#x27;</span>, <span class="string">&#x27;请输入年龄:&#x27;</span>, <span class="string">&#x27;请输入性别:&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> answers = [];</span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">  <span class="attr">output</span>: process.<span class="property">stdout</span>,</span><br><span class="line">  <span class="attr">prompt</span>: questions[<span class="number">0</span>]</span><br><span class="line">&#125;);</span><br><span class="line">rl.<span class="title function_">prompt</span>();</span><br><span class="line">rl</span><br><span class="line">  .<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="function">(<span class="params">line</span>) =&gt;</span> &#123;</span><br><span class="line">    answers.<span class="title function_">push</span>(line.<span class="title function_">trim</span>());</span><br><span class="line">    <span class="keyword">while</span> (answers.<span class="property">length</span> === questions.<span class="property">length</span>) &#123;</span><br><span class="line">      rl.<span class="title function_">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    rl.<span class="title function_">setPrompt</span>(questions[answers.<span class="property">length</span>])</span><br><span class="line">    rl.<span class="title function_">prompt</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = questions</span><br><span class="line">      .<span class="title function_">map</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> v.<span class="title function_">replace</span>(<span class="string">&#x27;请输入&#x27;</span>, <span class="string">&#x27;&#x27;</span>) + answers[i])</span><br><span class="line">      .<span class="title function_">join</span>(<span class="string">&#x27;，&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><img src="/2021/08/25/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92.png" alt="命令行交互"></p><p>上面的交互的形式相信每为学习编码的同行都写过，只不过当初我们学习的时候用的 c++，而现在换成了 node.js 。</p><p>对于常见的问答形式，我们使用原生的 readline 还可以应付，但是在 cli 中，不仅仅是只有问答形式的交互，还有单项选择、进度条等等，同上文提到参数解析一样，我们也可以借助现有的库去完成，比如 <a href="https://www.npmjs.com/package/inquirer">inquirer</a> 、<a href="https://www.npmjs.com/package/enquirer">enquirer</a> 、<a href="https://www.npmjs.com/package/prompts">prompts</a> 等等。</p><p>在编写 cli 工具的时候，通常选用 <a href="https://github.com/tj">tj</a> 大神开发的 <a href="https://github.com/tj/commander.js">commander</a> , 完整的 node.js 命令行解决方案，包含了参数解析、命令行交互等等。</p><h1 id="前端脚手架常见功能"><a href="#前端脚手架常见功能" class="headerlink" title="前端脚手架常见功能"></a>前端脚手架常见功能</h1><ul><li>通过交互收集用户输入的信息，并创建 package.json</li><li>提供 Babel 、TypeScript 、ESLint 、 StyleLint 、CSS 预处理器 这些常见的前端工具</li><li>从 github 拉取模板并创建项目</li></ul><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>通过 <code>npm init -y</code> 快速创建 package.json ，在 <code>bin</code> 字段中添加我们要暴露的命令名称，同时为了适配<code> npm init &lt;initializer&gt;</code> 的形式使用我们的脚手架，我们的项目要以 create 开头，同时在 bin 字段中添加相关脚本</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@onlymisaky/create-project&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@onlymisaky/create-project&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.bin/create-project.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;create-project&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.bin/create-project.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.bin/index.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onlymisaky&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>.bin&#x2F;create-project.js 负责接收并处理 create-project 传入的参数，调用相关方法创建项目</p><p>.bin&#x2F;index.js 则负责处理 pj 命令相关的功能，由于 demo 先对简单所以 pj 和 create-project 的功能相同，只是调用方式不同。</p><h1 id="commander"><a href="#commander" class="headerlink" title="commander"></a>commander</h1><p>这里我们使用上文提到 commander 来注册命令</p><p>create-project&#x2F;.bin&#x2F;create-project.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="keyword">const</span> &#123; program &#125; = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>);</span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">arguments</span>(<span class="string">&#x27;&lt;项目名称&gt;&#x27;</span>)</span><br><span class="line">  .<span class="title function_">action</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;../lib/create&#x27;</span>)(name);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">parse</span>();</span><br></pre></td></tr></table></figure><p>create-project&#x2F;.bin&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="keyword">const</span> &#123; program &#125; = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">&#x27;../package.json&#x27;</span>);</span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">version</span>(pkg.<span class="property">version</span>)</span><br><span class="line">  .<span class="title function_">description</span>(pkg.<span class="property">description</span>)</span><br><span class="line">  .<span class="title function_">usage</span>(<span class="string">&#x27;&lt;command&gt; [options]&#x27;</span>);</span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">command</span>(<span class="string">&#x27;create &lt;项目名称&gt;&#x27;</span>)</span><br><span class="line">  .<span class="title function_">description</span>(<span class="string">&#x27;创建一个新项目&#x27;</span>)</span><br><span class="line">  .<span class="title function_">action</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;./../lib/create&#x27;</span>)(name);</span><br><span class="line">  &#125;);</span><br><span class="line">program.<span class="title function_">parse</span>();</span><br></pre></td></tr></table></figure><p>arguments 接收参数，command 注册命令，在执行命令时( action ) 调用 lib&#x2F;create 创建项目。</p><h1 id="inquire"><a href="#inquire" class="headerlink" title="inquire"></a>inquire</h1><p>在 lib&#x2F;create 中通过 inquire 完成用户和脚手脚手架的交互。<br>inquire 的关键用法就是 prompt 函数，该函数接收一个数组，用于依次询问用户需要做哪些事情</p><p>prompt 参数介绍</p><ul><li>message: 终端显示的消息</li><li>name: 答案对用的 key</li><li>type: 消息类型，常用的类型如下<ul><li>input&#x2F;number&#x2F;password: 需要用户输入文本<ul><li>checkbox: 提供一组选项供用户选择(多选)</li><li>list&#x2F;rawlist: 提供一组选项供用户选择(单选)</li><li>confirm: 询问用户 是或否</li></ul></li></ul></li><li>default: 默认值</li><li>when: 是否执行该步骤，可以是 bool 值 或函数，由于 prompt 需要一次性所有的操作步骤，而有些步骤是前后连续的，所以需要通过 when 函数的参数（已经获取的答案）来判断是否需要执行该步骤</li><li>choices: 当 type 为 list&#x2F;rawlist&#x2F;checkbox 时，需要为此字段配置选项</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> answerMap = <span class="keyword">await</span> inquirer.<span class="title function_">prompt</span>([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;项目名称&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: projectName</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;项目描述&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;author&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;作者&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;features&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;检查项目所需的功能&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;checkbox&#x27;</span>,</span><br><span class="line">    <span class="attr">choices</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Babel&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;Babel&#x27;</span>,</span><br><span class="line">        <span class="attr">link</span>: <span class="string">&#x27;https://babeljs.io/&#x27;</span>,</span><br><span class="line">        <span class="attr">checked</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;ts&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;TS&#x27;</span>,</span><br><span class="line">        <span class="attr">link</span>: <span class="string">&#x27;https://www.tslang.cn/&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ESLint&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;eslint&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;ESLint&#x27;</span>,</span><br><span class="line">        <span class="attr">link</span>: <span class="string">&#x27;https://eslint.org/&#x27;</span>,</span><br><span class="line">        <span class="attr">checked</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;StyleLint&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;stylelint&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;StyleLint&#x27;</span>,</span><br><span class="line">        <span class="attr">link</span>: <span class="string">&#x27;https://stylelint.io/&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;CSS 预处理器&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;css-preprocessor&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;CSS 预处理器&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;eslint&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;选择预设的 ESLint 规则&#x27;</span>,</span><br><span class="line">    <span class="attr">when</span>: <span class="function">(<span class="params">answers</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> answers.<span class="property">features</span>.<span class="title function_">includes</span>(<span class="string">&#x27;eslint&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">    <span class="attr">choices</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ESLint with error prevention only&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;base&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;Basic&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ESLint + Airbnb config&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;airbnb&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;Airbnb&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ESLint + Standard config&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;Standard&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ESLint + Prettier&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;prettier&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;Prettier&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;stylelint&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;选择预设的 StyleLint 规则&#x27;</span>,</span><br><span class="line">    <span class="attr">when</span>: <span class="function">(<span class="params">answers</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> answers.<span class="property">features</span>.<span class="title function_">includes</span>(<span class="string">&#x27;stylelint&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">    <span class="attr">choices</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;StyleLint with error prevention only&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;base&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;Basic&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;StyleLint + Standard config&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">        <span class="attr">short</span>: <span class="string">&#x27;Standard&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;git&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;是否创建 git 仓库&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;confirm&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;git-msg&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;git message&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">    <span class="attr">when</span>: <span class="function">(<span class="params">answers</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> answers.<span class="property">git</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">default</span>: <span class="string">&#x27;initial project&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answerMap);</span><br></pre></td></tr></table></figure><p>该函数会返回一个 promise ，参数是用户输入的所有答案，我么接下来要做的就是分析答案执行创建 package.json 、下载模板、配置项目等等事情了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;my-project&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;pj创建的项目&#x27;</span>,</span><br><span class="line">  <span class="attr">author</span>: <span class="string">&#x27;onlymisaky&#x27;</span>,</span><br><span class="line">  <span class="attr">features</span>: [<span class="string">&#x27;babel&#x27;</span>, <span class="string">&#x27;ts&#x27;</span>, <span class="string">&#x27;eslint&#x27;</span>, <span class="string">&#x27;stylelint&#x27;</span>, <span class="string">&#x27;css-preprocessor&#x27;</span>],</span><br><span class="line">  <span class="attr">eslint</span>: <span class="string">&#x27;airbnb&#x27;</span>,</span><br><span class="line">  <span class="attr">stylelint</span>: <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">  <span class="attr">git</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;git-msg&#x27;</span>: <span class="string">&#x27;initial project&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h1><h2 id="模板方案"><a href="#模板方案" class="headerlink" title="模板方案"></a>模板方案</h2><p>一般生成项目都是采用以现有的模板为基础，同时解析用户输入的答案创建用户想要的初始化项目。CLI 提供了多样化配置，我们不可能编写 n 多份模板，常规做法是编写一份功能配置完善的模板，借助模板引擎来时先多样化配置，常用的模板引擎有 ejs 、handlebarsjs</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;#eslint&#125;&#125;<span class="keyword">const</span> <span class="title function_">createLintingRule</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">  <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">  <span class="attr">include</span>: [<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>), <span class="title function_">resolve</span>(<span class="string">&#x27;test&#x27;</span>)],</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">formatter</span>: <span class="built_in">require</span>(<span class="string">&#x27;eslint-friendly-formatter&#x27;</span>),</span><br><span class="line">    <span class="attr">emitWarning</span>: !config.<span class="property">dev</span>.<span class="property">showEslintErrorsInOverlay</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)&#123;&#123;/eslint&#125;&#125;</span><br></pre></td></tr></table></figure><p>也需要考虑模板的存放位置，对于简单且不常更新的模板，可以随 CLI 一起打包发布至 npm ，而稍微复杂一点的还是建议将模板和 CLI 分开，因为放在一起有一个明显的缺陷，当模板需要更新的时候，即使是更新一个依赖这种和 CLI 毫无关系的操作，也要被迫的提升 CLI 的版本号，增加用户的使用负担。所以模板一般都存放在远程，比如 github ，然后借助 <a href="https://www.npmjs.com/package/download-git-repo">download-git-repo</a> 下载到本地。</p><p>在模板下载并解析完成后，就需要将文件写入到项目中，可以使用 fs.writeFile ，也可以使用 <a href="https://www.npmjs.com/package/metalsmith">metalsmith</a> ，不过要考虑边界值得情况，比如文件是否已经存在，删除原有文件等等。</p><h2 id="插件方案"><a href="#插件方案" class="headerlink" title="插件方案"></a>插件方案</h2><p>模板的方案也有明显的缺陷，就是模板需要增加新功能时，需要在原有基础上做修改，随着不断的迭代，模板会变得越来越复杂。可以采用 vue-cli3 的插件方案解决该问题，模板只提供最小最基础的功能，其余的功能皆交给插件方案，比如 @vue&#x2F;cli-plugin-babel 只负责 babel 相关的功能，而插件的实现其实和模板方案差不多，都是读写文件，编译模板之类的。这样做既方便维护和扩展，也避免了去修改一份庞大的模板项目。</p><h1 id="自动执行命令"><a href="#自动执行命令" class="headerlink" title="自动执行命令"></a>自动执行命令</h1><p>在项目创建完成之后，需要执行一些常规的初始化命令， 比如 git init 初始化 git 仓库； npm install 安装依赖等等，我们可以使用 node 内置的 process.exce 或者使用 shelljs 之类包来完成。</p><h1 id="优化体验"><a href="#优化体验" class="headerlink" title="优化体验"></a>优化体验</h1><p>虽然 CLI 是运行在一个简陋的终端里面，但我们也要尽可能的提升 CLI 的使用体验，比如：</p><ul><li>使用 chalk ，对不同类型的提示设置不同的颜色</li><li>在需要等待的操作过程中，使用 ora 让命令行输出 loading ，或使用 progress 显示进度条</li><li>使用 boxen 在命令行中花去 boxes 区块</li><li>编写通俗易懂、完善的usage</li></ul><h1 id="没有提到，也很重要"><a href="#没有提到，也很重要" class="headerlink" title="没有提到，也很重要"></a>没有提到，也很重要</h1><ul><li>编写 cli 要考虑在不同平台的兼容性问题</li><li>命令要避免和常见的命令冲突</li><li>考虑到可扩展性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是-CLI&quot;&gt;&lt;a href=&quot;#什么是-CLI&quot; class=&quot;headerlink&quot; title=&quot;什么是 CLI&quot;&gt;&lt;/a&gt;什么是 CLI&lt;/h1&gt;&lt;p&gt;CLI (Command Line Interface) ，顾名思义是一种通过命令行来交互的工具或者</summary>
      
    
    
    
    
    <category term="node" scheme="http://onlymisaky.github.io/tags/node/"/>
    
    <category term="cli" scheme="http://onlymisaky.github.io/tags/cli/"/>
    
    <category term="前端工程化" scheme="http://onlymisaky.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端脚手架</title>
    <link href="http://onlymisaky.github.io/2021/08/17/"/>
    <id>http://onlymisaky.github.io/2021/08/17/</id>
    <published>2021-08-17T06:44:17.000Z</published>
    <updated>2024-09-11T03:04:29.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端脚手架"><a href="#前端脚手架" class="headerlink" title="前端脚手架"></a>前端脚手架</h1><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="什么是-CLI"><a href="#什么是-CLI" class="headerlink" title="什么是 CLI"></a>什么是 CLI</h2><p>—-分段—-</p><p>CLI (Command Line Interface) ，顾名思义是一种通过命令行来交互的工具或者说应用。前端常用的 CLI 有 @angular&#x2F;cli 、 @vue&#x2F;cli 、 create-react-app 。</p><p>它们可以帮助开发者减少低级重复劳动，专注业务提高开发效率，规范 develop workflow。<!-- .element: class="fragment" --></p><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="为什么要用-CLI"><a href="#为什么要用-CLI" class="headerlink" title="为什么要用 CLI"></a>为什么要用 CLI</h2><p>—-分段—-</p><p>我们可以将工作中繁杂、有规律可循、或者简单重复劳动的工作用 CLI 来完成，只需一些命令，快速完成简单基础劳动。现有工作中的可以用 CLI 完成的工作有：</p><p>—-分段—-</p><ul><li>快速生成应用模板，创建 module 模板文件</li><li>服务启动，如 ng serve<!-- .element: class="fragment" --></li><li>eslint ，代码校验<!-- .element: class="fragment" --></li><li>自动化测试<!-- .element: class="fragment" --></li><li>编译build<!-- .element: class="fragment" --></li></ul><p>总体而言就是一些快捷的操作替代人工重复劳动，提升开发效率。<!-- .element: class="fragment" --></p><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="与-npm-scripts-相比"><a href="#与-npm-scripts-相比" class="headerlink" title="与 npm scripts 相比"></a>与 npm scripts 相比</h2><p>—-分段—-</p><p>npm scripts 也可以实现开发工作流，通过在 package.json 中配置 scripts 字段，执行相关命令，但 CLI 与 npm scripts 相比仍有自己优势：</p><p>—-分段—-</p><ul><li>npm scripts 只能在项目中使用， CLI 可以全局，到处使用</li><li>npm scripts 与业务耦合度高，而 CLI 可以和业务代码剥离<!-- .element: class="fragment" --></li><li>CLI 可以单独迭代开发，改进原有功能，增加新特性<!-- .element: class="fragment" --></li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><ul><li>只能是小写字母、数字、~、-、_ 这些内容<!-- .element: class="fragment" --></li><li>不支持空格，使用连字符区分多个单词<!-- .element: class="fragment" --></li><li>支持 scope ，以 @name&#x2F; 开头，不过该形式的包托管到npm是收费的 (just 7$)<!-- .element: class="fragment" --></li></ul><p>—-分段—-</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init &lt;initializer&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init react-app project-name</span><br><span class="line">npm init vite@latest my-vue-app --template vue</span><br></pre></td></tr></table></figure><!-- .element: class="fragment" --><p>—-分段—-</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app project-name</span><br></pre></td></tr></table></figure><h3 id="等同于"><a href="#等同于" class="headerlink" title="等同于"></a>等同于<!-- .element: class="fragment" --></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i create-react-app</span><br><span class="line">create-react-app project-name</span><br></pre></td></tr></table></figure><!-- .element: class="fragment" --><p>—-分段—-</p><table><thead><tr><th>命令</th><th>等同</th></tr></thead><tbody><tr><td>npm init foo</td><td>npx create-foo</td></tr><tr><td>npm init @user&#x2F;foo</td><td>npx @user&#x2F;create-foo</td></tr><tr><td>npm init @user</td><td>npx @user&#x2F;create</td></tr></tbody></table><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>指定内部命令所对应可执行文件的位置<!-- .element: class="fragment" --></p><p>—-分段—-</p><p><img src="/2021/08/17/vue%E5%91%BD%E4%BB%A4.png" alt="vue命令"></p><p>—-分段—-</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bin/vue.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br></pre></td></tr></table></figure><!-- .element: class="fragment" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>Node.js 在设计 npm 之初，允许开发者在 package.json 文件中，通过 scripts 字段来自定义项目的脚本。<!-- .element: class="fragment" --></p><p>—-分段—-</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./build.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./server.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><!-- .element: class="fragment" --><p>—-分段—-</p><ul><li>有些命令是不需要加 run 的，比如 npm start  、npm test 、 npm lint</li><li>使用 &amp; 符号并行执行多个 npm scripts ，使用 &amp;&amp; 符号串行执行脚本</li></ul><p>—-分段—-</p><ul><li>npm script 也是有钩子，分别是 pre 和 post ，对应执行前和执行后</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prebuild&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./build.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;postbuild&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm start&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./server.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><!-- .element: class="fragment" --><p>—-分段—-</p><ul><li>可以通过 process.env.npm_** 来获取一些值<ul><li>process.env.npm_lifecycle_event 获取正在运行的脚本名称</li><li>process.env.npm_package_** 获取 package.json 相关字段的值</li><li>process.env.npm_config_argv 获取参数</li></ul></li></ul><p>—-分段—-</p><p>npm scripts 原理</p><p>在执行 npm run xx 的时候会自动根据不同平台创建一个 shell ， 类 UNIX 中代指 &#x2F;bin&#x2F;sh ，Windows 中使用的是 cmd.exe ， npm scripts 脚本就在这个新创建的 shell 中被运行。<!-- .element: class="fragment" --></p><p>—-分段—-</p><ul><li>只要是 shell 可以运行的命令，都可以作为 npm scripts 脚本</li><li>npm 脚本的退出码，也自然遵循 shell 脚本规则</li><li>如果系统里安装了 Python ，可以将 Python 作为 npm scripts</li><li>npm scripts 脚本可以使用 shell 的通配符等常规能力  { “scripts”: { “lint”: “eslint **&#x2F;*.js” } }</li></ul><p>—-分段—-</p><p>npm scripts 与 shell 的不同之处</p><p>npm scripts 创建出来的 shell 会将当前目录的node_modules&#x2F;.bin 子目录加入 PATH 变量中，执行完成后，再将 PATH 变量恢复。<!-- .element: class="fragment" --></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><!-- .element: class="fragment" data-index="2" --><p>等同于<!-- .element: class="fragment" data-index="3" --></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./node_modules/.bin/webpack&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><!-- .element: class="fragment" data-index="3" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="npm-link"><a href="#npm-link" class="headerlink" title="npm link"></a>npm link</h2><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run serve --prot=80</span><br><span class="line">node serve.js prot=80</span><br></pre></td></tr></table></figure><!-- .element: class="fragment" --><p>—-分段—-</p><ul><li>Unix 风格：前面加 -， 后面跟的是单个字符，例如 ls -l , ls -al 则相当于 ls -a -l；</li><li>GNU 风格：前面加 – ，例如上面的 npm run serve –prot&#x3D;80</li><li>BSD 风格：前面不叫任何修饰符 例如上面的 node serve.js prot&#x3D;80</li></ul><p>—-分段—-</p><p>参数别名</p><p>–version -V<!-- .element: class="fragment" --></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> alias = &#123;</span><br><span class="line">  <span class="string">&#x27;save-dev&#x27;</span>: <span class="string">&#x27;S&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;S&#x27;</span>: <span class="string">&#x27;save-dev&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- .element: class="fragment" --><p>—-分段—-</p><p>nopt 、mri 、minimist 、yargs-parser 等，其中 mri 解析效率最高， minimist 覆盖参数输入形式最全。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="命令行交互"><a href="#命令行交互" class="headerlink" title="命令行交互"></a>命令行交互</h2><p><img src="/2021/08/17/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92.png" alt="命令行交互"><!-- .element: class="fragment" --></p><p>—-分段—-</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> questions = [<span class="string">&#x27;请输入姓名:&#x27;</span>, <span class="string">&#x27;请输入年龄:&#x27;</span>, <span class="string">&#x27;请输入性别:&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> answers = [];</span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">  <span class="attr">output</span>: process.<span class="property">stdout</span>,</span><br><span class="line">  <span class="attr">prompt</span>: questions[<span class="number">0</span>]</span><br><span class="line">&#125;);</span><br><span class="line">rl.<span class="title function_">prompt</span>();</span><br><span class="line">rl</span><br><span class="line">  .<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="function">(<span class="params">line</span>) =&gt;</span> &#123;</span><br><span class="line">    answers.<span class="title function_">push</span>(line.<span class="title function_">trim</span>());</span><br><span class="line">    <span class="keyword">while</span> (answers.<span class="property">length</span> === questions.<span class="property">length</span>) &#123;</span><br><span class="line">      rl.<span class="title function_">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    rl.<span class="title function_">setPrompt</span>(questions[answers.<span class="property">length</span>])</span><br><span class="line">    rl.<span class="title function_">prompt</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = questions</span><br><span class="line">      .<span class="title function_">map</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> v.<span class="title function_">replace</span>(<span class="string">&#x27;请输入&#x27;</span>, <span class="string">&#x27;&#x27;</span>) + answers[i])</span><br><span class="line">      .<span class="title function_">join</span>(<span class="string">&#x27;，&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><!-- .element: class="fragment" --><p>—-分段—-</p><p>常用的 CLI 交互库有 inquirer 、enquirer 、prompts 、 <strong>commander</strong></p><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="前端脚手架常见功能"><a href="#前端脚手架常见功能" class="headerlink" title="前端脚手架常见功能"></a>前端脚手架常见功能</h2><p>—-分段—-</p><ul><li>通过交互收集用户输入的信息，并创建 package.json</li><li>提供 Babel 、TypeScript 、ESLint 、 StyleLint 、CSS 预处理器 这些常见的前端工具</li><li>从 github 拉取模板并创建项目</li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="兼容-npm-init"><a href="#兼容-npm-init" class="headerlink" title="兼容 npm init "></a>兼容 npm init <initializer></h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@onlymisaky/create-project&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@onlymisaky/create-project&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.bin/create-project.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;create-project&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.bin/create-project.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.bin/index.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onlymisaky&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><!-- .element: class="fragment" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create-project/.bin/create-project.js</span></span><br><span class="line">#!<span class="regexp">/usr/</span>bin/env node</span><br><span class="line"><span class="keyword">const</span> &#123; program &#125; = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>);</span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">arguments</span>(<span class="string">&#x27;&lt;项目名称&gt;&#x27;</span>)</span><br><span class="line">  .<span class="title function_">action</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;../lib/create&#x27;</span>)(name);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">parse</span>();</span><br></pre></td></tr></table></figure><p>—-分段—-</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create-project/.bin/index.js</span></span><br><span class="line">#!<span class="regexp">/usr/</span>bin/env node</span><br><span class="line"><span class="keyword">const</span> &#123; program &#125; = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">&#x27;../package.json&#x27;</span>);</span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">version</span>(pkg.<span class="property">version</span>)</span><br><span class="line">  .<span class="title function_">description</span>(pkg.<span class="property">description</span>)</span><br><span class="line">  .<span class="title function_">usage</span>(<span class="string">&#x27;&lt;command&gt; [options]&#x27;</span>);</span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">command</span>(<span class="string">&#x27;create &lt;项目名称&gt;&#x27;</span>)</span><br><span class="line">  .<span class="title function_">description</span>(<span class="string">&#x27;创建一个新项目&#x27;</span>)</span><br><span class="line">  .<span class="title function_">action</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;./../lib/create&#x27;</span>)(name);</span><br><span class="line">  &#125;);</span><br><span class="line">program.<span class="title function_">parse</span>();</span><br></pre></td></tr></table></figure><p>—-分段—-</p><ul><li>arguments 接收参数</li><li>command 注册命令</li><li>在执行命令时( action ) 调用 lib&#x2F;create 创建项目。</li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h2><p><img src="/2021/08/17/prompt%E6%BC%94%E7%A4%BA.png" alt="prompt演示"><!-- .element: class="fragment" --></p><p>—-分段—-</p><ul><li>message</li><li>name</li><li>type</li><li>default</li><li>when</li><li>choices</li></ul><p>—-分段—-</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;my-project&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;pj创建的项目&#x27;</span>,</span><br><span class="line">  <span class="attr">author</span>: <span class="string">&#x27;onlymisaky&#x27;</span>,</span><br><span class="line">  <span class="attr">features</span>: [<span class="string">&#x27;babel&#x27;</span>, <span class="string">&#x27;ts&#x27;</span>, <span class="string">&#x27;eslint&#x27;</span>, <span class="string">&#x27;stylelint&#x27;</span>, <span class="string">&#x27;css-preprocessor&#x27;</span>],</span><br><span class="line">  <span class="attr">eslint</span>: <span class="string">&#x27;airbnb&#x27;</span>,</span><br><span class="line">  <span class="attr">stylelint</span>: <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">  <span class="attr">git</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;git-msg&#x27;</span>: <span class="string">&#x27;initial project&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h2><p>—-分段—-</p><p>模板解析</p><ul><li>ejs</li><li>handlebarsjs</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;#eslint&#125;&#125;<span class="keyword">const</span> <span class="title function_">createLintingRule</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(js|ts|tsx)$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">  <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">  <span class="attr">include</span>: [<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>), <span class="title function_">resolve</span>(<span class="string">&#x27;test&#x27;</span>)],</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">formatter</span>: <span class="built_in">require</span>(<span class="string">&#x27;eslint-friendly-formatter&#x27;</span>),</span><br><span class="line">    <span class="attr">emitWarning</span>: !config.<span class="property">dev</span>.<span class="property">showEslintErrorsInOverlay</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)&#123;&#123;/eslint&#125;&#125;</span><br></pre></td></tr></table></figure><!-- .element: class="fragment" --><p>—-分段—-</p><h3>本地模板</h3><p>or</p><h3>远程模板</h3><p>—-分段—-</p><p>生成文件</p><ul><li>fs.writeFile</li><li>metalsmith</li></ul><p>—-分段—-</p><h3 id="插件方案"><a href="#插件方案" class="headerlink" title="插件方案"></a>插件方案</h3><p>提供一份最小模板，其余功能交由插件实现</p><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><ul><li>require(‘child_process’).exce</li><li>shelljs</li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="优化体验"><a href="#优化体验" class="headerlink" title="优化体验"></a>优化体验</h2><p>—-分段—-</p><ul><li>chalk 使终端输出彩色文案</li><li>ora 让命令行显示loading</li><li>progress 进度条</li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="没有提到，也很重要"><a href="#没有提到，也很重要" class="headerlink" title="没有提到，也很重要"></a>没有提到，也很重要</h2><p>—-分段—-</p><ul><li>考虑平台兼容性</li><li>命令要避免和常见的命令冲突<!-- .element: class="fragment" --></li><li>可扩展性<!-- .element: class="fragment" --></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端脚手架&quot;&gt;&lt;a href=&quot;#前端脚手架&quot; class=&quot;headerlink&quot; title=&quot;前端脚手架&quot;&gt;&lt;/a&gt;前端脚手架&lt;/h1&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;分页&amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    
    <category term="node" scheme="http://onlymisaky.github.io/tags/node/"/>
    
    <category term="cli" scheme="http://onlymisaky.github.io/tags/cli/"/>
    
    <category term="前端工程化" scheme="http://onlymisaky.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>扬帆起航</title>
    <link href="http://onlymisaky.github.io/2021/02/11/"/>
    <id>http://onlymisaky.github.io/2021/02/11/</id>
    <published>2021-02-11T08:25:17.000Z</published>
    <updated>2024-09-11T03:04:29.058Z</updated>
    
    <content type="html"><![CDATA[<p>Hi, boys:</p><p>  进入大学已经有一学期了，你们也对期盼已久的大学生活有了一些自己的体验与感悟了吧。这样的生活是否满足你们当初对大学的期许呢？</p><p>  作为一个已经离开校园很久，且有这许多遗憾的人，我想以一个失败的过来人和你们聊聊大学生活。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>  首先要聊的话题，肯定是关于学习。你们肯定也已经感受到了，在这里学习全靠自觉或压力的驱动(比如为了考试不挂科)，不知你们是属于哪种呢？</p><p>  其实学习这个话题可以展开聊很多很多，比如学习效率，学习方法，学习计划等等。但没有万能的方法，只有适合的方法，因此我给不了你们太多的建议，只能靠你们自己结合自身的情况去探索属于自己的最佳方法，这将会受益终身。我指的包括但不仅限于文化知识，专业知识。</p><p>  由于我自己就是个学渣，所以对你们的期许就是 <strong>不要挂科</strong> ，再稍微提高一点要求的话，就是可以轻轻松松的通过所有的学业考试，而不是每次考试前，到处求神拜佛，或是临时抱佛脚熬夜复习(也可能是预习)。当然我更希望你们 <strong>成绩可以在本专业进入前20%、前15%</strong> 。因为好的成绩不仅仅是学习能力的体现，也会成为你第一份简历上的谈资，更能给你带来更多的机会。</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>  谈到学习，不可避免的就要提及目标规划。先问一个问题，你们有想过为什么要读书吗？不管曾经是否想过这个问题，你们都已经在这条路上走了很久很久了，现在真的该考虑下一步的计划了。有了目标，你走的每一步都会更加沉稳。我见过太多太多临近毕业的人不知所措的学子，好像一个无力的孩子突然被推向了一群陌生人之中，彷徨无助。以我个人的经验，最好先提升学历(考研大三准备，专转本大二准备)，这是一个性价比极高的短期目标，至于更长远的需要你们自己去思考。但从功利的角度出发，可以面向招聘规划，没事可以多刷一些求职类App(boss直聘，拉钩等等)，看看用人单位到底需要什么样的人才，为了符合要求自己又能做哪些事情。我也有一个最低要求， <strong>不要快毕业的时候，还去问简历该怎么写。</strong> </p><h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h2><p>  我相信你们不止一次的听到过 <strong>大学就是一个小社会</strong> 这样的话。但实际上大学不只是一个小社会，它就是一个社会。在这里真的可以遇到形形色色的人，有时候要考虑到一些人情世故，也不能再用高中时候的那种思维去思考问题。这里我只讲一下如何交朋友。</p><p>  如果我没猜错的话，一般情况下你们在大学里最好的朋友应该就是舍友了。但是这并不是主动选择的结果，只是巧了被分到了一个宿舍，每天接触的时间多了就成了好朋友。我并不是说这没什么不好，能分到一个宿舍也是一种缘分。但当如果你发现，和其相处起来并不是很融洽，甚至需要迁就的时候，这种所谓的友谊真的没必要维持下去，但是为了同宿舍之间不那么尴尬，表面关系还是要做到的。当然这种极端的情况并不会真的就发生在你们的身上，至于平时小的摩擦，男孩子嘛，有什么事就拿到明面上出来说，谁的错谁来认。</p><p>  不过我还是建议你们有目的性的交友，交一群可以一起上进的朋友，交一群有共同爱好的朋友，如果你的朋友都只是聊天吃饭玩乐而已，在我看来这不算是友谊，只是关系较好的熟人。其实在人际交往方面，我也很失败，由于性格慢热，天生宅的属性，我的朋友圈也很小，只有高中同学和大学舍友两个圈子。去年(2020)有一段时间我也为此苦恼过，想认识更多的朋友，但是后来也都习惯了，学会了和自己相处。如果你们在社交上有什么问题，可以向我倾诉倾诉，可能帮不上大忙，至少吐吐苦水也是一种减压的方式。</p><h2 id="恋爱"><a href="#恋爱" class="headerlink" title="恋爱"></a>恋爱</h2><p>  爱情是一种可遇不可求的美妙感觉，如果遇到心仪的女孩，就勇敢的去追求吧，大大方方一些，不要扭扭捏捏，没有女孩会看上比自己还腼腆的男生。如果有了女朋友，怎么相处是你们自己的事情，但身为一个男生，有两点一定要做到：</p><ol><li>充分尊重女孩子的想法，不要大男子主义</li><li>有担当，必要时候做好安全措施，你们承担不起后果</li></ol><p>再唠叨一下，如果不是真的喜欢、不是真心的，一个人其实也很好。不要因为别人的怂恿，不要被<strong>不谈恋爱，就不是完整的大学</strong>之类的言论所蒙骗。</p><p>再唠叨一句，尽早的和对方交换一下个人的价值观、家庭观念，不要等到出现问题，才发现彼此是多么的不合适。</p><h2 id="自我认知-信仰-梦想"><a href="#自我认知-信仰-梦想" class="headerlink" title="自我认知 &amp; 信仰 &amp; 梦想"></a>自我认知 &amp; 信仰 &amp; 梦想</h2><p>  这是一个很长，很哲学，很深，也很无聊的话题。每天为了生活奔波的时候，根本无心思考这些。当衣食无忧的时候，就开始寻求自我价值。我是一个怎样的人，我为什么要存在于世。</p><p>  二十岁之前，我们都在上学，有许许多多的同龄人并肩走着同样的路，年轻的身体里蕴藏着无限的活力，甚至有些年少轻狂，为数不多的烦恼，也就是来自学校和家长的压力。毕业之后可能会突然发现，身边的人越来少，生活从一群人变成了一个人。孤独、迷茫、困惑，终于熬过了这几年，又到了成家立业的时候，生活被动的进入了下一个篇章。这中间有多少决定是自己选择的，一路上又丢弃了多少想法与梦想，向现实低了多少次头，普通人的一生真的太像了。普通没什么，但某个失意的深夜，回想起曾经的时候，心中的不甘和叹息会灼烧你的心。如果可以，保持真我，守住初心。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>  兼职、社团之类不是必须的。</p><p>  多看书，我的说的不是电子书和网络小说之类的垃圾文学。</p><p>  培养一个可以让自己一想到就觉得生活很有期待的兴趣爱好。</p><p>  不要抽烟。</p><p>  少熬夜，少熬夜，少熬夜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hi, boys:&lt;/p&gt;
&lt;p&gt;  进入大学已经有一学期了，你们也对期盼已久的大学生活有了一些自己的体验与感悟了吧。这样的生活是否满足你们当初对大学的期许呢？&lt;/p&gt;
&lt;p&gt;  作为一个已经离开校园很久，且有这许多遗憾的人，我想以一个失败的过来人和你们聊聊大学生活。&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>聊聊vue中的依赖注入</title>
    <link href="http://onlymisaky.github.io/2020/11/17/"/>
    <id>http://onlymisaky.github.io/2020/11/17/</id>
    <published>2020-11-17T08:08:26.000Z</published>
    <updated>2024-09-11T03:04:29.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-的组件通信方式"><a href="#Vue-的组件通信方式" class="headerlink" title="Vue 的组件通信方式"></a>Vue 的组件通信方式</h2><p>开篇先俗套一下，在 Vue 中，组件间的通信有以下几种方式: </p><ul><li><p>prop<br>作用: 父组件向子组件传值，单向数据流</p></li><li><p>$emit $on<br>作用: 子组件发布事件，父组件订阅事件</p></li><li><p>vuex<br>作用: 集中数据管理，数据共享</p></li><li><p>Event Bus<br>作用: 作为全局事件池，发布订阅事件</p></li><li><p>ref<br>作用: 通过ref获取子组件的引用(实例)，不是响应式的</p></li><li><p>$attrs $listeners<br>作用: 获取父作用域中除了 props 中声明的属性( class 和 style 也不包含在内) 和 事件( .native 除外)</p></li><li><p>$parent $children<br>作用: 获取当前组件的父实例和所有子实例(非响应式)</p></li><li><p>$root<br>作用: 获取当前组件数的根实例，实际上和 vuex 有相似之处</p></li><li><p>provide inject<br>作用: 依赖注入，将当前组件的方法和数据注入的子组件中，可以跨层级，非响应式</p></li></ul><h2 id="封装组件的方式与目的"><a href="#封装组件的方式与目的" class="headerlink" title="封装组件的方式与目的"></a>封装组件的方式与目的</h2><p>进入正题，通常情况下在设计一个组件的时候，我们会习惯性的将组件中的部分状态设计成 props 。以一个简单的 button 组件为例: </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ButtonBase</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ButtonBase&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">defualt</span>: <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">size</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">defualt</span>: <span class="string">&#x27;small&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">disabled</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">      <span class="attr">defualt</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>常用的事件则会通过 <code>$emit</code> 派发事件，例如 <code>$emit(&#39;click&#39;, $event)</code> 。如果还有更多不重要的属性和事件时，或者所写的组件只是对另一个更底层的组件进行包装(高阶组件)，就可以直接使用 <code>v-bind=&quot;$attrs&quot;</code> 和 <code>v-on=&quot;$listeners&quot;</code> 来进行事件和数据的绑定。</p><p>以上的这种思路，可以 cover 大部分的场景，但当涉及到双向数据流或非父子组件传值的时候，大家的方式就开始奔放起来了，常见的方式大概是以下几种:</p><ul><li>ref</li><li>veux</li><li>Event Bus</li></ul><p>借助这些方式几乎所有的场景都可以解决了，那我们再进入具体的场景分析一下。</p><p>首先想一下为什么需要封装组件？</p><p><strong>为了复用</strong></p><p>我猜你已经抢答了，但事实上除了组件库和项目中的基础组件，我们所写的业务组件几乎都不会有复用的场景，那我们在写业务代码的时候，为什么还要封装呢？</p><p><strong>为了代码的可维护性和可读性</strong></p><p>机智的你又回答对了，确实如此，作为一个平淡无奇的打工人，在封装代码的时候，一开始都是从可复用的角度出发，最后发现根本没有太多可复用的场景，甚至只用到一次，那我们封装的作用剩下了一个: 可维护性。</p><h2 id="业务组件的拆分"><a href="#业务组件的拆分" class="headerlink" title="业务组件的拆分"></a>业务组件的拆分</h2><p>站在 <strong>可维护性</strong> 这个角度再去思考组件该如何封装，以下面的原型图和需求为例，你会如何拆分组件？</p><p><img src="/2020/11/17/%E5%A4%84%E6%96%B9%E5%8E%9F%E5%9E%8B%E5%9B%BE.png" alt="处方原型图"></p><ol><li>上半部分为表单，用于写处方</li><li>下半部分为表格，用于展示历史处方</li><li>写处方和获取历史处方都需要一个 patientId ，从路由中获取</li><li>处方提交完成之后，下方历史处方需要同步更新</li><li>可以将下方表格中的一条处方复制到上方表单中，方便快速开方</li></ol><p>先简单分析一下，上半部分的表单和下半部分的表格功能虽然有耦合，但还是相对独立的，可以拆分为三个组件</p><ul><li>Prescription.vue 根组件</li><li>PrescriptionAdd.vue 写处方</li><li>PrescriptionHistory.vue 历史处方</li></ul><p><code>根组件</code>用于接收路由参数，因为需求中提到写处方和历史处方有一些联动，所以它可能还会承担两个兄弟组件间的通信作用。</p><p><code>写处方组件</code>有一部分独立的功能，那就是提交处方表单。需要联动的功能则是提交完成后通知<code>历史处方组件</code>更新数据。</p><p><code>历史处方组件</code>的独立功能是拉取展示历史数据，需要联动的功能是将一行数据复制发送给<code>写处方组件</code>。</p><p>每个组件的独立功能都比较简单，具体代码不予赘述。我们直接探讨需要联动的部分如何去实现。</p><p>第一个要探讨的点是路由中的参数 patientId 如何传递。最简单暴力的方式就是随用随取了: <code>this.$route.params.patientId</code> 。但是很明显，作为一个稍微有一点点追求的人，都不会用这种方式，因为耦合度太高了，所以我们选择通过路由组件传参的方式将 patientId 以 prop 的方式传递给<code>根组件</code>。然后再继续通过 prop 的方式将其传递给<code>写处方</code>和<code>历史处方</code>组件。</p><p>我们再考虑的长远一些，随着业务的不断增长需求也不断变化，有可能<code>写处方</code>和<code>历史处方</code>两个组件也会变成类似<code>根组件</code>一样的容器组件，这样可能又会抽一些组件出去，又要继续将 patientId 向更深层的子组件传递。再极端一点，可能有时候我们为了传递一个 prop 中间隔了很多层组件，而这个 prop 在这些组件却不会被使用到。</p><p>那有没有其他方法呢？这里就要引出本文所介绍的 <code>provide</code>&#x2F;<code>inject</code>。两者配合可以跨层级传递数据和方法，ElementUI 的表单组件就大量运用了这个功能，但它有一个明显的缺陷， <code>provide</code> 和 <code>inject</code> 绑定不是响应式的，这是 Vue 故意这样设计的，当然如果传入的是一个可监听对象，那对象的属性还是响应式的。</p><p><img src="/2020/11/17/provide%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="provide示意图"></p><p>所以，我们可以用 <code>provide</code>&#x2F;<code>inject</code> 代替 prop 传递数据。这时候你可能会问，通过 <code>provide</code>&#x2F;<code>inject</code> 传递数据，那组件的复用性不就大大降低了吗，因为在使用的时候，必须保证被注入数据的子组件在有同样 <code>provide</code> 的父组件中使用。确实如此，但其实这种担心全是多余的，因为这一原则只适用于业务组件，业务组件的封装主要目的是提升代码的可维护性，也很少有复用的场景，<strong>即使有也是一个完整的业务流程，既 <code>provide</code> 和 <code>inject</code> 一定会同时存在。</strong> 如果出现了特殊的场景，可能要考虑组件的粒度是否需要更细致一些。当然这种方式千万不要用在基础组件中，比如上文所提到 Button 。</p><p>这样一来，我们的三个组件代码类似下面这样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Prescription&#x27;</span>, <span class="comment">// 强烈建议书写Name，方便在devtool调试</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 通过路由组件传参，将路由参数以 prop 方式传递给路由组件</span></span><br><span class="line">    <span class="attr">patientId</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>],</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 通过 provide 将 patientId 注入到子孙后代组件中</span></span><br><span class="line">      <span class="attr">patientId</span>: <span class="variable language_">this</span>.<span class="property">patientId</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;PrescriptionHistory&#x27;</span>,</span><br><span class="line">  <span class="comment">// 通过 inject 从父组件获取注入的 patientId</span></span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;patientId&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个要解决的问题是，如何解决两个兄弟组件间的数据通信。既在写处方完成之后如何通知<code>历史处方组件</code>更新数据，和如何将历史处方的数据发送到<code>写处方组件中</code>。</p><p>有一些经验的开发者可能早就想到用 Event Bus 了。在完成对应的操作之后，将相关的数据通过 Event Bus <code>emit</code> 一个事件发送出去，然后在需要订阅的组件内订阅相关事件，简略的代码大概如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;PrescriptionAdd&#x27;</span>,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">onSubmit</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">/** some code */</span></span><br><span class="line">      <span class="comment">// 提交表单完成后，发布事件</span></span><br><span class="line">      bus.$emit(<span class="string">&#x27;prescription-add-success&#x27;</span>, <span class="variable language_">this</span>.<span class="property">prescriptionFormList</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将历史数据转换为表单数据 */</span></span><br><span class="line">    <span class="title function_">history2From</span>(<span class="params">data</span>) &#123; &#125;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** 在生命周期中订阅和取消订阅事件 */</span></span><br><span class="line">    bus.$on(<span class="string">&#x27;copy-prescription&#x27;</span>, <span class="variable language_">this</span>.<span class="property">history2From</span>);</span><br><span class="line">    <span class="variable language_">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      bus.$off(<span class="string">&#x27;copy-prescription&#x27;</span>, <span class="variable language_">this</span>.<span class="property">history2From</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;PrescriptionHistory&#x27;</span>,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">onCopy</span>(<span class="params">row</span>) &#123;</span><br><span class="line">      <span class="comment">// 将选中的数据发送出去</span></span><br><span class="line">      bus.$emit(<span class="string">&#x27;copy-prescription&#x27;</span>, row);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取历史处方数据</span></span><br><span class="line"><span class="comment">     * 不要怕名字长，一定要做到表意清晰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getPrescriptionHistoryList</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** 在生命周期中订阅和取消订阅事件 */</span></span><br><span class="line">    bus.$on(<span class="string">&#x27;prescription-add-success&#x27;</span>, <span class="variable language_">this</span>.<span class="property">getPrescriptionHistoryList</span>);</span><br><span class="line">    <span class="variable language_">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      bus.$off(<span class="string">&#x27;prescription-add-success&#x27;</span>, <span class="variable language_">this</span>.<span class="property">getPrescriptionHistoryList</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式实现起来很简单，甚至不需要父组件的参与。但是这就造成了事件满天飞的后果，一堆的 emit(‘xxx’) 这样的魔法自字符串不是很好维护，如果将这些事件名单独维护在一个文件中，又会像 redux 那样罗里吧嗦的。本人是很讨厌这样的模式，甚至因为魔法字符串的问题，我已经在新的项目中放弃了 Vuex 。</p><p>如果不用 Event Bus 的方式，还可使用 ref + $emit 的形式，主要思路就是由他们相同的父组件去订阅各自派发出的事件:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PrescriptionAdd</span> <span class="attr">ref</span>=<span class="string">&quot;PrescriptionAdd&quot;</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">prescription-add-success</span>=<span class="string">&quot;onPrescriptionAddSuccess&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">PrescriptionHistory</span> <span class="attr">ref</span>=<span class="string">&quot;PrescriptionHistory&quot;</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">copy-prescription</span>=<span class="string">&quot;onCopyPrescription&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Prescription&#x27;</span>,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title class_">PrescriptionAdd</span>: &#123;</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">PrescriptionAdd</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title class_">PrescriptionHistory</span>: &#123;</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">PrescriptionHistory</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">onPrescriptionAddSuccess</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">PrescriptionHistory</span></span><br><span class="line">        .<span class="title function_">getPrescriptionHistoryList</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">onCopyPrescription</span>(<span class="params">row</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">PrescriptionHistory</span></span><br><span class="line">        .<span class="title function_">history2From</span>(row);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以从一定程度上减少事件满天飞情况，但是已经让父组件参与进来了。而且不论是哪一种，两个完整的功能都被分散到三个(或以上的)文件当中。那从站在可维护的角度来说，我们肯定希望相关功能的代码不要被拆的七零八散，写的到出都是。如果能写在一起，不仅对后续的维护者是一种便利，就连 code review 也变得轻松很多。</p><h2 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide &amp; inject"></a>provide &amp; inject</h2><p>如何将这个功能写在一起呢？这时候就可以用到 <code>provide</code>&#x2F;<code>inject</code> 了。在 Vue 中用 js 写依赖注入有连个很明明显的缺陷:</p><ol><li>非响应式</li><li>没有一点点的类型提示</li></ol><p>这时候我们可以借助 <a href="https://github.com/kaorun343/vue-property-decorator">vue-property-decorator</a> 提供的一些装饰器，通过 ts 的方式来写 Vue ，社区中已经有很多很多关于 vue-property-decorator 的介绍了，这里不再便赘述了(<a href="https://onlymisaky.github.io/2020/08/17/">安利一下自己写的ppt</a>)。</p><p>这里主要使用 <code>ProvideReactive</code> 和 <code>InjectReactive</code> 这两个装饰器。 <code>ProvideReactive</code>&#x2F;<code>InjectReactive</code> 是 <code>provide</code>&#x2F;<code>inject</code> 的反射版本，直白的讲就是让注入的值由非响应变为响应式。</p><blockquote><p>额外补充: <br />ProvideReactive 是将所有被注入数据包装成名称为 <code>__reactiveInject__</code> 的对象传入子孙组件，子孙组件中 的 InjectReactive 再通过属性计算的方式将 <code>__reactiveInject__</code> 映射到当前组件中，从而实现数据的同步更新，原理还是利用 <strong>当然如果传入的是一个可监听对象，那对象的属性还是响应式的</strong> 。</p></blockquote><p>接下来，我们忘记前面所有的，甚至忘记组件封装，原型图长什么样。要做的就是将开处方、查看历史处方、复制处方这些一连串的功能在一个类中实现，业务场景中也可以拆分成多个类，再通过 Mixins 的方式聚合到一起，这样一来我们大概会得到这样一份代码: </p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Prop</span>, <span class="title class_">Vue</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Prescription&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Prescription</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@ProvideReactive</span>()</span><br><span class="line">  <span class="meta">@Prop</span>(&#123; <span class="attr">type</span>: <span class="title class_">Number</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="keyword">readonly</span> patientId!: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  prescriptionFormList = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onDelFormItem</span>(<span class="params">index</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onSubmit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">getPrescriptionHistoryList</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  prescriptionHistoryList = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getPrescriptionHistoryList</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onCopyPrescription</span>(<span class="params"><span class="attr">row</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">history2From</span>(row);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">history2From</span>(<span class="params"><span class="attr">data</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = &#123; <span class="comment">/** */</span> &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prescriptionFormList</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再按照最初的思路去拆分并编写组件:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;PrescriptionAdd&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Prescription</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@InjectReactive</span>()</span><br><span class="line">  <span class="keyword">readonly</span> patientId!: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  prescriptionFormList = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onDelFormItem</span>(<span class="params">index</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onSubmit</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;PrescriptionHistory&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Prescription</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@InjectReactive</span>()</span><br><span class="line">  <span class="keyword">readonly</span> patientId!: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  prescriptionHistoryList = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getPrescriptionHistoryList</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onCopyPrescription</span>(<span class="params"><span class="attr">row</span>: <span class="built_in">any</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写到这里就会发现，父组件和子孙组件有很多相同的数据和方法，那就在父组件(根组件)中，为需要注入到子孙组件中的属性加上 <code>@ProvideReactive</code> 装饰器，在子孙组件中相对应的数据上加上 <code>@InjectReactive</code> 装饰器，同时删除细节只保留声明，需要注意的是，虽然通过 Reactive 注入的数据虽然是响应式的，但依旧是单向数据流，所以对子孙组件而言仍旧是只读的，所以需要像 prop 一样加上 <code>readonly</code> 修饰符；需要注入到子孙组件中的方法则加上 <code>@Provide</code> 装饰器，这也可以节省更多的内存开销，修改之后代码如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Prescription&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Prescription</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@ProvideReactive</span>()</span><br><span class="line">  <span class="meta">@Prop</span>(&#123; <span class="attr">type</span>: <span class="title class_">Number</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="keyword">readonly</span> patientId!: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ProvideReactive</span>()</span><br><span class="line">  prescriptionFormList = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onDelFormItem</span>(<span class="params">index</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onSubmit</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ProvideReactive</span>()</span><br><span class="line">  prescriptionHistoryList = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getPrescriptionHistoryList</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onCopyPrescription</span>(<span class="params"><span class="attr">row</span>: <span class="built_in">any</span></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">history2From</span>(<span class="params">data</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;PrescriptionAdd&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">PrescriptionAdd</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@InjectReactive</span>()</span><br><span class="line">  <span class="keyword">readonly</span> patientId!: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@InjectReactive</span>()</span><br><span class="line">  <span class="keyword">readonly</span> prescriptionFormList!: <span class="built_in">any</span>[];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span>()</span><br><span class="line">  <span class="keyword">readonly</span> onDelFormItem!: <span class="function">(<span class="params">index</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span>()</span><br><span class="line">  <span class="keyword">readonly</span> onSubmit!: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;PrescriptionHistory&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">PrescriptionHistory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@InjectReactive</span>()</span><br><span class="line">  <span class="keyword">readonly</span> patientId!: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@InjectReactive</span>()</span><br><span class="line">  <span class="keyword">readonly</span> prescriptionHistoryList!: <span class="built_in">any</span>[];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span>()</span><br><span class="line">  <span class="keyword">readonly</span> getPrescriptionHistoryList!: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span>()</span><br><span class="line">  <span class="keyword">readonly</span> onCopyPrescription!: <span class="function">(<span class="params"><span class="attr">row</span>: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getPrescriptionHistoryList</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就把主要的(连续的)逻辑全部塞进了 <code>Prescription</code> 组件当中。这样做的优势不言而喻， code review 简直太爽了，同样代码的可维护性也有一定的提升。</p><p>但缺点也很明显: </p><ol><li>有太多冗余的声明</li><li>部分子孙组件完全弱化成了一个壳子，主要作用也就是模板了</li><li>在某些场景下，注入的数据可能会被子孙组件修改，虽然我们可以在父组件中为子孙组件 <code>Provide</code> 修改数据的方法，但还是会显得极为繁琐，比如上文例子中的 <code>prescriptionFormList</code> ，我们需要修改 <code>给药途径</code>, <code>单次剂量</code>, <code>数量</code>, <code>备注</code>。虽然可以直接在子组件内修改(因为是引用类型，是可以直接修改的)，但是这毕竟违背了单向数据流的原则。而且对于浅层次的数据，直接在子孙组件中修改，也会在控制台中抛出错误。</li></ol><h2 id="Vue3-中的依赖注入"><a href="#Vue3-中的依赖注入" class="headerlink" title="Vue3 中的依赖注入"></a>Vue3 中的依赖注入</h2><p>虽有 Vue 中的依赖注入有这些缺点，官方文档中也不推荐使用，但不妨碍它成为一个组织业务代码的大杀器。而且随着 Vue3 的到来，上面的这些缺点也都统统解决了。</p><p>Vue3 的组合式 API 为我们提供了 <code>provide</code> 和 <code>inject</code> 这两个方法，它们的作用和 Vue2 的依赖注入相同。但是它们可以将响应式数据 <code>ref</code> 和 <code>reactive</code> 注入到子孙组件中，这意味着我们不需要再用 hack 的方式让注入的值变为响应式，也不用再考虑因单向数据流而带来的复杂更新操作了，再配合上自定义 hook ，也能省去很多繁琐的声明，如果非要确保通过 <code>provide</code> 传递的数据不会被 <code>inject</code> 的组件更改，则可以使用 <code>readonly</code> 方法。</p><p>同样是开处方的需求为例，我们用 Composition Api 的方式来实现一下:</p><ol><li>首先写一个比较长的 hook ，将所需的业务代码代码组织起来</li></ol><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PrescriptionContext</span> &#123;</span><br><span class="line">  <span class="attr">prescriptionFormList</span>: <span class="title class_">Ref</span>&lt;<span class="built_in">any</span>[]&gt;;</span><br><span class="line">  <span class="title function_">onDelFormItem</span>(<span class="attr">index</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">onSubmit</span>(): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">prescriptionHistoryList</span>: <span class="title class_">Ref</span>&lt;<span class="built_in">any</span>[]&gt;;</span><br><span class="line">  <span class="title function_">getPrescriptionHistoryList</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">onCopyPrescription</span>(<span class="attr">row</span>: <span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 InjectionKey 接口提供类型支持</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PrescriptionToken</span>: <span class="title class_">InjectionKey</span>&lt;<span class="title class_">PrescriptionContext</span>&gt; = <span class="title class_">Symbol</span>(<span class="string">&#x27;PrescriptionToken&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">usePrescriptionProvider</span>(<span class="params">patientId</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> prescriptionFormList = <span class="title function_">ref</span>([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onDelFormItem</span>(<span class="params"><span class="attr">index</span>: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onSubmit</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prescriptionHistoryList = <span class="title function_">ref</span>([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getPrescriptionHistoryList</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onCopyPrescription</span>(<span class="params"><span class="attr">row</span>: <span class="built_in">any</span></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">provide</span>(<span class="title class_">PrescriptionToken</span>, &#123;</span><br><span class="line">    prescriptionFormList,</span><br><span class="line">    onDelFormItem,</span><br><span class="line">    onSubmit,</span><br><span class="line">    prescriptionHistoryList,</span><br><span class="line">    getPrescriptionHistoryList,</span><br><span class="line">    onCopyPrescription,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">getPrescriptionHistoryList</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">usePrescriptionInject</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> prescriptionContext = inject&lt;<span class="title class_">PrescriptionContext</span>&gt;(<span class="title class_">PrescriptionToken</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prescriptionContext) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;usePrescriptionInject must be used after usePrescriptionProvider&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prescriptionContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>剩下的工作就是愉快的复制粘贴模板了</li></ol><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Prescription&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">patientId</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="title function_">usePrescriptionProvider</span>(props.<span class="property">patientId</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;PrescriptionAdd&#x27;</span>,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      prescriptionFormList,</span><br><span class="line">      onDelFormItem,</span><br><span class="line">      onSubmit,</span><br><span class="line">    &#125; = <span class="title function_">usePrescriptionInject</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      prescriptionFormList,</span><br><span class="line">      onDelFormItem,</span><br><span class="line">      onSubmit,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;PrescriptionHistory&#x27;</span>,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      prescriptionHistoryList,</span><br><span class="line">      getPrescriptionHistoryList,</span><br><span class="line">      onCopyPrescription,</span><br><span class="line">    &#125; = <span class="title function_">usePrescriptionInject</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      prescriptionHistoryList,</span><br><span class="line">      getPrescriptionHistoryList,</span><br><span class="line">      onCopyPrescription,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样一番改造之后，有没有发现单文件组件完全沦为了 <code>模板</code> 和 <code>setup</code> 的容器，我们的将所有业务逻辑全都迁移到了自定义 hook 当中，是不是更加清爽了许多，而且还可以利用所学的设计模式，继续魔改我们的 <code>usePrescriptionProvider</code> 。什么？你觉得烦？但这不就是架构师该做的事情么(让别人参照自己的规范编写代码，同时提供周边的工具链)。 webpack 配置工程师是不会的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue-的组件通信方式&quot;&gt;&lt;a href=&quot;#Vue-的组件通信方式&quot; class=&quot;headerlink&quot; title=&quot;Vue 的组件通信方式&quot;&gt;&lt;/a&gt;Vue 的组件通信方式&lt;/h2&gt;&lt;p&gt;开篇先俗套一下，在 Vue 中，组件间的通信有以下几种方式: &lt;/p</summary>
      
    
    
    
    
    <category term="vue" scheme="http://onlymisaky.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Event Loop</title>
    <link href="http://onlymisaky.github.io/2020/08/28/"/>
    <id>http://onlymisaky.github.io/2020/08/28/</id>
    <published>2020-08-28T09:37:00.000Z</published>
    <updated>2024-09-11T03:04:28.922Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>script start<br>async1 start<br>async2<br>promise1<br>script end<br>async1 end<br>promise2<br>setTimeout</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;key</summary>
      
    
    
    
    
    <category term="自己看" scheme="http://onlymisaky.github.io/tags/%E8%87%AA%E5%B7%B1%E7%9C%8B/"/>
    
    <category term="面试题" scheme="http://onlymisaky.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="Event Loop" scheme="http://onlymisaky.github.io/tags/Event-Loop/"/>
    
  </entry>
  
  <entry>
    <title>about me</title>
    <link href="http://onlymisaky.github.io/2020/08/21/"/>
    <id>http://onlymisaky.github.io/2020/08/21/</id>
    <published>2020-08-21T03:47:24.000Z</published>
    <updated>2024-09-11T03:04:28.934Z</updated>
    
    <content type="html"><![CDATA[<!-- .slide: data-background-image="background-1.png" --><h1 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h1><ul><li>姓名：朱士奇<!-- .element: class="fragment" --></li><li>入职日期：2018年04月20日<!-- .element: class="fragment" --></li><li>担任职位：平台组前端开发<!-- .element: class="fragment" --></li><li>主要职责：HIS, 中控, 正夫HIS…<!-- .element: class="fragment" -->&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</li></ul><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>—-分段—-<br><img src="/2020/08/21/logo-ch.png" alt="江苏楚淮"></p><h3 id="江苏楚淮"><a href="#江苏楚淮" class="headerlink" title="江苏楚淮"></a>江苏楚淮</h3><p>—-分段—-<br><img src="/2020/08/21/logo-thinkerx.png" alt="上海铝神"></p><h3 id="上海铝神"><a href="#上海铝神" class="headerlink" title="上海铝神"></a>上海铝神</h3><p>—-分段—-<br><img src="/2020/08/21/logo-xr.png" alt="企鹅杏仁💕💖"></p><h2 id="企鹅杏仁💕💖"><a href="#企鹅杏仁💕💖" class="headerlink" title="企鹅杏仁💕💖"></a>企鹅杏仁💕💖</h2><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h1><ul><li>Asp.Net Winform<!-- .element: class="fragment" --></li><li>jQuery<!-- .element: class="fragment" --></li><li>AngularJs(ng1.x) gulp<!-- .element: class="fragment" --></li><li>Vue webpack<!-- .element: class="fragment" --></li><li>react,php,hybrid<!-- .element: class="fragment" -->&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</li></ul><h1 id="擅长"><a href="#擅长" class="headerlink" title="擅长"></a>擅长</h1><ul><li>排查js方面的疑难杂症<!-- .element: class="fragment" --></li><li>爱造小轮子<!-- .element: class="fragment" --></li><li>喜欢追一些新的js技术<!-- .element: class="fragment" --></li><li>oop叛逃者<!-- .element: class="fragment" -->&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</li></ul><h1 id="弱项😿"><a href="#弱项😿" class="headerlink" title="弱项😿"></a>弱项😿</h1><ul><li>英语极差<!-- .element: class="fragment" --></li><li>css严重退化<!-- .element: class="fragment" --></li><li>移动端技巧几乎荒废<!-- .element: class="fragment" -->&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;<!-- .slide: data-background-image="background-1.png" --></li></ul><h1 id="谢谢"><a href="#谢谢" class="headerlink" title="谢谢"></a>谢谢</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- .slide: data-background-image=&quot;background-1.png&quot; --&gt;
&lt;h1 id=&quot;个人介绍&quot;&gt;&lt;a href=&quot;#个人介绍&quot; class=&quot;headerlink&quot; title=&quot;个人介绍&quot;&gt;&lt;/a&gt;个人介绍&lt;/h1&gt;&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue-property-decorator</title>
    <link href="http://onlymisaky.github.io/2020/08/17/"/>
    <id>http://onlymisaky.github.io/2020/08/17/</id>
    <published>2020-08-17T03:47:24.000Z</published>
    <updated>2024-09-11T03:04:28.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h3><p>分享人：onlymisaky</p><!-- .element: class="fragment fade-up" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>—-分段—-</p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>—-分段—-</p><h2 id="🤔🤔🤔"><a href="#🤔🤔🤔" class="headerlink" title="🤔🤔🤔"></a>🤔🤔🤔</h2><h2 id="Why-TypeScript"><a href="#Why-TypeScript" class="headerlink" title="Why TypeScript"></a>Why TypeScript</h2><!-- .element: class="fragment" --><p>—-分段—-</p><h2 id="😍🤤"><a href="#😍🤤" class="headerlink" title="😍🤤"></a>😍🤤</h2><p><img src="/2020/08/17/ts%E7%9C%9F%E9%A6%99.gif" alt="ts真香"></p><!-- .element: class="fragment" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>—-分段—-<br>options api</p><p>![options api](options api.png)</p><!-- .element: class="fragment" style="max-height: 60vh;" --><p>—-分段—-<br>Vue.extends</p><p><img src="/2020/08/17/Vue.extends1.png" alt="Vue.extends1"></p><!-- .element: class="fragment" style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Vue.extends2.png" alt="Vue.extends2"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-</p><p>💩💩💩</p><h3 id="宁愿不用"><a href="#宁愿不用" class="headerlink" title="宁愿不用"></a>宁愿不用</h3><!-- .element: class="fragment" --><p>—-分段—-</p><h3 id="等一等，还有别的办法"><a href="#等一等，还有别的办法" class="headerlink" title="等一等，还有别的办法"></a>等一等，还有别的办法</h3><p>—-分段—-</p><h3 id="借鉴大法！！"><a href="#借鉴大法！！" class="headerlink" title="借鉴大法！！"></a>借鉴大法！！</h3><p>—-分段—-<br><img src="/2020/08/17/React.png" alt="React"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/ng.png" alt="ng"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-</p><h3 id="或许我们也可以😏…"><a href="#或许我们也可以😏…" class="headerlink" title="或许我们也可以😏…"></a>或许我们也可以😏…</h3><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h2><p>—-分段—-<br><img src="/2020/08/17/VueClass1.png" alt="VueClass1"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/VueClass2.png" alt="VueClass2"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-</p><h3 id="还是不好用😤😤"><a href="#还是不好用😤😤" class="headerlink" title="还是不好用😤😤"></a>还是不好用😤😤</h3><p><img src="/2020/08/17/%E8%BF%9B%E5%85%A5%E4%B8%BB%E9%A2%98.gif" alt="进入主题"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/%E8%A3%85%E9%A5%B0%E5%99%A8.gif" alt="装饰器"><br>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Decorator"><a href="#Decorator" class="headerlink" title="@Decorator"></a>@Decorator</h1><p class="fragment">AOP（面向切面）</p><p class="fragment">装饰模式</p><p class="fragment">TC39</p><p class="fragment">ECMAScript</p>----分段----* Stage 0: strawman（想法）——最初想法的提交。<!-- .element: class="fragment" -->* Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。<!-- .element: class="fragment" --><li class="fragment">  <span class="fragment highlight-red">    Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。  </span></li>* Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈<!-- .element: class="fragment" -->* Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间<!-- .element: class="fragment" -->----分段----- ClassDecorator<!-- .element: class="fragment" -->- PropertyDecorator<!-- .element: class="fragment" -->- MethodDecorator<!-- .element: class="fragment" -->- ParameterDecorator<!-- .element: class="fragment" -->====分页====<h2 id="ClassDecorator"><a href="#ClassDecorator" class="headerlink" title="ClassDecorator"></a>ClassDecorator</h2><p><img src="/2020/08/17/ClassDecorator%E7%AD%BE%E5%90%8D.png" alt="ClassDecorator签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Singleton.Class.png" alt="Singleton.Class"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Singleton.Decorator.png" alt="Singleton.Decorator"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="PropertyDecorator"><a href="#PropertyDecorator" class="headerlink" title="PropertyDecorator"></a>PropertyDecorator</h2><p><img src="/2020/08/17/PropertyDecorator%E7%AD%BE%E5%90%8D.png" alt="PropertyDecorator签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/readonly.png" alt="readonly"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="MethodDecorator"><a href="#MethodDecorator" class="headerlink" title="MethodDecorator"></a>MethodDecorator</h2><p><img src="/2020/08/17/MethodDecorator%E7%AD%BE%E5%90%8D.png" alt="MethodDecorator签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Auth.png" alt="Auth"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Auth.Fn.png" alt="Auth.Fn"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Auth.Decorator.png" alt="Auth.Decorator"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="ParameterDecorator"><a href="#ParameterDecorator" class="headerlink" title="ParameterDecorator"></a>ParameterDecorator</h2><p><img src="/2020/08/17/ParameterDecorator%E7%AD%BE%E5%90%8D.png" alt="ParameterDecorator签名"></p><!-- .element: class="fragment" --><p>—-分段—-</p><ul><li>notNull</li><li>nestjs @Req() @Query @Param()<br>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</li></ul><h1 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h1><p><img src="/2020/08/17/Component%E7%AD%BE%E5%90%8D.png" alt="Component签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Component%E7%94%A8%E6%B3%95.png" alt="Component用法"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Component%E8%BD%AC%E6%8D%A2.png" alt="Component转换"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><!-- .element: class="fragment" --><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><!-- .element: class="fragment" --><h2 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a>Computed</h2><!-- .element: class="fragment" --><h2 id="Life-cycle"><a href="#Life-cycle" class="headerlink" title="Life cycle"></a>Life cycle</h2><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Component.Class%E7%94%A8%E6%B3%95.png" alt="Component.Class用法"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Component.Class%E8%BD%AC%E6%8D%A2.png" alt="Component.Class转换"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h1><p><img src="/2020/08/17/Mixins%E7%AD%BE%E5%90%8D.png" alt="Mixins签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Mixins%E7%94%A8%E6%B3%95.png" alt="Mixins用法"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Mixins%E8%BD%AC%E6%8D%A2.png" alt="Mixins转换"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h1><p><img src="/2020/08/17/Prop%E7%AD%BE%E5%90%8D.png" alt="Prop签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Prop%E7%94%A8%E6%B3%95.png" alt="Prop用法"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Prop%E8%BD%AC%E6%8D%A2.png" alt="Prop转换"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="PropSync"><a href="#PropSync" class="headerlink" title="PropSync"></a>PropSync</h1><p><img src="/2020/08/17/PropSync%E7%AD%BE%E5%90%8D.png" alt="PropSync签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/PropSync%E7%94%A8%E6%B3%95.png" alt="PropSync用法"><br>—-分段—-<br><img src="/2020/08/17/PropSync%E8%BD%AC%E6%8D%A2.png" alt="PropSync转换"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h1><p><img src="/2020/08/17/Model%E7%AD%BE%E5%90%8D.png" alt="Model签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Model%E7%94%A8%E6%B3%95.png" alt="Model用法"><br>—-分段—-<br><img src="/2020/08/17/Model%E8%BD%AC%E6%8D%A2.png" alt="Model转换"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h1><p><img src="/2020/08/17/Watch%E7%AD%BE%E5%90%8D.png" alt="Watch签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Watch%E7%94%A8%E6%B3%95.png" alt="Watch用法"><br>—-分段—-<br><img src="/2020/08/17/Watch%E8%BD%AC%E6%8D%A2.png" alt="Watch转换"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Provide"><a href="#Provide" class="headerlink" title="Provide"></a>Provide</h1><p><img src="/2020/08/17/Provide%E7%AD%BE%E5%90%8D.png" alt="Provide签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Provide%E7%94%A8%E6%B3%95.png" alt="Provide用法"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Provide%E8%BD%AC%E6%8D%A2.png" alt="Provide转换"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Inject"><a href="#Inject" class="headerlink" title="Inject"></a>Inject</h1><p><img src="/2020/08/17/Inject%E7%AD%BE%E5%90%8D.png" alt="Inject签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Inject%E7%94%A8%E6%B3%95.png" alt="Inject用法"><br>—-分段—-<br><img src="/2020/08/17/Inject%E8%BD%AC%E6%8D%A2.png" alt="Inject转换"><br>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Emit"><a href="#Emit" class="headerlink" title="Emit"></a>Emit</h1><p><img src="/2020/08/17/Emit%E7%AD%BE%E5%90%8D.png" alt="Emit签名"></p><!-- .element: class="fragment" style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Emit%E7%94%A8%E6%B3%95.png" alt="Emit用法"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Emit%E8%BD%AC%E6%8D%A2.png" alt="Emit转换"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><img src="/2020/08/17/Ref%E7%AD%BE%E5%90%8D.png" alt="Ref签名"></p><!-- .element: class="fragment" --><p>—-分段—-<br><img src="/2020/08/17/Ref%E7%94%A8%E6%B3%95.png" alt="Ref用法"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Ref%E8%BD%AC%E6%8D%A2.png" alt="Ref转换"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Ref.png" alt="Ref"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><p>—-分段—-</p><h3 id="增强类型提示"><a href="#增强类型提示" class="headerlink" title="增强类型提示"></a>增强类型提示</h3><p>src&#x2F;shims-vue.d.ts</p><!-- .element:  class="fragment" data-fragment-index="0" --><p><img src="/2020/08/17/shims-vue.d.png" alt="shims-vue.d"></p><!-- .element: class="fragment" data-fragment-index="0" style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/VueRouter.d.png" alt="VueRouter.d"></p><!-- .element: style="max-height: 60vh;" --><p>—-分段—-<br><img src="/2020/08/17/Vuex.d.png" alt="Vuex.d"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h1><p>—-分段—-<br><img src="/2020/08/17/router%E5%AE%9A%E4%B9%89.png" alt="router定义"></p><!-- .element: style="max-height: 60vh;" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>—-分段—-</p><ul><li><a href="https://github.com/ktsn/vuex-class/">vuex-class</a></li><li><a href="https://github.com/championswimmer/vuex-module-decorators#readme">vuex-module-decorators</a><br>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</li></ul><h1 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h1><p><img src="/2020/08/17/%E6%8F%90%E9%97%AE%E7%8E%AF%E8%8A%82.gif" alt="提问环节"></p><!-- .element: class="fragment" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><p><img src="/2020/08/17/%E8%AE%B2%E7%9A%84%E5%BE%88%E5%A5%BD.gif" alt="讲的很好"></p><h3 id="愣着干啥，快👏👏👏"><a href="#愣着干啥，快👏👏👏" class="headerlink" title="愣着干啥，快👏👏👏"></a>愣着干啥，快👏👏👏</h3><!-- .element: class="fragment" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h3 id="没有了，别翻了，快去吃饭吧"><a href="#没有了，别翻了，快去吃饭吧" class="headerlink" title="没有了，别翻了，快去吃饭吧"></a>没有了，别翻了，快去吃饭吧</h3><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><h3 id="我说的话你就这么不信吗"><a href="#我说的话你就这么不信吗" class="headerlink" title="我说的话你就这么不信吗"></a>我说的话你就这么不信吗</h3><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><p>都翻到这里了，原来我在你心里的分量也不错如此，算了你走吧<br>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><p>我让你走你就走，你就不知道再多问一下吗，果然你的心里只有吃饭🥺🥺🥺</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue-property-decorator&quot;&gt;&lt;a href=&quot;#vue-property-decorator&quot; class=&quot;headerlink&quot; title=&quot;vue-property-decorator&quot;&gt;&lt;/a&gt;vue-property-decorat</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue3介绍</title>
    <link href="http://onlymisaky.github.io/2020/06/30/"/>
    <id>http://onlymisaky.github.io/2020/06/30/</id>
    <published>2020-06-30T09:53:25.000Z</published>
    <updated>2024-09-11T03:04:29.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><blockquote><p>在做了一个又一个的xx管理系统后，好像生活变得更枯燥乏味了，逐渐的在一次又一次的复制粘贴中迷失自我。不甘如此的17开寻求新的出口，既然都是在 ctrl+c  ctrl+v 那位了不 cv 的更上流一些呢？</p></blockquote><p>前端的逻辑复用一直是个讨论的热点话题，毕竟程序员都那么懒，懒到连复制粘贴都不想，所以就想尽办法的抽取封装通用的业务逻辑。那什么是<strong>业务逻辑</strong>呢，从代码层面来讲，就是一些数据( <code>Data</code> )和一些事件、方法( <code>Method</code> )的组合。</p><p>比如一个常见的列表页面，他可能会有以下这些数据、事件和方法:</p><ol><li>searchOptions 用于搜索查询过滤列表的参数</li><li>list 列表所展示所需要用到的数组数据</li><li>pagination 存储分页信息的数据</li><li>getList 用于拉取列表数据的接口调用</li><li>onChangePage onSearch onFilter 翻页搜索过滤等事件</li></ol><p>所以像状态管理(<code>redux</code>,<code>vuex</code>等)和一些工具方法(表单校验,防抖节流等)都不能算是逻辑复用的方案。</p><p>接下来我们先看看当前比较主流的逻辑复用方案都有哪些。</p><h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><p>Mixin 是一种借鉴 <code>OOP</code> 的逻辑复用方式，直觉上来讲，它很像<strong>多重继承</strong>，但实际上它是<strong>组合</strong>，将多个方法和属性合并到一个对象中，像 jQuery 中的 <code>$.extend</code> <code>$.fn.extend</code> ，早期的 React 和 Vue2.x 都是通过这种方式来实现逻辑复用的。</p><p>React 中的 Mixin</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Mixin1</span> = &#123;</span><br><span class="line">  <span class="title function_">getMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Mixin2</span> = &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Mixin2.componentDidMount()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [<span class="title class_">Mixin1</span>, <span class="title class_">Mixin2</span>],</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.getMessage()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Vue 中的 Mixin</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Mixin1</span> = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">list</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">getList</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fetchData</span>(<span class="variable language_">this</span>.<span class="property">searchOptions</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span> = res.<span class="property">data</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Mixin2</span> = &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Mixin2.created()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = &#123;</span><br><span class="line">  <span class="attr">mixins</span>: [<span class="title class_">Mixin1</span>, <span class="title class_">Mixin2</span>],</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">searchOptions</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getList</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了防止 Minix 的使用不当，React 和 Vue 又对其进行了一些限制和合并策略上的调整，比如在 React 中:</p><ol><li>如果 mixins 中有相同的属性会直接抛出异常。</li><li>constructor 、render 和 shouldComponentUpdate 也是不允许重复的。</li><li>如果有重复的 compoentDidMount 生命周期，会先执行 mixins 中的生命周期，然后再执行组件内的 compoentDidMount；</li></ol><p>在 Vue 中:</p><ol><li>相同的 data 会保留组件自己的 data </li><li>相同的 method  会被封装为一个数组，在调用的时候则会依次执行 mixins 中的 method 组件内的 method</li><li>相同的生命周期会合并到一个钩子中，依次执行 mixins 中的钩子，最后执行组件内的钩子</li></ol><p>Mixin虽然实现了业务逻辑的复用，但是却有着一些致命的缺陷:</p><ul><li><p>引入了不清晰的依赖关系<br>  Mixin1 可能还会依赖 Mixin2 ， Mixin2 可能还需要组件提供指定的方法，如果某个 Mixin 中的方法修改了，依赖它的 Mixin 可能会无法正常工作。这种复杂的依赖关系在 JavaScript 这种动态类型的语言中，会变成一种心智负担。</p></li><li><p>导致命名空间的冲突<br>  多个 Mixin 之间可能会存在相同的属性和方法，造成冲突。</p></li><li><p>滚雪球般的复杂度<br>  Mixin 是侵入式的，改变了原组，和组件之间高度耦合，尤其当依赖多个 Mixin 时，代码将变得难以预测，管理代码的复杂度也会直线上升。</p></li></ul><p>所以 React 很早就宣布放弃了这种方式，当然 Vue 也快了。</p><h3 id="HOC-Higher-Order-Components"><a href="#HOC-Higher-Order-Components" class="headerlink" title="HOC(Higher-Order Components)"></a>HOC(Higher-Order Components)</h3><p>有时候一些英文单词的缩写看起来很唬人， HOC 便是其中之一了。它的中文名叫高阶组件，直白的解释一下，它和高阶函数一样，只不过高阶组件的参数是 Component 返回的也还是 Component ，既: <code>const EnhancedComponent = higherOrderComponent(WrappedComponent);</code>。在 React 放弃 Mixin 之后，HOC 就成为了逻辑复用的推荐方案。</p><p>HOC 实现逻辑复用的原理将需要复用的代码抽离到函数中，然后通过 props 将其传递到下层组件当中，实际上就是对下层组件进行了一次包装，其实这就是<strong>装饰器模式</strong>。所以 HOC 并不算是 React 的一部分，它是一种基于 React 的组合特性而形成的设计模式。我们常用的 <code>react-redux</code> 中的 <code>connect</code> 就是一个高阶组件，它通过 props 将 store 中的 state 以 prop 的方式传递给下层组件。HOC很好的解决的了 Mixin 的缺陷。</p><p>React 中的 HOC :</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">List</span>(<span class="params">&#123; data &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.map(item =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withLoadData</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    state = &#123;</span><br><span class="line">      <span class="attr">data</span>: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">data</span>: [</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;11&#x27;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;22&#x27;</span> &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...this.state</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withLoadData</span>(<span class="title class_">List</span>);</span><br></pre></td></tr></table></figure><p>这是一个很简单的例子， <code>List</code> 组件只负责展示数据，没有任何多余的逻辑，而 <code>withLoadData</code> 则负责加载数据，当然你还可以在写一个 <code>withLoading</code> 来控制组件的 <code>laoding</code> 状态。</p><p>在 Vue 很少有提及 HOC 这个概念，可能主要是因为 Vue 是以模板为主要方式，没有 jsx 那样灵活，而且 Vue 的 props 需要显式的定义出来(可以通过 $attrs 绕做)，相对于 React 也多了一个事件的概念(对应 React 中的回调，如 <code>onInput</code> 等，可以用 $listeners 绕过 )。当然你要是想在 Vue 是使用高阶组件也不是不可以，在 React 中 <code>f(Component): NewComponent</code> ，那在 Vue 中就是 <code>f(Options): NewOptions</code>。但是还是极力不推荐在 Vue 中使用 HOC 。同样以上面的场景为例，Vue 中的 HOC:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">List</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;List&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.data.map(item =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withLoadData</span>(<span class="params">WrappedOptions</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;withLoadData&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: &#123; <span class="title class_">WrappedOptions</span> &#125;,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;Wrapped-Options v-on=&quot;$listeners&quot; v-bind=&quot;&#123;data:data, ...$attrs&#125;&quot; /&gt;`</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">data</span>: [],</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = [</span><br><span class="line">          &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;11&#x27;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;22&#x27;</span> &#125;,</span><br><span class="line">        ];</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withLoadData</span>(<span class="title class_">List</span>);</span><br></pre></td></tr></table></figure><p>同样的，HOC 自身也有一些令人不爽的小问题:</p><ul><li>扩展性限制，并不能完全替代 Mixin ，例如无法获取子组件的 state 等</li><li>Ref 被隔断</li><li>静态方法丢失</li><li>Wrapper Hell ，一层函数嵌套不够，那就多嵌套几层</li><li>性能有一定的影响</li></ul><!-- ### render proprender prop 则是属于 react 中 --><h2 id="hook的诞生"><a href="#hook的诞生" class="headerlink" title="hook的诞生"></a>hook的诞生</h2><p>介绍完了上面三种逻辑复用的方式，终于轮到 hook 出场了。</p><h3 id="假想"><a href="#假想" class="headerlink" title="假想"></a>假想</h3><p>如前面所提到的，所谓业务逻辑 <strong>就是一些数据( <code>Data</code> )和一些事件、方法( <code>Method</code> )的组合</strong>。如果抛开框架的束缚，我们能想到最直接、最简单的复用方式就是函数了。我们可以将这些有关联性的 Data 和 Method 都写在一起，然后放在一个函数中。但是有一个问题，如何保证这些 Data 能和 View 进行关联呢？</p><h3 id="Class-Component-与-Vue-的问题"><a href="#Class-Component-与-Vue-的问题" class="headerlink" title="Class Component 与 Vue 的问题"></a>Class Component 与 Vue 的问题</h3><p>在 React 中，我们可以在类组件中定义 <code>state</code> ，当显式的调用 <code>this.setState</code> 时，state 会发生改变，然后通过 vDOM diff 查找需要更新的区域，最后在更新真实的 DOM 树。如果用我们提到的方法，就遇到了一个问题，如何将这些 Data 和 Method 放进这个组件内，还有 <code>this</code> 指向也会是个不小的阻碍。</p><p>在 Vue 中也会遇到同样的问题，我们需要想办法将这些 Data 放进 <code>data</code> 或 <code>computed</code> 这个两个属性中，将 Method 放进 <code>methods</code> 属性中。而且 Vue 也需要考虑 <code>this</code> 指向的问题。</p><h3 id="Function-Component缺失的功能"><a href="#Function-Component缺失的功能" class="headerlink" title="Function Component缺失的功能"></a>Function Component缺失的功能</h3><p>如果是函数式组件，那就更不好办，函数式组件是没有状态，没有生命周期，他只能接受 props 作为参数，只有当 props 变更时，才会更新对应的 DOM 。所以就更没有办法将 Data 放进函数式组件当中了。</p><h3 id="Function-Component-Hook"><a href="#Function-Component-Hook" class="headerlink" title="Function Component + Hook"></a>Function Component + Hook</h3><p>不过 React 团队还是想出了办法让函数组件也能拥有自己的状态，且状态更新对应的视图也做出更新。那就是通过指定的方法在函数式组件内部创建和更新 state ：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Count</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useState 返回的结果是数组，数组的第一项是 state ，第二项是更新 state 函数，useState 函数的第一个参数就是默认值，也支持回调函数。在上述的例子中 <code>count</code> 和 <code>setCount</code> 分别对应逻辑中的 Data 和 Method 。这样便解决了函数式组件没有自己的状态的问题，为了让函数式组件能有和 class 组件类似的生命周期， react 还提供了 useState 方法。下面就介绍一下 react 中两个常用的 hook 。</p><h2 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h2><p>在介绍 React Hook 之前，需要知道以两点规则(限制)：</p><ul><li>hook 只能在函数式组件中使用</li><li>不要在循环，条件或嵌套函数中调用 Hook</li></ul><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>useState 让函数式组件也能拥有了自己的状态。当需要在组件内部拥有自己的状态时，便可以通过调用 useState 来创建 <code>state变量</code> ，不过你要遵循上面的两个条件。当你需要多个 <code>state变量</code> 的时候你就需要调用多次，这时候你可能就会遇到控制 state 粒度的问题了。</p><p>在传统的 class 组件中，我们是不用关心这个问题的，以 <code>TodoList</code> 组件为例，在 class 组件中，我们会这样写：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TodoList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">todoList</span>: [],</span><br><span class="line">    <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">filterText</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">filterType</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getTodoList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">loading</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/todos&#x27;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">todoList</span>: data,</span><br><span class="line">          <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在使用了 State Hook 之后，我们就要考虑这个问题了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TodoList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [todoList, setTodoList] = <span class="title function_">useState</span>([]);</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [filterText, setFilterText] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [filterType, setFilterType] = <span class="title function_">useState</span>(<span class="string">&#x27;all&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getTodoList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setLoading</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/todos&#x27;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="title function_">setTodoList</span>(data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们已经发现了两个问题了:</p><ol><li>函数开始很长一串的声明 <code>state</code> 变量的代码，这还仅仅是一个简单的组件</li><li>当需要同时更新多个 <code>state</code> 的时候，无法像 class 组件那样批量更新，而需要依次的去调用对应的 setXxx 方法。</li></ol><p>Q: 连续多次调用不同的 setXxx 会触发几次更新呢？</p><p>那可不可以将所有的 <code>state</code> 变量都通过一个 useState 生成呢？当然可以:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">  <span class="attr">todoList</span>: [],</span><br><span class="line">  <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">filterText</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">filterType</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是事情并不是像我们想象的那么美好，在 class 组件中， <code>setState</code> 会把更新的字段自动合并到 <code>this.state</code> 对象中。而在 <code>State Hook</code> 中，setXxx 做的是替换操作，所以每当我们需要更新某个 <code>state</code> 的时候，就需要这么写: <code>setState(&#123; ...state, todoList: data, loading: false &#125;)</code> 看起来好像也没什么，但是这样做又引入了新的问题，粒度过粗，代码的可复用性就会降低，也有些违背了 hook api 的初衷 。</p><p>所以，在使用 State Hook 的时候，结合业务场景，尽量遵循下面两点:</p><ol><li>将完全不相关的 state 拆分为多组 state</li><li>如果某些 state 是相互关联的，或者需要一起发生改变，就可以把它们合并为一组 state</li></ol><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>已经通过 useState 让函数式组件拥有了自己的状态，那再提供个 hook 让函数式组件也能拥有自己的生命周期，这不算过分吧。这就是 <code>useEffect</code> 的作用就是，但是实际上官方文档中对它的描述却让人有些模糊: <code>Effect Hook 可以让你在函数组件中执行副作用操作</code> 。</p><p>OK, 先不着急。先看一下 <code>useEffect</code> 怎么使用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * part1</span></span><br><span class="line"><span class="comment">   * dosomething</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * part2</span></span><br><span class="line"><span class="comment">     * dosomething</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;, [ <span class="comment">/* part3 依赖的state */</span>])</span><br></pre></td></tr></table></figure><p>useEffect 的第一个参数是函数，我们可以在这个函数内发起网络请求、绑定事件、订阅消息、创建定时器、查找操作 DOM 等，这也就是所谓的副作用，对应的就是上述代码中的 <code>part1</code> 。还可以在函数内部再返回一个函数，在该函数内清除上一次副作用遗留下来的状态，比如解绑事件、取消订阅、消除定时器等等。它是可选的，你也可以不返回任何值，这取决你的业务场景，比如你只是在 <code>part1</code> 部分获取数据、记录一些日志，那就完全没必要再多一写一个 <code>return</code> 了。对应上述代码中的 <code>part2</code> 。第三个参数是一个数组，将 <code>part1</code> 和 <code>part2</code> 部分使用到的 <code>state</code> 或 <code>prop</code> 放进这个数组内，接下来我们先分析 useEffect 的执行过程，然后解释为什么需要 <code>part3</code> 。</p><!-- todo 有误 --><ol><li>组件初次 render 的时候执行 part1 </li><li>组件更新之前执行 part2</li><li>组件更新完成后 执行 part1</li></ol><p>所以我们可以把 useEffect 当做是 <code>componentDidMount</code> 、 <code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 的组合。 <code>part1</code> 对应 <code>componentDidMount</code> ， <code>part3</code> 对应 <code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 。</p><p>useEffect 和 useState 一样可以在一个组件内使用多次。这样我们就可以更好的将有关联的代码组织在一起了，但是随之而来就产生了一个问题，来看下面一段代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [width, setWidth] = <span class="title function_">useState</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onResize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setWidth</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, onResize, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, onResize, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = count;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      页面名称: &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      页面宽度: &#123;width&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; setCount(count + 1) &#125;&#125;&gt;Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，第一个 useEffect 在组件初始时监听 window 的 resize 事件，在组件更新或销毁的时候取消事件绑定；第二个 useEffect 在组件初始和更新的时候修改页面的 title 。</p><p>每当 state 或 prop 都会触发函数式组件的更新，所以只要触发了 resize 事件，第二个 useEffect 都会再执行一遍。所以在某些情况下，每次渲染后都 effect 可能会导致性能问题。那 useEffect 的第二参数 DependencyList 便是用来控制何时执行 effect :</p><ol><li>在不传 DependencyList 的情况下，每次渲染、更新都会执行 part1 和 part2 </li><li>在传 DependencyList 的情况下，只有当 DependencyList 中的值发生变化才会执行 part1 和 part2</li><li>如果传了空数组，只有在初次渲染和卸载的时候才会执行 part1 和 part2<br>根据上面的规则，我可以对上面的代码做一些优化:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, onResize, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, onResize, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = count;</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure></li></ol><h3 id="自定义-hook"><a href="#自定义-hook" class="headerlink" title="自定义 hook"></a>自定义 hook</h3><p>仅仅让有函数式组件拥有 state 和生命周期这远远不够，我们要讨论的是逻辑复用，这时候我们就可以用到自定义 hook 。自定义 hook 就是以 use 开头的函数，我们可以在该函数能使用 <code>useState</code> 、 <code>useEffect</code> 等等这些 React 提供的 hook ，还可以在函数内部返回一些 Date 或者 Method 。</p><h2 id="Vue-Composition-API"><a href="#Vue-Composition-API" class="headerlink" title="Vue Composition API"></a>Vue Composition API</h2><p>从框架使用者角度而言， Vue3 最大的改动就是从 Options API 表更为 Composition API 。Options API 是一种非常直观的分隔代码的方法， data, computed, watch, methods, lifecycle, 一切看看起来井井有条。但是它也有致命的缺点，比如你在刚写 Vue 的时候是否经常疑惑 this 的指向;当一个组件的代码有数百行，一个简单的功能所对应的代码可能会被分割在了不同的地方，从而变得难以阅读或调试;无法更便捷的使用类型推到，所以在 Vue2 中使用 ts 相对于 ng 和 react 要更麻烦一些;而且这种配置式的 API 注定想要复用逻辑，就只能使用 mixin 的方式。</p><p>而且 Vue3 的 Composition API 将上述的问题都统统解决了。为了更直观的对比，我们就一个计数器的例子来展示说明。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>count is &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>plusOne is &#123;&#123; plusOne &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>count++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue2 Options API</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">plusOne</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> += <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">count</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`oldVal is <span class="subst">$&#123;oldVal&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Vue3 Composition API</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, computed, watch, onMounted, &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      count.<span class="property">value</span> += <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(count, <span class="function">(<span class="params">val, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`oldVal is <span class="subst">$&#123;oldVal&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onMounted&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; count, plusOne, increment &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从上面的例子中我们可以发现 Composition API 已经完全移除了 data, computed, methods, watch, 生命周期等等这些配置项(其实为了兼容 Vue2 并没有移除)，而是提供了 <code>ref/reactive</code> , <code>computed</code> , <code>watch</code> , <code>onMounted</code> 这些方法来代替。新增了 setup 方法，创建响应式数据，业务逻辑也全都移到了 setup 之中。如果需要在模板中访问数据调用方法，只需在 setup 中将相应的数据&#x2F;方法 return 出去即可。</p><p>底层主要是从 flow 切换到 typescript ，用 Proxy 取代了 Object.defineProperty ，重构了 Virtual DOM 。</p><p>Composition API 在一定程度借鉴了 react hook ，但是实现方式是完全不同的，并且确实解决了 Vue 中逻辑复用和代码组织的问题，同时提供了更好的类型推导。而且 Composition API 相较于 React Hook 使用起来心智负担要很多，所以没必要对 Composition API 有过多的质疑甚至是否定，没人能逃得出真香定论。</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>setup 是新增的一个组件选项，也是使用 Composition API 的入口点。创建组件实例，然后初始化 props ，紧接着就调用setup 函数。从生命周期钩子的角度来看，它会在 beforeCreate之前被调用。setup 中返回的对象会被合并到模板的渲染上下文中。也可以在 setup 返回一个渲染函数。</p><p>它和一些响应式 API ，生命周期钩子组合，代替了之前的 data , computed , methods , watch , 生命周期等。<strong>在 setup 中将无法在使用 this</strong> 。那当我们需要在 setup 使用到 props 或者一些组件内置的方法(比如 this.$emit )时该怎么办呢？ setup 提供了两个参数，分别是 props 和 context 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props, ctx</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>props 就是由父组件传递给子组件的 props 。它和 react 中函数式组件的 props 类似，但是不要解构 props 因为那样是让 props 失去响应式特性。</p><p>context 则代替了之前的 this 。比如 ctx.attrs , ctx.emit 等等。</p><p>Q: 为什么将 props 设计为第一个参数，而不是 context 呢？为什么不将 props 和 context 合并呢？</p><h3 id="响应式-API"><a href="#响应式-API" class="headerlink" title="响应式 API"></a>响应式 API</h3><ul><li>reactive<br>以一个普通对象为参数，传入的对象会经过 Proxy 包装，返回该对象的响应式代理。它与 Vue2 的 Vue.observable() 用法完和作用完全相同。为了避免和 RXJS 的 observable 混淆，改名为 reactive 。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;qq&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br></pre></td></tr></table></figure></li><li>ref<br><code>reactive</code> 可以代理对象，但是如果我们只需要用到一个简单的值类型时，比如上面例子的中 count ，该怎么办呢？一种办法是将 count 包装一次层，用 reactive 创建创建响应式数据 :<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br></pre></td></tr></table></figure>另一种方法就是用 <code>ref</code> :<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countRef = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(countRef.<span class="property">value</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>ref 返回的也是一个响应式对象，拥有一个指向内部值的单一属性 <code>.value</code> 。为了让我们能方便一些，在模板中使用 ref 的值时是不需要通过有 .value 来获取的。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;countRef&#125;&#125;<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>Q: 那什么时候使用 reactive 什么时候使用 ref 呢？</li><li>computed<br>computed 函数代替了之前的 computed 选项:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;qq&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(&#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> count.<span class="property">value</span> + <span class="number">1</span>,</span><br><span class="line">  <span class="attr">set</span>: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    count.<span class="property">value</span> = val - <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfo = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="string">`我是<span class="subst">$&#123;user.name&#125;</span>，今年<span class="subst">$&#123;user.age&#125;</span>岁`</span>);</span><br></pre></td></tr></table></figure>不过和 Vue2 不同的是， computed 返回的值与 ref 一样是一个 ref 对象。原因是一样的，属性计算就可能会返回一个值类型 <code>plusOne</code> , 也可能会返回一个引用类型 <code>userInfo</code> ，为了保证值类型不丢失内部逻辑关系，那就要像 ref 一样包装一层，为了统一起来， computed 一律返回一个 ref 对象。</li><li>watch<br>watch 与之前的 watch 选项完全相同，当需要监听指定值变化并执行一些逻辑的时候可以使用 watch 。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">ref</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;qq&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> user,</span><br><span class="line">  <span class="function">(<span class="params">val, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;user&#x27;</span>, val, oldVal);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">immediate</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(count, <span class="function">(<span class="params">val, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count&#x27;</span>, val, oldVal);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>([count, bar], <span class="function">(<span class="params">[currentCount, currentBar], [oldCount, oldBar]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count &amp; bar current: &#x27;</span>, currentCount, currentBar);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count &amp; bar old: &#x27;</span>, oldCount, oldBar);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    user.<span class="property">name</span> = <span class="string">&#x27;pp&#x27;</span>;</span><br><span class="line">    count.<span class="property">value</span> += <span class="number">1</span>;</span><br><span class="line">    bar.<span class="property">value</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>与之前不能的是， watch 现在可以监听多个值了， watch 会返回一个用于停止监听的函数，显式的调用该函数，就可以停止监听: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = <span class="title function_">watch</span>(count, <span class="function">(<span class="params">val, oldVal</span>) =&gt;</span> &#123; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止监听</span></span><br><span class="line"><span class="title function_">stop</span>();</span><br></pre></td></tr></table></figure>Q: 在 Vue2 中如何同时监听多个值呢？</li><li>watchEffect<br>watchEffect 与 wacth 的功能类似，不过它不需要像 watch 那样指明被依赖的数据。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`count is <span class="subst">$&#123;count.value&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    count.<span class="property">value</span> += <span class="number">1</span>;</span><br><span class="line">  &#125;, <span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>看着是不是和 React.useEffect 很像。那可不可以和 React.useEffect 一样清除副作用呢？当然可以: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onResize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  count.<span class="property">value</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">(<span class="params">onInvalidate</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, onResize, <span class="literal">false</span>);</span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, onResize, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>那清除副作用的函数 清除副作用会在何时调用呢？<!-- todo --></li><li>readonly<br>用于创建一个只读的代理对象，参数可以是普通对象、代理对象、或者 ref<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> readonlyCount = <span class="title function_">readonly</span>(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="title function_">readonly</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">15</span> * <span class="number">1000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;qq&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> readonlyUser = <span class="title function_">readonly</span>(user);</span><br><span class="line"></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.<span class="property">value</span>++;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count.value:&#x27;</span>, count.<span class="property">value</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;readonlyCount.value:&#x27;</span>, readonlyUser.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">  readonlyUser.<span class="property">name</span> = <span class="string">&#x27;pp&#x27;</span>; <span class="comment">// 无法修改并且发出警告</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Lifecycle-Hooks"><a href="#Lifecycle-Hooks" class="headerlink" title="Lifecycle Hooks"></a>Lifecycle Hooks</h3><p>Vue3 中新增了一些周期钩子，这钩子只能在 setup 期间同步使用(或者在自定义 hook 中使用，但是自定义 hook 最中还是要在 setup 中使用)。为它们依赖于内部的全局状态来定位当前组件实例（正在调用 setup() 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。</p><ul><li><del>beforeCreate</del> -&gt; 使用 setup()</li><li><del>created</del>  -&gt; 使用 setup()</li><li>beforeMount -&gt; onBeforeMount</li><li>mounted -&gt; onMounted</li><li>beforeUpdate -&gt; onBeforeUpdate</li><li>updated -&gt; onUpdated</li><li>beforeDestroy -&gt; onBeforeUnmount</li><li>destroyed -&gt; onUnmounted</li><li>errorCaptured -&gt; onErrorCaptured</li></ul><p>新增</p><ul><li>onRenderTracked</li><li>onRenderTriggered</li></ul><p>可以用这个钩子进行调试优化。</p><h3 id="响应式系统工具集"><a href="#响应式系统工具集" class="headerlink" title="响应式系统工具集"></a>响应式系统工具集</h3><ul><li>isRef()<br>检查一个值是否为一个 ref 对象，其实是通过 <code>__v_isRef</code> 来判断的</li><li>toRef()<br>为一个 reactive 对象的属性创建一个 ref 。 <code>toRef()</code> 则可以解决这个问题<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;qq&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> userNameRef = <span class="title function_">toRef</span>(user, <span class="string">&#x27;name&#x27;</span>); <span class="comment">// userNameRef.value qq</span></span><br></pre></td></tr></table></figure></li><li>toRefs()<br>把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;qq&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> userRef = <span class="title function_">toRefs</span>(user);</span><br><span class="line"></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    user.<span class="property">name</span> = <span class="string">&#x27;pp&#x27;</span>;</span><br><span class="line">    userRef.<span class="property">age</span>.<span class="property">value</span> = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(userRef.<span class="property">name</span>.<span class="property">value</span>); <span class="comment">// pp</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">age</span>); <span class="comment">//16</span></span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>unref()<br>如果参数是一个 ref 则返回它的 value，否则返回参数本身。它是 <code>val = isRef(val) ? val.value : val</code> 的语法糖。</li><li>isProxy<br>检查一个对象是否是由 reactive 或者 readonly 方法创建的代理。</li><li>isReactive<br>检查一个对象是否是由 reactive 创建的响应式代理。如果这个代理是由 readonly 创建的，但是又被 reactive 创建的另一个代理包裹了一层，那么同样也会返回 true。</li><li>isReadonly<br>检查一个对象是否是由 readonly 创建的只读代理。</li></ul><h1 id="体验-Composition-API"><a href="#体验-Composition-API" class="headerlink" title="体验 Composition API"></a>体验 Composition API</h1><ul><li>npm init vite-app vue-vite</li><li>vue add vue-next</li><li>npm i @vue&#x2F;composition-api</li></ul><p>Vue3的其它改动 : </p><p>react :</p><ul><li>useRef</li><li>useCallback</li><li>useMemo</li></ul><p>自定义hook :</p><ul><li>useRequest</li><li>useStorage</li><li>useDebounce</li><li>useList</li><li>useForm</li><li>useModal</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;逻辑复用&quot;&gt;&lt;a href=&quot;#逻辑复用&quot; class=&quot;headerlink&quot; title=&quot;逻辑复用&quot;&gt;&lt;/a&gt;逻辑复用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在做了一个又一个的xx管理系统后，好像生活变得更枯燥乏味了，逐渐的在一次又一次的复制粘贴中迷失自我</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue3介绍-参考</title>
    <link href="http://onlymisaky.github.io/2020/06/30/"/>
    <id>http://onlymisaky.github.io/2020/06/30/</id>
    <published>2020-06-30T06:53:25.000Z</published>
    <updated>2024-09-11T03:04:29.038Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>minixs hoc<br><a href="http://www.ayqy.net/blog/react%e7%bb%84%e4%bb%b6%e9%97%b4%e9%80%bb%e8%be%91%e5%a4%8d%e7%94%a8/">React组件间逻辑复用</a></p><p><a href="https://juejin.im/post/5ec28e1c5188256d571ef2dc">React组件逻辑复用的那些事儿（Mixins -&gt; HOC+render props -&gt; Hooks）</a></p><p><a href="https://zhuanlan.zhihu.com/p/20361937">React Mixin 的前世今生</a></p><p><a href="https://www.jianshu.com/p/fbe57702c1b9">react 放弃mixins设计模式</a></p><p><a href="https://blog.csdn.net/qq_38045106/article/details/84198171">react为何移除mixins</a></p><p><a href="https://www.zhihu.com/question/67588479">为何在React中推荐使用HOC，而不是mixins来实现组件复用。但在Vue中，很少有HOC的尝试？</a></p><p><a href="https://blog.csdn.net/Dong8508/article/details/103728302">vue中使用 minix 混入</a></p><p><a href="https://juejin.im/post/5e8b5fa6f265da47ff7cc139">Vue 进阶必学之高阶组件 HOC</a></p><p><a href="https://zhuanlan.zhihu.com/p/63161576">探索Vue高阶组件</a></p><p><a href="https://zhuanlan.zhihu.com/p/29250138">React高阶组件实践</a></p><p><a href="https://zhuanlan.zhihu.com/p/61711492">React 中的高阶组件及其应用场景</a></p><p><a href="https://zhuanlan.zhihu.com/p/28138664">深入浅出React高阶组件</a></p><p><a href="https://zhuanlan.zhihu.com/p/34648434">如何理解 React 高阶组件(HOC)?</a></p></li><li><p>react hook<br><a href="https://zhuanlan.zhihu.com/p/67087685">精读《Function Component 入门》</a></p><p><a href="https://zhuanlan.zhihu.com/p/59558396">精读《Function VS Class 组件》</a></p><p><a href="https://zhuanlan.zhihu.com/p/49408348">精读《React Hooks》</a></p><p><a href="http://www.ayqy.net/blog/react-hooks-introduction/">React Hooks简介</a></p><p><a href="http://www.ayqy.net/blog/the-rise-of-function-component/">函数式组件的崛起</a></p><p><a href="https://zhuanlan.zhihu.com/p/50597236">一篇看懂 React Hooks</a></p><p><a href="https://zhuanlan.zhihu.com/p/85382425">呕心沥血，一文看懂 react hooks</a></p><p><a href="https://zhuanlan.zhihu.com/p/92211533">React Hooks完全上手指南</a> </p><p><a href="https://juejin.im/post/5e53d9116fb9a07c9070da44">终于搞懂 React Hooks了！！！！！</a></p><p><a href="https://zhuanlan.zhihu.com/fefame">专栏，介绍react hook 玩法</a></p><p><a href="https://zhuanlan.zhihu.com/p/85969406">React Hooks 你真的用对了吗？</a></p><p><a href="https://mp.weixin.qq.com/s/vCXnTXDOTflxooPudnM6Hw">一起围观由React Hooks防抖引发的面试翻车现场</a></p><p><a href="https://juejin.im/post/5be3ea136fb9a049f9121014">30分钟精通React Hooks</a></p><p><a href="https://juejin.im/post/5ec7372cf265da76de5cd0c9">React Hooks 最佳实践</a></p><p><a href="https://juejin.im/post/5ec00abb6fb9a0438222986a">React系列-轻松学会Hooks(中)</a></p><p><a href="https://juejin.im/post/5ee4c33ae51d4578762017c7">15 个很有用的自定义 React Hooks</a></p><p><a href="https://juejin.im/post/5e57d0dfe51d4526ce6147f2">10分钟教你手写8个常用的自定义hooks</a></p><p><a href="https://github.com/nanxiaobei/flooks/issues/14">请教：是否更推荐model数据细粒度化？</a></p><p><a href="https://zhuanlan.zhihu.com/p/84697185">React useEffect的陷阱</a></p><p><a href="https://github.com/dance2die/react-use-localstorage/blob/master/src/index.ts">react-use-localstorage</a></p><p><a href="https://zhuanlan.zhihu.com/p/98554943">React Hooks(二): useCallback 之痛</a></p></li><li><p>Vue Composition API<br><a href="https://zhuanlan.zhihu.com/p/71667382">精读《Vue3.0 Function API》</a></p><p><a href="https://composition-api.vuejs.org/zh/">Vue Composition API</a></p><p><a href="https://zhuanlan.zhihu.com/p/146097763">深入理解 Vue3 Reactivity API</a></p><p><a href="https://juejin.im/post/5e9ce011f265da47b8450c11">Vue3 究竟好在哪里？（和 React Hook 的详细对比）</a></p><p><a href="https://segmentfault.com/a/1190000022451034">一份vue3-beta相关文集前来报告，请您收下</a></p><p><a href="https://juejin.im/post/5e70970af265da576429aada">40行代码把Vue3的响应式集成进React做状态管理</a></p><p><a href="https://juejin.im/post/5ec537486fb9a047bb6a4204">vue 3.x 如何有惊无险地快速入门</a></p><p><a href="https://juejin.im/post/5dc820a3e51d4509320d084d">[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香</a></p><p><a href="https://www.zhihu.com/question/378861485/answer/1074239845">React Hooks 是否可以改为用类似 Vue 3 Composition API 的方式实现？</a>(<a href="https://www.zhihu.com/question/378861485/answer/1125724740">https://www.zhihu.com/question/378861485/answer/1125724740</a>)</p><p><a href="https://juejin.im/post/5e99c21b6fb9a03c590dfea8">Vue 3.0 全家桶抢先体验</a></p><p><a href="https://zhuanlan.zhihu.com/p/98955770">从 0 到 1 实现 useAxios</a></p></li></ul><ol><li>逻辑复用 </li><li>Mixin </li><li>HOC </li><li>render prop </li><li>class Component 和 Fuction Component 各自缺陷 </li><li>hook 诞生 </li><li>Vue Composition API 介绍和用法 </li><li>React Hook 与 Vue Hook 对比 </li><li>用 Vue Hook 造一些轮子</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;minixs hoc&lt;br&gt;&lt;a href=&quot;http://www.ayqy.net/blog/react%e7%bb%84%e4%bb%b6%e9%97%b4%e9%80%bb%e8%be%91%e5%a4%8d%e7%94%a8/&quot;&gt;React组件间逻</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello RxJS</title>
    <link href="http://onlymisaky.github.io/2020/05/12/"/>
    <id>http://onlymisaky.github.io/2020/05/12/</id>
    <published>2020-05-12T10:47:05.000Z</published>
    <updated>2024-09-11T03:04:28.922Z</updated>
    
    <content type="html"><![CDATA[<p>这次来介绍一下 <a href="https://rxjs.dev/">RxJS</a> ，不会过于深入的讲解，因为我自己也是个半吊子，本文旨在让你对 RxJS 有个整体的认识，并能够体会到 RxJS 在部分场景下的优势。</p><p>读过我之前的文章应该能了解到，我在介绍一些此类内容的时候，喜欢用 <strong>Why</strong> 、 <strong>What</strong> 、 <strong>How</strong> 这样的方式。不过这次可能要换一种方式了，因为在我看来 RxJS 更多的是一种思维方式的转变，就像在前端没有出现 MV* 框架之前，我们的思维还是<strong>拿着数据去更新DOM</strong>，而有了这些框架，操作 DOM 的思维方式已经逐渐被替代掉了。</p><p>首先我们来看一个例子，给定一个数组 <code>[1, &#39;qq&#39;, 3, &#39;奇奇&#39;, 17, &#39;77&#39;]</code> 将数组中的数字乘以2然后再相加求和，你可能会很快想到下面的解法：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="string">&#x27;qq&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;奇奇&#x27;</span>, <span class="number">17</span>, <span class="string">&#x27;77&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="built_in">parseInt</span>(item <span class="keyword">as</span> <span class="built_in">string</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(n)) &#123;</span><br><span class="line">    sum += n * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，但是可读性就差了很多，我们再用函数式编程的方式改造一下：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = arr</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">parseInt</span>(n <span class="keyword">as</span> <span class="built_in">string</span>, <span class="number">10</span>))</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">n</span> =&gt;</span> !<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(n))</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">reduce</span>(<span class="function">(<span class="params">prve, current</span>) =&gt;</span> prve + current)</span><br></pre></td></tr></table></figure><p>第一种方式叫<strong>命令式</strong>，而第二种则叫<strong>声明式</strong>。从命令式到声明式，便是一种思维模式的转换。同样的例子还有 <code>SQL</code> 和 <code>ORM</code>。我们通过仔细观察可以发现，在命令式编程中，我们是<strong>迫不及待</strong>，<strong>想尽一切办法</strong>的想要得到最终的结果。而在声明式中，我们则是通过<strong>一系列的转化</strong>，<strong>有条不紊</strong>的得到最终结果。那这个例子和我们要介绍的 <code>RxJS</code> 又有什么关系呢？请再次阅读我对声明式的评价并理解它，那在接下来的内容中，你就能很好的理解 RxJS 了。</p><p>首先简单介绍 RxJS 的由来。2012年微软提出并开源了 <a href="http://reactivex.io/">ReactiveX(Reactive Extensions)</a> 编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。目前已有 c#、c++、java、JavaScript等多个版本实现。而 RxJS 则是 ReactiveX 的 JavaScript 版本。ReactiveX 有三个非常重要的特点: <code>观察者模式</code>、<code>Iterator</code>、<code>函数式编程</code>。</p><p><a href="https://www.zhihu.com/topic/20036245/top-answers">https://www.zhihu.com/topic/20036245/top-answers</a><br><a href="https://blog.techbridge.cc/2017/12/08/rxjs/">https://blog.techbridge.cc/2017/12/08/rxjs/</a><br><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Intro.html">https://mcxiaoke.gitbooks.io/rxdocs/content/Intro.html</a><br><a href="https://rxjs-cn.github.io/learn-rxjs-operators/">https://rxjs-cn.github.io/learn-rxjs-operators/</a><br><a href="https://zhuanlan.zhihu.com/p/23331432">https://zhuanlan.zhihu.com/p/23331432</a><br><a href="https://www.jianshu.com/p/5d01341599e9">https://www.jianshu.com/p/5d01341599e9</a><br><a href="https://segmentfault.com/a/1190000012252368">https://segmentfault.com/a/1190000012252368</a><br><a href="https://zhuanlan.zhihu.com/p/23331432">https://zhuanlan.zhihu.com/p/23331432</a><br><a href="https://www.jianshu.com/p/16be96d69143">https://www.jianshu.com/p/16be96d69143</a></p><p>Observable<br>Observer</p><p>操作符分类</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次来介绍一下 &lt;a href=&quot;https://rxjs.dev/&quot;&gt;RxJS&lt;/a&gt; ，不会过于深入的讲解，因为我自己也是个半吊子，本文旨在让你对 RxJS 有个整体的认识，并能够体会到 RxJS 在部分场景下的优势。&lt;/p&gt;
&lt;p&gt;读过我之前的文章应该能了解到，我在介</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>最近零减一</title>
    <link href="http://onlymisaky.github.io/2020/04/30/"/>
    <id>http://onlymisaky.github.io/2020/04/30/</id>
    <published>2020-04-30T12:44:53.000Z</published>
    <updated>2024-09-11T03:04:29.058Z</updated>
    
    <content type="html"><![CDATA[<p>刚过去的一个季度，不是很顺畅。生病了一段时间，加上对疫情的恐惧，很长一段时间里身心都处于一种不正常状态，感情生活也是很糟糕。种种叠加在一起，所以经常陷入人生哲学问题的思考之中，虽然曾经也会这样，不过那时毕竟有“年轻”二字在撑腰。</p><p>我觉得我们义务教育中应该加入情绪管理这样一门课程，旨在引导人们如何合适释放自己的情绪，不至于像我这样在此刻用文字胡乱呻吟~~~~</p><p>下一篇见，下一篇会是rxjs吧，对吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;刚过去的一个季度，不是很顺畅。生病了一段时间，加上对疫情的恐惧，很长一段时间里身心都处于一种不正常状态，感情生活也是很糟糕。种种叠加在一起，所以经常陷入人生哲学问题的思考之中，虽然曾经也会这样，不过那时毕竟有“年轻”二字在撑腰。&lt;/p&gt;
&lt;p&gt;我觉得我们义务教育中应该加入情</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我在锤桌子</title>
    <link href="http://onlymisaky.github.io/2020/01/02/"/>
    <id>http://onlymisaky.github.io/2020/01/02/</id>
    <published>2020-01-02T12:15:52.000Z</published>
    <updated>2024-09-11T03:04:29.058Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>css3中的<code>transform</code>是讲究顺序的<code>transform: translate(50%, -50%) rotate(45deg);</code>与<code>transform: rotate(45deg) translate(50%, -50%);</code>效果是不一样的。</p></li><li><p>nth-last-of-type nth-last-child</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;css3中的&lt;code&gt;transform&lt;/code&gt;是讲究顺序的&lt;code&gt;transform: translate(50%, -50%) rotate(45deg);&lt;/code&gt;与&lt;code&gt;transform: rotate(45deg) tra</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>让vue老项目支持js与ts混用</title>
    <link href="http://onlymisaky.github.io/2019/12/27/"/>
    <id>http://onlymisaky.github.io/2019/12/27/</id>
    <published>2019-12-27T12:28:45.000Z</published>
    <updated>2024-09-11T03:04:29.078Z</updated>
    
    <content type="html"><![CDATA[<p>今年国庆前(2019)，终于把我司的一个老项目重构完成(<a href="/2019/09/20/" title="his前端重构经验">his前端重构经验</a>)，开发体验和效率上都有了质的飞越。不过由于一些不可抗原因(可用于重构时间不够充裕、历史代码量较大)，还是没能将项目由 JavaScript 迁移到 TypeScript。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>对于喜欢ts好久好久的我来说（没错，我就是馋ts的类型系统，我下贱😝），不用ts我浑身难受。这周也是抽了些时间，让该系统支持ts与js混用了。当然并不是出于个人偏爱ts才做这样的改动，主要的动机有如下几点：</p><ul><li>该项目属于中大型的后台项目，确实需要类型系统来提升代码的可维护性和可读性</li><li>在多人协作开发中，有类型提示可以减去很多不必要的沟通成本</li><li>我司的小程序已经采用ts，未来ts也是我们团队的主要方向之一</li></ul><p>如果读者也想对项目进行升级，一定要先确定是否真的有必要，<strong>切莫为了满足个人爱好，从而给整个团队带来额外的成本。</strong></p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>需要改造的项目是通过 vue-cli3 生成的模板项目，开启了eslint。</p><h2 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h2><h3 id="安装-typescript-ts-loader"><a href="#安装-typescript-ts-loader" class="headerlink" title="安装 typescript , ts-loader"></a>安装 typescript , ts-loader</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i typescript ts-loader -D</span><br></pre></td></tr></table></figure><h3 id="修改-webpack-配置"><a href="#修改-webpack-配置" class="headerlink" title="修改 webpack 配置"></a>修改 webpack 配置</h3><p>由于 vue-cli3 将 webpack 的配置全部隐藏起来了，只能通过在项目根目录下建立 <code>vue.config.js</code> 来修改配置，这里有两种方式来编写配置</p><ol><li>通过直接修改<code>configureWebpack</code>选项，该方式和写webpack配置一样，在编译的时候，这份配置会通过  webpack-merge 合并到最终的配置中</li><li>通过  webpack-chain 链式修改配置，vue-cli3 内部也是通过这样的方式来维护</li></ol><p>我选择的是第二种方式，因为它有友好的类型提示，不用边写边翻文档，关键的配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">/** 其他与本次改动无关的配置 */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">import(&#x27;webpack-chain&#x27;)</span>&#125; <span class="variable">config</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config</span><br><span class="line">      .<span class="property">resolve</span>.<span class="property">extensions</span>.<span class="title function_">add</span>(<span class="string">&#x27;.ts&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;.tsx&#x27;</span>)</span><br><span class="line">      .<span class="title function_">end</span>().<span class="title function_">end</span>()</span><br><span class="line">      .<span class="property">module</span></span><br><span class="line">      .<span class="title function_">rule</span>(<span class="string">&#x27;typescript&#x27;</span>)</span><br><span class="line">      .<span class="title function_">test</span>(<span class="regexp">/\.tsx?$/</span>)</span><br><span class="line">      .<span class="title function_">use</span>(<span class="string">&#x27;babel-loader&#x27;</span>)</span><br><span class="line">      .<span class="title function_">loader</span>(<span class="string">&#x27;babel-loader&#x27;</span>)</span><br><span class="line">      .<span class="title function_">end</span>()</span><br><span class="line">      .<span class="title function_">use</span>(<span class="string">&#x27;ts-loader&#x27;</span>)</span><br><span class="line">      .<span class="title function_">loader</span>(<span class="string">&#x27;ts-loader&#x27;</span>)</span><br><span class="line">      .<span class="title function_">options</span>(&#123;</span><br><span class="line">        <span class="attr">transpileOnly</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">appendTsSuffixTo</span>: [</span><br><span class="line">          <span class="string">&#x27;\\.vue$&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">happyPackMode</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的配置就是对于 <code>.ts</code>、<code>.tsx</code>文件先通过 ts-loader 解析，然后再交由babel处理。</p><p>如果你的项目是 vue-cli2 生成的话，直接在 <code>build/webpack.base.conf.js</code> 中做相关的修改即可，关键代码如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build/webpack.base.conf.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">/** 其他与本次改动无关的配置 */</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="comment">/** other code */</span></span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>], <span class="comment">// 添加 .ts 扩展名</span></span><br><span class="line">  &#125;,</span><br><span class="line">   <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">/** other code */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span> &#125;,</span><br><span class="line">          &#123; </span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;ts-loader&#x27;</span>, </span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, </span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">transpileOnly</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">appendTsSuffixTo</span>: [</span><br><span class="line">                <span class="string">&#x27;\\.vue$&#x27;</span></span><br><span class="line">              ],</span><br><span class="line">              <span class="attr">happyPackMode</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-tsconfig-json"><a href="#配置-tsconfig-json" class="headerlink" title="配置 tsconfig.json"></a>配置 tsconfig.json</h3><p>ts的编译需要读取 <a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html">tsconfig.json</a> 文件，在根目录下创建 tsconfig.json 文件</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esnext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esnext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;preserve&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;importHelpers&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;webpack-env&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;src/*&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;esnext&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;dom&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;dom.iterable&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;scripthost&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;src/**/*.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;src/**/*.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;src/**/*.tsx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;src/**/*.vue&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;tests/**/*.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;tests/**/*.tsx&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>进行到这一步，如果你只是想简单的在项目中混用ts的话(比如在.js、.vue中引入.ts)，配置就算是全部完成了，你可以新建一个 <code>.ts</code> 文件，然后再入口文件中导入开发测试了；如果你还需要eslint进行代码规范、编写类组件等需求的，则需要继续进行下面的步骤</p><h3 id="配置eslint"><a href="#配置eslint" class="headerlink" title="配置eslint"></a>配置eslint</h3><p>因为eslint的生态圈比较繁荣，typescript团队已经放弃了tslint从而转向eslint，所以这里我们也是用eslint作为代码规范校验的工具。需要安装以下工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @typescript-eslint/eslint-plugin @typescript-eslint/parser @vue/eslint-config-typescript -D</span><br></pre></td></tr></table></figure><p>然后修改eslint配置文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 关键配置</span></span><br><span class="line">   <span class="attr">plugins</span>: [<span class="string">&#x27;@typescript-eslint&#x27;</span>],</span><br><span class="line">   <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;plugin:vue/essential&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@vue/airbnb&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@vue/typescript&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">parser</span>: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支持在ts文件中导入-vue文件"><a href="#支持在ts文件中导入-vue文件" class="headerlink" title="支持在ts文件中导入.vue文件"></a>支持在ts文件中导入.vue文件</h3><p>默认情况下，typescript是无法识别 .vue 文件，当你需要在ts导入vue的单文件组件时(比如路由配置)，编辑器会报错：<code>找不到模块</code>。为了让ts能将 .vue 当成模块识别，需要在项目中创建<code>shims-vue.d.ts</code>文件，这样ts就会把 .vue 文件当成模块来解析了。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/shims-vue.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.vue&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用装饰器注册组件-不推荐再使用"><a href="#用装饰器注册组件-不推荐再使用" class="headerlink" title="用装饰器注册组件(不推荐再使用)"></a>用装饰器注册组件(不推荐再使用)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i vue-property-decorator -S</span><br></pre></td></tr></table></figure><p>由于vue的api设计原因，导致其很难使用ts来编写vue组件(无法正确的推导出this)，所以还需要安装<code>vue-property-decorator</code>，通过它提供的一列装饰器，来编写类组件，用起来大有一种angular的感觉，具体可以移步到这里👉 <a href="https://github.com/kaorun343/vue-property-decorator">https://github.com/kaorun343/vue-property-decorator</a>，详细的参考demo👉<a href="https://github.com/onlymisaky/TodoMvc-vue">TodoMvc-vue</a></p><p>不过vue官方已经决定放弃这种写法，学习react的hook并推出了composition-api，虽然社区对此颇有不满。所现阶段不推荐装饰器写法，等vue3正式发布后再逐步迁移vue组件吧。</p><h3 id="在ts中导入js"><a href="#在ts中导入js" class="headerlink" title="在ts中导入js"></a>在ts中导入js</h3><p>既然是ts和js混用，那就会存在js中导入ts，或ts中导入js的情况。前者一般情况经过上面的配置，是不会有太多问题出现的。而后者(ts中导入js)可能在编写代码的时候，编辑器可能会提示一些小错误。这时候就需要你为相关的js文件编写类型提示文件了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了在ts中导入a.js不报错，我们要在相同的目录下创建<code>a.d.ts</code>类型提示文件</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> sum = <span class="function">(<span class="params"><span class="attr">m</span>: <span class="built_in">number</span>, <span class="attr">n</span>:<span class="built_in">number</span></span>) =&gt;</span> numer;</span><br></pre></td></tr></table></figure><p>如果导入的js文件代码量不是很多，建议直接修改源文件。</p><h3 id="删除jsconfig-json"><a href="#删除jsconfig-json" class="headerlink" title="删除jsconfig.json"></a>删除jsconfig.json</h3><p>如果你使用了vscode作为开发工具，并且也配置了<code>jsconfig.json</code>文件。那么在引入ts之后，你完全可以删除这个文件，然后将<code>tsconfig.json</code>中的<code>compilerOptions.allowJs</code>设置为<code>true</code>即可。<a href="https://code.visualstudio.com/docs/languages/jsconfig">https://code.visualstudio.com/docs/languages/jsconfig</a></p><h2 id="下一步计划"><a href="#下一步计划" class="headerlink" title="下一步计划"></a>下一步计划</h2><p>接下来会逐步将所有的 .js 文件加上类型系统，转成 .ts 文件。对于 .vue 单文件组件，继续保持原有写法，等到vue3发布后再做迁移的打算。当然也有可能会迁移到其他的框架，在这期间只要不断弱化 vue 的比重，让它之负责 ui 部分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>安装 <code>typescript</code>、<code>ts-laoder</code>，修改webpack配置，支持对<code>.ts</code>文件的解析</li><li>配置 <code>tsconfig.json</code></li><li>配置 <code>eslint</code></li><li>添加 <code>shims-vue.d.ts</code> 支持对 .vue 文件的识别</li><li>如果需要编写类组件，安装 <code>vue-property-decorato</code></li><li>为需要导入到ts文件中的js文件编写类型文件，或者直接修改该文件为 .ts 文件</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今年国庆前(2019)，终于把我司的一个老项目重构完成(&lt;a href=&quot;/2019/09/20/&quot; title=&quot;his前端重构经验&quot;&gt;his前端重构经验&lt;/a&gt;)，开发体验和效率上都有了质的飞越。不过由于一些不可抗原因(可用于重构时间不够充裕、历史代码量较大)，还是没能</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://onlymisaky.github.io/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="http://onlymisaky.github.io/tags/TypeScript/"/>
    
    <category term="vue" scheme="http://onlymisaky.github.io/tags/vue/"/>
    
    <category term="webpack" scheme="http://onlymisaky.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>his前端重构经验</title>
    <link href="http://onlymisaky.github.io/2019/09/20/"/>
    <id>http://onlymisaky.github.io/2019/09/20/</id>
    <published>2019-09-20T10:30:21.000Z</published>
    <updated>2024-09-11T03:04:28.942Z</updated>
    
    <content type="html"><![CDATA[<p>自入职以来，85% 的工作都是在做 HIS:Hospital Information System (医院信息系统)的需求。从前端的角度来看，这是一个很典型的后台管理系统，而且有趣的是，你可以从项目的 git 记录中窥探到近年前端技术的变迁。</p><p>在我接手到这项目的时候，它已经稳定运行了有三年多的时间了，而且每月都有至少两个以上新需求需要去完成。这是一个非常好的事情，说明我们一直是稳步前进的，不过对于开发者来说，未必是那么的美好。因为出于项目的稳定性考虑，正在使用的技术可能是很久以前的技术，我并不是狂热新技术推崇者，有经验的人都明白，万金油般的解决方案是不存在的，最优的技术选型还是要由场景来决定。所以这次重构并不是为了重构而重构，而是为了<strong>提高项目的可维护性</strong>和<strong>提升开发效率</strong>而做出的决定，因此专门抽出一段时间来做重构，收益是远远大于付出的。</p><h2 id="重构前的痛点"><a href="#重构前的痛点" class="headerlink" title="重构前的痛点"></a>重构前的痛点</h2><p>首先介绍一下重构前的技术方案，当时项目还没有采用目前主流的前后端分离的方式，后端使用的是：Spring Boot + thymeleaf(Java 模板引擎)，前端采用的技术就比较多了：</p><ul><li>jQuery (操作 Dom，发起 ajax 请求)</li><li>基于 jQuery 封装的常用插件(日期选择、表格、select 等等)</li><li>Handlebars(老牌的前端模板引擎)</li><li>sass</li><li>gulp (编译 sass，压缩 js，移动编译后的文件，启动 webpack )</li><li>vue1.x</li><li>webpack1.x (编译 .vue 文件)</li><li>lodash (仅仅是为了使用 lodash 的 template，所以项目中一共有四套模板语法 thymeleaf、Handlebars、template、vue)</li></ul><p>除了以上列举出的这些，还有其它使用频次不太高的js库没有列出。</p><p>那这样一个糅合了多种前端技术方案的项目，要如何启动进行开发调试呢？前面提到项目前后端没有分离，所以要想跑起来就必须要配置java开发环境(jdk, maven, mysql, redis…)，和前端开发环境(node, npm, gulp, webpack…)。首先通过 gulp 和 webpack 编译打包前端代码，移动到后端指定的 resource 目录，然后再通过 mvn 启动后端服务(过程比较漫长)。每当前后端代码有改动的时候，则需要重新执行上线的步骤，等待时间极为漫长。讲到这里你可能已经感受了一些痛点了：</p><ol><li>上手成本高(前端同学要去了解一些后端，后端同学又要去了解一些前端)</li><li>前端部分技术方案老旧(vue1.x, gulp, webpack1.x)</li><li>调试成本极高，每当前端代码更新就需要重新打包前端，重启后端服务，无法使用热更新，耗费时间极长</li></ol><p>为了解决以上这些痛点，在我入职第二周，项目经理便和我聊了重构的问题，重构的目标就是将项目打造成前后端分离，提高以后的开发效率和代码质量。刚接到这个任务的时候还是比较兴奋的，因为一直写业务代码确实有些厌倦了，想接受新的挑战，做一些重构和架构方面的东西。但是也有几分的惆怅，因为当时整个项目组只有我一个前端，而且明确表示不会有专门的开发周期用于重构。如同项目经理多次提到的那样，我们要做的事情是“<strong>给一辆高速行驶中的汽车换轮胎</strong>”。当然在重构的最后阶段还是争取到了一周多宝贵的时间用于全身心投入重构工作。</p><h2 id="重构前的准备"><a href="#重构前的准备" class="headerlink" title="重构前的准备"></a>重构前的准备</h2><p>既然没有专门的开发周期用于重构，那只能在日常的需求迭代中一点点做重构，所以技术选型就显得尤为重要。最终在主流的 Angular、React、Vue 三者中选择了 Vue，原因如下：</p><ol><li>vue使用起来非常灵活。只要在页面中引入 vue.js 即可，然后逐步剥离 jQuery、Handlebars 这些老旧的技术，同时引入 vue 生态内的 router、vuex 等等，项目会向一个单页应用慢慢演变。虽然 Angular 和 React 也可以直接通过 script 标签的方式引入使用，但是这样做的话开发体验上比 vue 差很多。</li><li>项目有已经有一下部分页面用使用 vue1.x 编写，如果再选别的框架，在迭代过程中又会加重开发的负担。</li></ol><p>PS:如果是停掉所有的新需求专门重构的话，我可能不会选择 Vue，具体原因暂且不表，也莫问。</p><p>框架敲定之后，就该对重构过程中的方案进行思考了，这里我直接给出方案的结果，这些都是基于个人的经验总结出来的，未必是最优的仅供参考：</p><ul><li>首先就是创建一个全新的目录，用于存放新的代码，可以很好的隔离新代码和老代码。目录结构和目前主流的前端项目大同小异<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── 老代码文件夹</span><br><span class="line">├── v2(新代码文件夹)</span><br><span class="line">│   ├── api</span><br><span class="line">│   ├── components</span><br><span class="line">│   ├── constants</span><br><span class="line">│   ├── plugins</span><br><span class="line">│   ├── styles</span><br><span class="line">│   ├── util</span><br><span class="line">├── └── views</span><br><span class="line">└── pages(webpack 入口文件)</span><br></pre></td></tr></table></figure></li><li>修改打包脚本。<br>在上面的的目录结构中有一个 pages 文件夹，它是用来存放 webpack 入口文件用的。因为没有前后端分离，所以除了公共的静态资源外，不同的页面也会加载各自的 js&#x2F;css 文件，pages 文件夹下存放的就是每个页面对应的 js 文件，v2&#x2F;views 下面的文件则是每个页面对应的 vue 组件，最后借用 webpack 的多入口功能来打包<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;./pages/foo.js&#x27;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;./pages/bar.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但是这样做有一个缺点，每当添加新的入口文件时，就需要修改一下入口配置。这里可以采用读取 pages 文件，动态创建 entry 对象的方式来解决这个问题：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">fs.<span class="title function_">readdirSync</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;pages/&#x27;</span>))</span><br><span class="line">  .<span class="title function_">forEach</span>(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fileName.<span class="title function_">endsWith</span>(<span class="string">&#x27;.js&#x27;</span>)) &#123;</span><br><span class="line">      entry[fileName.<span class="title function_">replace</span>(<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;&#x27;</span>)] = <span class="string">`v2/pages/<span class="subst">$&#123;fileName&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>不过最终并没有这样做，因为已经用到了 gulp，所以使用了 <code>webpack-stream</code> 这个插件，他的原理是通过 gulp 把文件转成 stream 传给 webpack-stream 打包编译，这样做也不用再单独启动 webpack 了。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack-stream&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> named = <span class="built_in">require</span>(<span class="string">&#x27;vinyl-named&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;webpack&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>([<span class="string">&#x27;js/pages/*.js&#x27;</span>])</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">named</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">webpack</span>(webpackConfig))</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">uglify</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/js/&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>对于全新的需求，一律使用vue开发。<br>首先由后端同学定义好后端路由(页面 url )，并且提供对应的空模板页面。对于前端而言，这个空面便是一个单页应用了，你可以在这里任意发挥，所以在替换为前端路由之前，每一个 url 对应的就是一个 spa，最后只要把后端路由替换成前端路由，就成为一个完整的单页应用了。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hello-world.html  --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:layout</span>=<span class="string">&quot;http://www.ultraq.net.nz/web/thymeleaf/layout&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span> <span class="attr">layout:decorator</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/hello-world.css&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/hello-world.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>然后在 pages 下面创建对应的js文件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** hello-world.js */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;./v2/views/hello-world/index.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">HelloWorld</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">hello-world</span> /&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li>对于老页面，如果改动比较小，则继续沿用之前的写法；如果改动较大则需要根据工时、风险性、后期收益来评估是用 Vue 重写还是继续沿用之前的开发方式。不过大部分情况下，两种方式是可以并存的。比如某个页面中一部分需要进行较大的改动，便可以将这一部分用 vue 重写，下次再将另一部分用 vue 重写，最终这个页面中可能会有多个 vue 实例，我们只要吧这些实例以组件的形式组织起来，这个页面就算是重构完成了。当然这还要得益于 vue 的灵活性。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:layout</span>=<span class="string">&quot;http://www.ultraq.net.nz/web/thymeleaf/layout&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span> <span class="attr">layout:decorator</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/other.css&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/hello-world.css&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 老的模板  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 本次的改动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">th:block</span> <span class="attr">layout:fragment</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/js/other.js&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/hello-world.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th:block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>每次改动只要将老的模板用 vue 的方式重写即可，在这个不断替换的过程中，要注意文件的加载顺序。可能会涉及到老的部分和 vue 部分的交互，一般使用事件订阅和 props 的方式都是可以解决的<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">Foo</span> &#125;,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">bar</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">onXxx</span>=<span class="string">&#123;($event)</span> =&gt;</span> &#123; this.$emit(&#x27;xxx&#x27;, $event); &#125;&#125; bar=&#123;bar&#125;/&gt;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">$(() =&gt; &#123;</span><br><span class="line">  vm.$on(<span class="string">&#x27;xxx&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">  vm.<span class="property">bar</span> = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="重构中遇到的问题和解决方案"><a href="#重构中遇到的问题和解决方案" class="headerlink" title="重构中遇到的问题和解决方案"></a>重构中遇到的问题和解决方案</h2><ul><li>让人头疼的版本问题。<br>前面提到部分页面使用了 vue1.x，考虑到 vue1 升级到 vue2 曲线相对平滑一下，所以前期一直想着先把这部分代码升级到 vue2，官方提供了 <code>vue-migration-helper</code> 帮助开发者识别出代码中旧有的特性，并且会告知你给出建议，同时附上关于详细信息的链接。不过当我跑完命令后，这种想法已经减少了一半了，<br><img src="/2019/09/20/01-vue-migration-helper%E6%8F%90%E7%A4%BA%E6%9C%891200%E5%A4%9A%E5%A4%84%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9.png" alt="vue-migration-helper提示有1200多处需要修改"><br>1200多处修改，几乎涉及到了所有的 vue1.x 的代码。即使通过编辑器批量修改，也不能保证修改后可以顺利运行。在我看过部分的代码后，完全取消了直接升级的想法了，原因有二：</li></ul><ol><li>大部分组件都使用事件通讯，事件满天飞，光理清里面的业务(事件流)就需要很长的时间</li><li>里面有一部分常用组件是自己开发的，重构的版本引入了 element-ui 组件库，这些老的组件都要替换</li><li>没有单元测试，升级后之后的代码无法保障正确性<br>所以最终决定这部分代码不升级，当改到具体页面的时候再进行升级重构，(不过这也引发了我的思考，框架在设计的时候一定要设计好对外暴露的 api，没要每次升级，就改一次 api，开发者很痛苦的，说的就是你，AngularJS)</li></ol><p>除了框架版本，还有打包工具的版本也困扰着我。项目一开始使用 sass 编写样式的，但是在 vue1.x 中却没有看到使用 sass，所有的样式都是写在单独的 .scss  文件中，然后通过gulp 打包，最后以 link 的方式在页面中引入。为什么不直接写在单文件组件中呢？还可以通过 Scoped CSS 防止样式污染。</p><p>于是我就添加了 sass-loader 和 node-sass，但是很遗憾，vue-loader 版本过低，当升级了 vue-loader 后，vue1.x 的代码就无法编译通过了。最后找到了一个可以同时兼容 vue1 和 vue2 的版本，但是他却不支持 webpack1，然后升级 webpack 后，有引发了另外一些问题，我发现版本依赖的问题似乎无法解决了，要么全部升级，包括用 vue1.x 写的代码，这个方案已经在前面被否定调了；要么不用 sass-loader 。最后在尝试使用 less-loader 后，发现没有什问题，最终确定使用 less-loader。</p><p>上面所描述的两个版本问题一个没有解决，一个用了替代方案，总体上来说是很失败的，不过倒是从中获取了一些经验：</p><ol><li>当升级版本的时遇到较多的改动，而时间又不充裕，且没有单测时，最好不要升级</li><li>当遇到版本依赖问题时，最好先想想为什么要升级，不升级是否有替代方案，不然会引发一系列连锁反应</li></ol><ul><li><p>记不住的命令<br>每次调试的时候都要敲好多命令，根本记不住，一开始都是把这些命令记在一个地方，用到的时候就复制粘贴一下。但是还是觉得不爽，后来想到可以用 alias 让这些命令更简洁，比如自定义一些 <code>his-build-fe</code>、<code>his-build-be</code> 这样的命令，好用也好记，同时也激发了我对linux命令的兴趣。</p></li><li><p>一些失败的尝试<br>前面提到每次代码有变动的时候，都要重新编译打包、重启服务，非常浪费时间。尤其是前端代码改动也要重新打包，作为一个前端不允许这种事情发生，所以就尝试用来 webpack 的 watch 来监听代码，但是由于是通过 webpack-stream 启动的，加了 watch 并没有用。于是就用 gulp-watch 来检测文件变更，虽然可以实现功能，但是 cpu 风扇一直嗡嗡的转，机器发热量也比较大，所以最后还是放弃了这种想法。</p></li></ul><h2 id="重构的一些经验和忠告"><a href="#重构的一些经验和忠告" class="headerlink" title="重构的一些经验和忠告"></a>重构的一些经验和忠告</h2><ul><li><p>首先就是要有平和的心态。<br>重构的过程中要不可避免的和老代码打交道，你可能会看到令你惊叹的奇巧淫技，但更多的是让你头晕眼花的业务逻辑和满口脏话的代码。当遇到这样的情况时，一定要调整好心态，用足够的耐心去梳理其中的逻辑。</p></li><li><p>尽可能的做到低耦合<br>这一点可能在初期阶段显得不重要，但是到后面做全局性的改动和替换时，你就能感受到他的好处了。举一个例子，在项目中经常有需要从地址栏获取参数做一些业务逻辑的运算，一开始我是将这些参数在组件内部获取并且保存，到后面替换前端路由的时候，很多地址都变了，参数读取的方式也发生了很大的改变，如果当初是把这些值设计成组件的 props，那后期的工作将会减轻很多；同样的还有地址跳转，全局变量等等这些场景。</p></li><li><p>要对所使用的技术非常熟悉<br>重构和新开项目、重写项目是不同的，经常会遇到需要新老兼容的场景，如果对项目所使用的技术不熟悉，会很难应付这些问题。</p></li><li><p>尽早的制定规范<br>重构初期的工作都是我一个人在做，后面随着团队的壮大新加入了一些小伙伴，在和他们介绍项目背景和如何开发之后便做各自的任务了。由于一开始没有制定规范，所以大伙的代码风格，编写方式还是比较多样的，这也为后面统一调整的阶段增加了一些额外的工作量，如果一开始就好的代码规范就不会发生这样的事情了。</p></li><li><p>不定期重构代码<br>在阅读项目中老代码的时候，会见到一些让人啼笑皆非的代码，我想写这段代码的人看到后也会怀疑自己当初是怎么写出这样的代码的，所以重构不是一次性的工作，好的代码就像粥一样，是熬出来。不定期的去重构整理自己曾经写过的代码和业务，不仅能让代码变得更健壮，每一次也是自我的升华。</p></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在写这篇文章的时候，HIS 系统已经重构完成为一个纯粹的单页应用了，并且在线上运行了有一个多月的时间，虽然没有收到用户反馈，但是重构后开发体验和效率确实有了很大的提升，切面切换速度也比以前快了很多，所以重构的结果个人还是十分满意的。</p><p>本文并没有太多代码和架构层面描述，如果你想了解这些可以留言讨论，我会尽可能的给予答复。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自入职以来，85% 的工作都是在做 HIS:Hospital Information System (医院信息系统)的需求。从前端的角度来看，这是一个很典型的后台管理系统，而且有趣的是，你可以从项目的 git 记录中窥探到近年前端技术的变迁。&lt;/p&gt;
&lt;p&gt;在我接手到这项目</summary>
      
    
    
    
    
    <category term="vue" scheme="http://onlymisaky.github.io/tags/vue/"/>
    
    <category term="重构" scheme="http://onlymisaky.github.io/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>用vscode remote + wsl在windows上搭建linux开发环境</title>
    <link href="http://onlymisaky.github.io/2019/07/09/"/>
    <id>http://onlymisaky.github.io/2019/07/09/</id>
    <published>2019-07-09T08:25:17.000Z</published>
    <updated>2024-09-11T03:04:29.058Z</updated>
    
    <content type="html"><![CDATA[<p>本文不是安利文章，所以不会介绍任何有关wsl的优点（但是不得不承认，用起来<strong>真的很爽</strong>），这仅仅是一篇没有感情的操作教程。</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h2 id="vscode-remote"><a href="#vscode-remote" class="headerlink" title="vscode remote"></a>vscode remote</h2><blockquote><p>微软在 PyCon 2019 大会上发布了 VS Code Remote，通过安装Remote Development扩展包，可以在很多情况下代替vim直接远程修改与调试服务器上的代码，同时具备代码高亮与补全功能，就和在本地使用VScode一样。从此告别了 SSH + vim。</p></blockquote><h2 id="wsl"><a href="#wsl" class="headerlink" title="wsl"></a>wsl</h2><blockquote><p>Windows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，其目标是使纯正的Ubuntu 14.04 “Trusty Tahr”映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。</p></blockquote><p>简单的说，就是在Windows 10 运行<strong>完整的</strong> Linux 系统。</p><h1 id="安装wsl"><a href="#安装wsl" class="headerlink" title="安装wsl"></a>安装wsl</h1><ol><li>打开控制面板，将查看方式改为类别，点击卸载程序<br><img src="/2019/07/09/01-%E6%89%93%E5%BC%80%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF.png" alt="打开控制面板"></li><li>点击启用或关闭 Windows 功能，在弹窗中勾选 适用于 Linux 的 Windows 子系统，点击确定等待安装<br><img src="/2019/07/09/02-%E5%90%AF%E7%94%A8windows%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%8B%BE%E9%80%89wsl.png" alt="启用windows功能，勾选wsl"></li><li>安装完成后重启操作系统<br><img src="/2019/07/09/03-%E5%AE%89%E8%A3%85%E9%87%8D%E5%90%AF.png" alt="安装重启"></li><li>打开Microsoft store，搜索 ubuntu<br><img src="/2019/07/09/04%E6%90%9C%E7%B4%A2ubuntu.png" alt="搜索ubuntu"></li><li>可以选择其他的Linux发行版本，也可以直接选择Ubuntu安装，这里选择是Ubuntu<br><img src="/2019/07/09/05%E5%85%B6%E4%BB%96linux.png" alt="其他linux"></li><li>安装完成后，会在开始菜单中多出Ubuntu的图标，点击启动，初次进入需要等待安装必要的文件<br><img src="/2019/07/09/06%E5%88%9D%E6%AC%A1%E5%90%AF%E5%8A%A8%E7%AD%89%E5%BE%85%E5%AE%89%E8%A3%85.png" alt="初次启动等待安装"></li><li>文件安装完成后设置username和password即可进入Ubuntu子系统<br><img src="/2019/07/09/07-%E8%AE%BE%E7%BD%AEname%E5%92%8Cpwd.png" alt="设置name和pwd"><br><img src="/2019/07/09/08-%E8%BF%9B%E5%85%A5%E7%B3%BB%E7%BB%9F.png" alt="进入系统"></li></ol><h1 id="配置Ubuntu"><a href="#配置Ubuntu" class="headerlink" title="配置Ubuntu"></a>配置Ubuntu</h1><p>Ubuntu安装完成后，为了更好的使用，做一些简单的配置</p><h2 id="更新镜像地址，以获取更快的下载速度"><a href="#更新镜像地址，以获取更快的下载速度" class="headerlink" title="更新镜像地址，以获取更快的下载速度"></a>更新镜像地址，以获取更快的下载速度</h2><ol><li>备份源配置文件   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.backup</span><br></pre></td></tr></table></figure></li><li>修改源配置为清华大学开源镜像地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a><br>如果对vim操作不是很熟悉，可以打开 <code>C:\Users\你的用户名\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\etc\apt</code> 通过 Windows 的文本编辑器或其他文件编辑工具来修改。<br><img src="/09-%E4%BF%AE%E6%94%B9%E6%BA%90%E5%9C%B0%E5%9D%80.png" alt="修改源地址"></li><li>更新仓库列表<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><img src="/2019/07/09/10-%E6%9B%B4%E6%96%B0%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80.png" alt="更新仓库地址"></li></ol><h2 id="安装-zsh-和-oh-my-zsh"><a href="#安装-zsh-和-oh-my-zsh" class="headerlink" title="安装 zsh 和 oh-my-zsh"></a>安装 zsh 和 oh-my-zsh</h2><p>该步骤不是必须的，只是个人偏爱zsh，而且zsh相较于Ubuntu自带bash要好用很多</p><ol><li>安装<code>zsh</code>、<code>curl</code>、<code>git</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install zsh curl git</span><br></pre></td></tr></table></figure></li><li>从 github 下载安装 oh-my-zsh<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><img src="/2019/07/09/11-%E5%AE%89%E8%A3%85oh-my-zsh.png" alt="安装oh-my-zsh"><br>下载完成后，根据提示进行操作完成后，默认的 shell 会从 bash 修改为 zsh，如果下次启动 Ubuntu 后，默认 shell 还是 bash 可以通过以下命令手动修改默认 shell<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/shells <span class="comment">#查看所有shell</span></span><br><span class="line">chsh -s /bin/zsh <span class="comment">#设置zsh为默认shell</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="安装openssh-server"><a href="#安装openssh-server" class="headerlink" title="安装openssh-server"></a>安装openssh-server</h2><h2 id="需要通过-shh-连接到-Ubuntu，所以这里要安装一下-openssh-server"><a href="#需要通过-shh-连接到-Ubuntu，所以这里要安装一下-openssh-server" class="headerlink" title="需要通过 shh 连接到 Ubuntu，所以这里要安装一下 openssh-server"></a>需要通过 shh 连接到 Ubuntu，所以这里要安装一下 <code>openssh-server</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install openssh-server</span><br></pre></td></tr></table></figure></h2><p>至此，wsl的安装就结束了，这样你就在你的Windows 10 上面拥有了一个完成的 Ubuntu 系统，你也可以根据的需求，配置不同的开发环境了。</p><h1 id="安装Remote-Development并连接-WSL"><a href="#安装Remote-Development并连接-WSL" class="headerlink" title="安装Remote Development并连接 WSL"></a>安装Remote Development并连接 WSL</h1><ol><li>安装 <a href="https://code.visualstudio.com/">Visual studio Code</a> (这不是废话吗)</li><li>在插件市场中搜索 <code>remote</code> , 会出现几个相似的图标和名称，只需要选择 <code>Remote Development</code> 这个插件安装即可，剩下的几个会自动帮我们安装好<br><img src="/2019/07/09/12-%E5%AE%89%E8%A3%85remote%E6%89%A9%E5%B1%95.png" alt="安装remote扩展"><br>安装完成后，侧边活动栏会多出一个远程桌面的图标，左下角也会多出一个代码的小图标<br><img src="/2019/07/09/13-%E5%AE%89%E8%A3%85remote%E5%AE%8C%E6%88%90.png" alt="安装remote完成"></li><li>在 wsl 上安装 vscode-server，点击左下角的小图标，在弹出命令下拉菜单中选择 <code>Remote-WSL: New Window</code><br><img src="/2019/07/09/14-%E5%AE%89%E8%A3%85vscode-server.png" alt="安装vscode-server"><br>此时会打开新的vscode窗口，并且在右下角会显示当前的安装状态，耐心等待完成完成<br><img src="/2019/07/09/15-%E7%AD%89%E5%BE%85vscode-server%E5%AE%89%E8%A3%85.png" alt="等待vscode-server安装"></li><li>同步本机上的插件到 vscode-server 上面。如果你是一个 vscode 老用户，那你肯定积累很多自己常用的插件。但是本机上的 vscode 插件和 Ubuntu 上面的 vscode 插件时完全独立的，所有需要你单独再安装一次，不过安装过程很简单，在连接上 WSL 后，选择侧边活动的插件市场按钮，会列出本地 vscode 上已经安装的插件，你只需要点击安装按钮，就可以将对应的插件安装到 vscode-server 上面了<br><img src="/2019/07/09/16-%E4%B8%BAvscode-server%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6.png" alt="为vscode-server安装插件"></li><li>在完成以上的操作之后，你就已经完成了所有的配置，下面就可以开始你的开(折)发(腾)之旅了。</li></ol><h1 id="连接到远程服务器"><a href="#连接到远程服务器" class="headerlink" title="连接到远程服务器"></a>连接到远程服务器</h1><p>对于有自己服务器的小伙伴，你也可以通过 vscode remote 远程连接到自己的服务，由于我<strong>家境贫寒</strong>，买不起自己的服务器，所以没法给你们演示如何连接远程服务器的操作了。不过没关系，我可以把虚拟机中 Ubuntu 当做 远程成服务器来操作演示。<br>这里演示是用 SSH keys 的方式连接的，你也可以用账号密码的方式连接，选择自己喜好的即可。</p><ol><li>生成 SSH keys<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></li><li>将生成的 key (存放在id_rsa.pub文件中) 添加到远程服务器的  &#x2F;home&#x2F;用户名&#x2F;.ssh&#x2F;authorized_keys 文件中</li><li>打开 vscode ，选择侧边活动的 remote 图标，配置服务器信息<br><img src="/2019/07/09/17-%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E6%81%AF.png" alt="配置服务器信息"><br><img src="/2019/07/09/18-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B7%E4%BD%93%E4%BF%A1%E6%81%AF.png" alt="服务器具体信息"><br>Host：服务器名称，可以随便填<br>HostName：服务器地址，我的虚拟机地址是<code>192.168.106.128</code><br>User：用户名<br>其他详细信可以点击这里查看：<a href="https://linux.die.net/man/5/ssh_config">https://linux.die.net/man/5/ssh_config</a></li><li>配置成功后，点击加号按钮连接。如果是第一连接，也需要安装 vscode-server ，不过都是全自动的，只要耐心等待即可；如果你是通过用户名+密码的方式连接的话，途中需要打开 vscode 的终端，手动输入密码<br><img src="/2019/07/09/19-%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90.png" alt="配置完成"></li><li>连接成功后就可以愉快的记性远程调试啦<br><img src="/2019/07/09/20-%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%90%E5%8A%9F.png" alt="连接服务器成功"></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文不是安利文章，所以不会介绍任何有关wsl的优点（但是不得不承认，用起来&lt;strong&gt;真的很爽&lt;/strong&gt;），这仅仅是一篇没有感情的操作教程。&lt;/p&gt;
&lt;h1 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="http://onlymisaky.github.io/2019/05/29/"/>
    <id>http://onlymisaky.github.io/2019/05/29/</id>
    <published>2019-05-29T11:00:20.000Z</published>
    <updated>2024-09-11T03:04:28.922Z</updated>
    
    <content type="html"><![CDATA[<!-- .slide: data-background="#49B1F5" --><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><br /><div class="fragment fade-up" data-fragment-index="1">分享人：</div><br /> <div class="fragment fade-up" data-fragment-index="2">现任 『企鹅杏仁』 ~~最年轻的~~ 前端工程师 — 奥利安奇</div><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#C7916B" --><h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><p>—-分段—-</p><!-- .slide: data-background="#C7916B" --><p>TypeScript是JavaScript类型的超集，它可以编译成纯JavaScript。<br>—-分段—-</p><!-- .slide: data-background="#C7916B" --><p>TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。<br>—-分段—-</p><!-- .slide: data-background="#C7916B" --><p>简单的说</p><p><span class="fragment" data-fragment-index="1">Type</span><br><span class="fragment" data-fragment-index="2" data-autoslide="500"> + JavaScript</span><br><span class="fragment" data-fragment-index="3"> &#x3D; TypeScript</span><br>—-分段—-</p><!-- .slide: data-background="#C7916B" --><p><img src="/2019/05/29/ts%E5%92%8Cjs%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="ts和js的关系"></p><!-- /ppt/TypeScript/ --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#00C4B6" --><h2 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h2><ol><li>静态类型检查<!-- .element: class="fragment fade-up" data-fragment-index="1" --></li><li>IDE 智能提示<!-- .element: class="fragment fade-up" data-fragment-index="2" --> </li><li>代码重构<!-- .element: class="fragment fade-up" data-fragment-index="3" --> </li><li>可读性<!-- .element: class="fragment fade-up" data-fragment-index="4" -->—-分段—-<!-- .slide: data-background="#00C4B6" -->倔强的你就是不想用</li></ol><ul><li><p>你需要在 HTML 里大量嵌入 JavaScript 代码，而非 HTML 和 JavaScript 分离</p><!-- .element: class="fragment fade-up" data-fragment-index="1" --></li><li><p>项目中大量依赖了第三方 JavaScript 类库，并且这些类库没有 .d.ts 文件</p><!-- .element: class="fragment fade-up" data-fragment-index="2" --></li><li><p>你是 “微软雅黑” </p><!-- .element: class="fragment fade-up" data-fragment-index="3" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#1B9EF3" --></li></ul><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>/<span class="keyword">let</span>/<span class="keyword">const</span> 变量名: 类型 = 值;</span><br></pre></td></tr></table></figure><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>—-分段—-</p><!-- .slide: data-background="#1B9EF3" --><h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#1B9EF3" --><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;qq&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">word</span>: <span class="built_in">string</span> = <span class="string">`my name is <span class="subst">$&#123;word&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#1B9EF3" --><h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#1B9EF3" --><h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#1B9EF3" --><h2 id="void-空值"><a href="#void-空值" class="headerlink" title="void 空值"></a>void 空值</h2><p><small>空类型，表示没有类型，比如无返回值函数的返回值类型</small></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">void</span> &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#1B9EF3" --><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p><small>任意类型，表示未知类型，比如动态内容（用户输入、或第三方类库）或不知道类型的东西（混合类型数组），可以声明any类型绕过类型检查</small></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">any</span> = <span class="number">1</span>;</span><br><span class="line">str = <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>不要让你的代码成为AnyScript<!-- .element: class="fragment fade-up" data-fragment-index="1" --><br>—-分段—-</p><!-- .slide: data-background="#1B9EF3" --><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><small>绝不存在的值的类型，如永远不会返回的函数（必定抛异常的，或函数体有死循环的）的返回值类型</small></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params"><span class="attr">message</span>: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#002b36" --><p>只有这些怎么够呢？<br>—-分段—-</p><!-- .slide: data-background="#002b36" --><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">nums</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strs</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;你&#x27;</span>, <span class="string">&#x27;好&#x27;</span>, <span class="string">&#x27;呀&#x27;</span> , <span class="string">&#x27;！&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">baz</span>: <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt; = [<span class="string">&#x27;你&#x27;</span>, <span class="string">&#x27;好&#x27;</span>, <span class="number">6</span> , <span class="literal">true</span>];</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#002b36" --><h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p><small>元组，表示一组固定数量的元素（不要求元素类型相同），如二元组，三元组</small></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">status</span>: [<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&quot;DONE&quot;</span>, <span class="string">&quot;已结束&quot;</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#002b36" --><h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">OrderStatus</span> &#123;</span><br><span class="line">  <span class="variable constant_">UNPAID</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="variable constant_">UNUSED</span>,</span><br><span class="line">  <span class="variable constant_">USING</span>,</span><br><span class="line">  <span class="variable constant_">INVALID</span>,</span><br><span class="line">  <span class="variable constant_">DONE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">state</span>: <span class="built_in">number</span> = <span class="title class_">OrderStatus</span>.<span class="property">DONE</span>;</span><br></pre></td></tr></table></figure><p>双向索引</p><!-- .element: class="fragment fade-up" data-fragment-index="1" --><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">stateStr</span>: <span class="built_in">string</span> = <span class="title class_">OrderStatus</span>[<span class="title class_">OrderStatus</span>[<span class="string">&#x27;DONE&#x27;</span>]]; <span class="comment">// DONE</span></span><br></pre></td></tr></table></figure><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>—-分段—-</p><!-- .slide: data-background="#002b36" --><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p><small>可以通过类型断言告知TypeScript编译器某个值的确切类型，类似于其它语言里的强制类型转换，区别在于类型断言只是编译时的，不像类型转换一样具有运行时影响</small></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;type&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">length1</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br><span class="line"><span class="comment">// as type</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">length2</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#002b36" --><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="comment">// index.ts(2,1): </span></span><br><span class="line"><span class="comment">//  error TS2322: </span></span><br><span class="line"><span class="comment">//    Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFavoriteNumber</span>: <span class="built_in">string</span> = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#69C282" --><p>表达能力还是不够</p><!-- .element: class="fragment fade-out" data-fragment-index="1" --><h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>—-分段—-</p><!-- .slide: data-background="#69C282" --><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。<br>—-分段—-</p><!-- .slide: data-background="#69C282" --><p>不喜欢看官方的描述？<!-- .element: class="fragment fade-out" data-fragment-index="1" --></p><p>interface就是用来描述对象的属性和方法，和C语言中的struct更像一些。</p><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>—-分段—-</p><!-- .slide: data-background="#69C282" --><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">fe1</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;奥利安奇&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">fe2</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Xeon&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other fe...</span></span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#69C282" --><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IFe</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">fe1</span>: <span class="title class_">IFe</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;奥利安奇&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">fe2</span>: <span class="title class_">IFe</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Xeon&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other fe...</span></span><br></pre></td></tr></table></figure><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>—-分段—-</p><!-- .slide: data-background="#69C282" --><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPatient</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">phone</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  idCode?: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#69C282" --><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPatient</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">phone</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  idCode?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#69C282" --><h2 id="索引属性（任意属性）"><a href="#索引属性（任意属性）" class="headerlink" title="索引属性（任意属性）"></a>索引属性（任意属性）</h2><p><small>有些场景下无法确定属性名称</small></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPatient</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">phone</span>: <span class="built_in">string</span>;</span><br><span class="line">  idCode?: <span class="built_in">string</span>;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">patient</span>: <span class="title class_">IPatient</span>;</span><br><span class="line">patient[<span class="string">&#x27;sex&#x27;</span>] = <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure><p><small class="fragment fade-up" data-fragment-index="1">一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</small><br>—-分段—-</p><!-- .slide: data-background="#69C282" --><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Base64</span> &#123;</span><br><span class="line">  <span class="title function_">encode</span>(<span class="attr">input</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">decode</span>(<span class="attr">input</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">base64</span>: <span class="title class_">Base64</span>;</span><br><span class="line">base64.<span class="title function_">encode</span>(<span class="string">&#x27;1234&#x27;</span>);</span><br><span class="line">base64.<span class="title function_">decode</span>(<span class="string">&#x27;sxdwwq&#x27;</span>);</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#69C282" --><h2 id="骚操作"><a href="#骚操作" class="headerlink" title="骚操作"></a>骚操作</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GetStrLength</span> &#123;</span><br><span class="line">  (<span class="attr">str</span>: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="title class_">GetStrLength</span> = <span class="function">(<span class="params"><span class="attr">s</span>: <span class="built_in">string</span></span>) =&gt;</span> s.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Nums</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">Nums</span> = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#1e1e1e" --><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">add</span>: <span class="function">(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#1e1e1e" --><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p><small>JavaScript里参数默认都是可选的（不传的默认undefined），而TypeScript认为每个参数都是必填的，除非显式声明可选参数</small></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params"><span class="attr">firstName</span>: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (lastName)</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);  </span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#1e1e1e" --><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params"><span class="attr">firstName</span>: <span class="built_in">string</span>, lastName = <span class="string">&quot;Smith&quot;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">buildName</span>(<span class="string">&#x27;Will&#x27;</span>, <span class="number">123</span>); <span class="comment">//error 类型“123”的参数不能赋给类型“string”的参数</span></span><br></pre></td></tr></table></figure><p><small>带默认值的参数不需要放在必须参数的后面，但必须明确的传入 undefined值来获得默认值</small></p><!-- .element: class="fragment fade-up" data-fragment-index="1" --><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName = <span class="string">&quot;Will&quot;</span>, <span class="attr">lastName</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">buildName</span>(<span class="literal">undefined</span>, <span class="string">&quot;Smith&quot;</span>);</span><br></pre></td></tr></table></figure><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>—-分段—-</p><!-- .slide: data-background="#1e1e1e" --><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params"><span class="attr">firstName</span>: <span class="built_in">string</span>, ...<span class="attr">restOfName</span>: <span class="built_in">string</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">buildName</span>(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#1e1e1e" --><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">$(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">$([])</span><br><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;)</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#00c4b6" --><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>—-分段—-</p><!-- .slide: data-background="#00c4b6" --><p>Minimal Class</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> version = <span class="string">&#x27;1.0.0&#x27;</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">messages</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">hasReads</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">messages</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> !item.<span class="property">read</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">messages</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">content</span>: msg,</span><br><span class="line">      <span class="attr">read</span>: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">messages</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#00c4b6" --><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><ul><li>public：类的成员属性&#x2F;方法默认都是public，没有访问限制<!-- .element: class="fragment fade-up" data-fragment-index="1" --></li><li>private：无法在该类声明的外部访问其成员（如无法通过this.xxx访问私有成员）<!-- .element: class="fragment fade-up" data-fragment-index="2" --></li><li>protected：与private类似，但在派生类中也可以访问受保护成员<!-- .element: class="fragment fade-up" data-fragment-index="3" -->—-分段—-<!-- .slide: data-background="#00c4b6" --><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">theName</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">foo</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">move</span>(<span class="params"><span class="attr">distanceInMeters</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>注意</strong>，这些访问控制都只是编译时的限制，<strong>运行时并不做强检查</strong>。符合TypeScript的设计原则：<!-- .element: class="fragment fade-up" data-fragment-index="1" --><blockquote><p>不给编译产物增加运行时开销</p></blockquote><!-- .element: class="fragment fade-up" data-fragment-index="1" -->—-分段—-<!-- .slide: data-background="#00c4b6" --><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Animal</span> = <span class="comment">/** <span class="doctag">@class</span> */</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">theName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">move</span> = <span class="keyword">function</span> (<span class="params">distanceInMeters</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; moved &quot;</span> + distanceInMeters + <span class="string">&quot;m.&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Animal</span>;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>—-分段—-<!-- .slide: data-background="#00c4b6" -->but!!!!<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RGBColor</span> &#123;</span><br><span class="line">#hex</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">r, g, b</span>) &#123;</span><br><span class="line">#hex = r * <span class="number">0x10000</span> + g * <span class="number">0x100</span> + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;<span class="variable language_">this</span>.red&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.green&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.blue&#125;</span>)`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">red</span>()   &#123; <span class="keyword">return</span> #hex &gt;&gt; <span class="number">16</span> &#125;</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">green</span>() &#123; <span class="keyword">return</span> (#hex &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span> &#125;</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">blue</span>()  &#123; <span class="keyword">return</span> #hex &amp; <span class="number">0xff</span> &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="title function_">equals</span>(<span class="params">c1, c2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c1.#hex === c2.#hex</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a href="https://github.com/tc39/proposal-private-fields/issues/14">Why not use the “private” keyword, like Java or C#?</a><!-- .element: class="fragment fade-up" data-fragment-index="3" --><a href="https://github.com/tc39/proposal-class-fields/issues/100">A summary of feedback regarding the # sigil prefix</a><!-- .element: class="fragment fade-up" data-fragment-index="3" -->—-分段—-<!-- .slide: data-background="#00c4b6" --></li></ul><h2 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h2><p>—-分段—-</p><!-- .slide: data-background="#00c4b6" --><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// 声明和赋值合并</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Animal</span> = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;jerry&#x27;</span>; </span><br><span class="line"><span class="comment">// Cannot assign to &#x27;name&#x27; because it is a read-only property.ts(2540)</span></span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#00c4b6" --><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">makeSound</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;roaming the earch...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口只能定义抽象方法</p><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#49B1F5" --><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>等等…我还没想好…☺️</p><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>不要问我了！我真不知道😭</p><!-- .element: class="fragment fade-up" data-fragment-index="2" --><p>—-分段—-</p><!-- .slide: data-background="#49B1F5" --><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/1&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> user = response.<span class="property">data</span>; <span class="comment">// user长啥样 🤔🤔</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/patients&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> patients = response.<span class="property">data</span>; <span class="comment">// patients又长啥样🤔🤔</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#49B1F5" --><h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray&lt;T&gt;(<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): T[] &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#49B1F5" --><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span> &#123;</span><br><span class="line">  &lt;T&gt;(<span class="attr">arg</span>: T): T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentity</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">id</span>(<span class="attr">arg</span>: T): T;</span><br><span class="line">  <span class="title function_">idArray</span>(...<span class="attr">args</span>: T[]): T[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#49B1F5" --><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>&lt;<span class="title class_">IProp</span>, <span class="title class_">IState</span>&gt;&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">prop</span>: <span class="title class_">IProp</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">state</span>: <span class="title class_">IState</span></span></span><br><span class="line"><span class="params">  </span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AppProp</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AppState</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Component</span>&lt;<span class="title class_">AppProp</span>, <span class="title class_">AppState</span>&gt;(&#123; <span class="attr">name</span>: <span class="string">&#x27;MyAPP&#x27;</span> &#125;, &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#49B1F5" --><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>&lt;<span class="title class_">IProp</span> <span class="keyword">extends</span> &#123; <span class="attr">parentName</span>: <span class="built_in">string</span> &#125;, <span class="title class_">IState</span>&gt;  &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">prop</span>: <span class="title class_">IProp</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">state</span>: <span class="title class_">IState</span></span></span><br><span class="line"><span class="params">  </span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#49B1F5" --><h2 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray&lt;T = <span class="built_in">string</span>&gt;(<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">result</span>: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#C7916B" --><h1 id="TSX"><a href="#TSX" class="headerlink" title="TSX"></a>TSX</h1><p><small>TypeScript 也支持JSX，只需 2 步，即可使用 TypeScript 写 JSX：</small></p><ol><li>源码文件用.tsx扩展<!-- .element: class="fragment fade-up" data-fragment-index="1" --></li><li>开启–jsx选项<!-- .element: class="fragment fade-up" data-fragment-index="2" -->—-分段—-<!-- .slide: data-background="#C7916B" --><img src="/2019/05/29/tsx.png" alt="tsx"><br>—-分段—-<!-- .slide: data-background="#C7916B" --></li></ol><ul><li>preserve：生成.jsx文件，但保留 JSX 语法不转换，交给后续构建环节（如Babel）处理</li><li>react：生成.js文件，将 JSX 语法转换成React.createElement</li><li>react-native：生成.js文件，但保留 JSX 语法不转换<br>—-分段—-<!-- .slide: data-background="#C7916B" --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>App<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;<!-- .slide: data-background="#00c4b6" --></li></ul><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>—-分段—-</p><h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><!-- .slide: data-background="#00c4b6" --><p><a href="https://angular.cn/">Angular</a></p><p><a href="https://angular.cn/generated/live-examples/toh-pt6/stackblitz.html">hero</a></p><ul><li>支持最好</li><li>开箱即用</li><li>工具链丰富<br>—-分段—-<!-- .slide: data-background="#00c4b6" --><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">OnInit</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Hero</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../hero&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HeroService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../hero.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-dashboard&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./dashboard.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [ <span class="string">&#x27;./dashboard.component.css&#x27;</span> ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">DashboardComponent</span> <span class="keyword">implements</span> <span class="title class_">OnInit</span> &#123;</span><br><span class="line">  <span class="attr">heroes</span>: <span class="title class_">Hero</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="attr">heroService</span>: <span class="title class_">HeroService</span></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">ngOnInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getHeroes</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getHeroes</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heroService</span>.<span class="title function_">getHeroes</span>()</span><br><span class="line">      .<span class="title function_">subscribe</span>(<span class="function"><span class="params">heroes</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">heroes</span> = heroes.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>—-分段—-</li></ul><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><!-- .slide: data-background="#00c4b6" --><ul><li>npm i create-react-app -g<!-- .element: class="fragment fade-up" data-fragment-index="1" --></li><li>create-react-app myApp –typescritp<!-- .element: class="fragment fade-up" data-fragment-index="2" --><br>—-分段—-<!-- .slide: data-background="#00c4b6" --> 函数式组件</li></ul><img src="函数式组件.png" width="70%">----分段----<!-- .slide: data-background="#00c4b6" --> class组件<img src="class组件.png" width="65%">----分段----<!-- .slide: data-background="#00c4b6" --> ## Vue[vue-class-component](https://github.com/vuejs/vue-class-component)、[vue-property-decorator](https://github.com/kaorun343/vue-property-decorator)、[vuex-class](https://github.com/ktsn/vuex-class/)、[TodoMvc-vue](https://github.com/onlymisaky/TodoMvc-vue)- vue cli 内置了 TypeScript 工具支持- 在 Vue 的下一个大版本 (3.x) 中也计划了相当多的 TypeScript 支持改进----分段----<!-- .slide: data-background="#00c4b6" --> <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Watch</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue-property-decorator&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">State</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vuex-class&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TodoHeader</span> <span class="keyword">from</span> <span class="string">&quot;@/components/todo-header.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TodoMain</span> <span class="keyword">from</span> <span class="string">&quot;@/components/todo-main.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TodoFooter</span> <span class="keyword">from</span> <span class="string">&quot;@/components/todo-footer.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; saveTodos &#125; <span class="keyword">from</span> <span class="string">&quot;@/utils/store.ts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Todo</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@/types/todo&quot;</span>;</span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">TodoHeader</span>,</span><br><span class="line">    <span class="title class_">TodoMain</span>,</span><br><span class="line">    <span class="title class_">TodoFooter</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@State</span>(<span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">todo</span>.<span class="property">todoList</span>)</span><br><span class="line">  todoList!: <span class="title class_">Todo</span>[];</span><br><span class="line">  <span class="meta">@Watch</span>(<span class="string">&quot;todoList&quot;</span>, &#123; <span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">immediate</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="title function_">todoListChange</span>(<span class="params"><span class="attr">todos</span>: <span class="title class_">Todo</span>[]</span>) &#123;</span><br><span class="line">    <span class="title function_">saveTodos</span>(todos);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>----分段----<!-- .slide: data-background="#00c4b6" --> ## But!![the Class API proposal is being dropped](https://github.com/vuejs/rfcs/pull/17#issuecomment-494242121)<!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>所以没有折腾精神，追求稳定，还是等Vue3吧</p><!-- .element: class="fragment fade-up" data-fragment-index="2" --><p><a href="https://zhuanlan.zhihu.com/p/68477600">Vue Function-based API RFC</a><!-- .element: class="fragment fade-up" data-fragment-index="3" --><br>—-分段—-</p><!-- .slide: data-background="#00c4b6" --> <h2 id="nest"><a href="#nest" class="headerlink" title="nest"></a><a href="https://docs.nestjs.cn/">nest</a></h2><img src="nest-logo.svg" width="50%">----分段----<!-- .slide: data-background="#00c4b6" --> 用于构建高效且可伸缩的服务端应用程序的渐进式 Node.js 框架。<ul><li>完美支持 Typescript<!-- .element: class="fragment fade-up" data-fragment-index="1" --></li><li>面向 AOP 编程<!-- .element: class="fragment fade-up" data-fragment-index="2" --></li><li>支持 typeorm<!-- .element: class="fragment fade-up" data-fragment-index="3" --></li><li>Node.js 版的 spring<!-- .element: class="fragment fade-up" data-fragment-index="4" --></li><li>构建微服务应用<!-- .element: class="fragment fade-up" data-fragment-index="5" --><br>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;<!-- .slide: data-background="#002b36" --></li></ul><h1 id="BB这么多，到底怎么用？"><a href="#BB这么多，到底怎么用？" class="headerlink" title="BB这么多，到底怎么用？"></a>BB这么多，到底怎么用？</h1><p>—-分段—-</p><!-- .slide: data-background="#002b36" --> <img src="tsc.gif" width="100%"/>----分段----<!-- .slide: data-background="#002b36" --> ## tsconfig.js<small  class="fragment fade-up" data-fragment-index="1">告诉typescript如何编译ts文件，比如前面提到的`--jsx`选项，编译后的js版本(`target`等等)</small><p><small  class="fragment fade-up" data-fragment-index="2">如果一个目录下存在一个<code>tsconfig.json</code>文件，那么它意味着这个目录是TypeScript项目的根目录。<code> tsconfig.json</code>文件中指定了用来编译这个项目的根文件和编译选项。</small></p><p><a href="https://www.tslang.cn/docs/handbook/compiler-options.html">编译选项</a><!-- .element: class="fragment fade-up" data-fragment-index="4" --><br>—-分段—-</p><!-- .slide: data-background="#002b36" --> <h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.tsx&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&quot;/dist&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123; </span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.tsx&quot;</span>, <span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>, <span class="attr">loader</span>: <span class="string">&quot;ts-loader&quot;</span> &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>—-分段—-</p><!-- .slide: data-background="#002b36" --><h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&quot;gulp&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ts = <span class="built_in">require</span>(<span class="string">&quot;gulp-typescript&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> tsProject = ts.<span class="title function_">createProject</span>(<span class="string">&quot;tsconfig.json&quot;</span>);</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;default&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> tsProject.<span class="title function_">src</span>()</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">tsProject</span>())</span><br><span class="line">    .<span class="property">js</span>.<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;dist&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#69c282" --><h1 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h1><p>并不是所有的文件都是使用typescript编写的，当使用这些由JavaScript编写的第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。<!-- .element: class="fragment fade-up" data-fragment-index="1" --><br>—-分段—-</p><h2 id="获取声明文件途径"><a href="#获取声明文件途径" class="headerlink" title="获取声明文件途径"></a>获取声明文件途径</h2><!-- .slide: data-background="#69c282" --><ul><li><a href="http://microsoft.github.io/TypeSearch/">TypeSearch</a><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p class="fragment fade-up" data-fragment-index="2">`@types/react`、 `@types/react-dom` 、`types/react-redux` ...</p><p class="fragment fade-up" data-fragment-index="3">仓库地址：[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/)</p></li></ul><p>—-分段—-</p><!-- .slide: data-background="#69c282" --><ul><li>自己动手编写(<a href="https://www.tslang.cn/docs/handbook/declaration-files/introduction.html">声明文件编写介绍</a>)</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params"><span class="attr">selector</span>: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><!-- .element: class="fragment fade-up" data-fragment-index="1" --><p>编写声明文件也是学习typescript的一个很好的入门途径</p><!-- .element: class="fragment fade-up" data-fragment-index="2" --><p>&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D;</p><!-- .slide: data-background="#1e1e1e" --><h1 id="JSDOC"><a href="#JSDOC" class="headerlink" title="JSDOC"></a>JSDOC</h1><p>—-分段—-</p><!-- .slide: data-background="#1e1e1e" --><ul><li><a href="http://usejsdoc.org/">JSDOC</a></li><li><a href="https://gitlab.aihaisi.com/docs/docs/issues/423">震惊！JavaScript 竟然可以类型推断！</a><img src="JSDoc.png" class="fragment fade-up" data-fragment-index="1" width="60%"/>====分页====<!-- .slide: data-background="#49B1F5" --></li></ul><h1 id="谢谢"><a href="#谢谢" class="headerlink" title="谢谢"></a>谢谢</h1><p class="fragment fade-up" data-fragment-index="1">打游戏时拿命在C的<h3 class="fragment fade-up" data-fragment-index="2">奥利安奇</h3></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- .slide: data-background=&quot;#49B1F5&quot; --&gt;
&lt;h1 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>最近零事</title>
    <link href="http://onlymisaky.github.io/2018/10/17/"/>
    <id>http://onlymisaky.github.io/2018/10/17/</id>
    <published>2018-10-17T07:28:10.000Z</published>
    <updated>2024-09-11T03:04:29.058Z</updated>
    
    <content type="html"><![CDATA[<p>看了一下 git 提交记录，已经有两个月没写东西了，主要还是工作太忙了，一周至少有三天时间加班到夜晚9点之后，身体方面很是吃不消，经常感觉浑身不舒服，甚至开始担心自己会猝死。当然灵魂方面也饱受摧残，每天都在填坑，写自己不喜欢的代码。作为一个有代码洁癖的人，这几个月来也算是被折磨的服服帖帖的了。</p><p>因为长期处于高强度的工作状态，思考的时间都放在通勤途中的和每日睡前了。大城市是一列停不下来的火车，而我们就是车上的煤，一铲一铲的被扔进锅炉里燃烧，没有任何挣扎也不能挣扎，等年纪大一些了，也就成了煤渣，也该回到原来的故处谋划以后的生计。</p><p>作为一块不够黑也不够亮、甚至夹杂一些杂质的煤炭，也想成为这列车上的乘客，站票也无所谓。但是光做眼前的事，好像也不能实现什么。</p><p>人生已过二十几载，平凡不可平庸。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看了一下 git 提交记录，已经有两个月没写东西了，主要还是工作太忙了，一周至少有三天时间加班到夜晚9点之后，身体方面很是吃不消，经常感觉浑身不舒服，甚至开始担心自己会猝死。当然灵魂方面也饱受摧残，每天都在填坑，写自己不喜欢的代码。作为一个有代码洁癖的人，这几个月来也算是被</summary>
      
    
    
    
    
    <category term="闲聊" scheme="http://onlymisaky.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>webpack快速上手</title>
    <link href="http://onlymisaky.github.io/2018/07/23/"/>
    <id>http://onlymisaky.github.io/2018/07/23/</id>
    <published>2018-07-23T07:32:00.000Z</published>
    <updated>2024-09-11T03:04:29.038Z</updated>
    
    <content type="html"><![CDATA[<p>嫌啰嗦想直接看最终的配置请戳这里<a href="https://github.com/onlymisaky/webpack-workbench">webpack-workbench</a> </p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>用两个自问自答来当作序吧：</p><ul><li><p>Q：为什么要写这篇文章？</p></li><li><p>A：因为我在将自己的一个项目 <a href="https://github.com/onlymisaky/AngularJS-ES6">AngularJS-ES6</a> 从 webpack3.x 升级到 4.x 的时候发现，作为一个熟练的 GitHub 搬运工，改起来还是很费力，主要是因为对其没有一个更完整的认知，因此有必要写一篇文章强化认知。</p></li><li><p>Q：既然是写给自己看的，那对于其他人有帮助吗？</p></li><li><p>A：如果你对 webpack 有少许的了解（至少知道webpack是干什么用的），那这篇文章应该还是有帮助的。</p></li></ul><h2 id="Why-webpack？"><a href="#Why-webpack？" class="headerlink" title="Why webpack？"></a>Why webpack？</h2><p>一个工具的诞生，必然有其诞生的原因，也许是为了简化工作，也许是为了解决某些痛点，也可能是今年的kpi压力很大…</p><p>今天的主角 webpack 的诞生就是为了解决前端开发长久以来的痛点：<strong>模块化</strong> ，这是也它的前辈 <a href="https://gruntjs.com/">grunt</a> 和 <a href="https://gulpjs.com/">gulp</a> 所不具备的功能。</p><p>回想一下那个前端还被称作切图仔的时代，我们是怎么组织多个 <code>.js</code> 文件的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;c.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>且不说这样写有多low，就单从代码维护角度来说，<code>b.js</code> 可能使用了 <code>a.js</code> 中的某个方法； <code>c.js</code> 同样如此，可能还用到了 <code>b.js</code> 中的某些方法。单看每个文件，是根本不知道这些方法是哪来的，也不清楚这三个文件之间的依赖关系的。</p><p>为了解决的这个问题，<a href="https://github.com/requirejs/requirejs">requirejs</a> 诞生了，这是一套 <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a> 的模块化实现方案。而此时 node 已经出现有些时日，其遵循的是 <a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS</a> ，同样是 <code>JavaScript</code> 模块化，却有两套实现方案，语法也不一样。于是又出现了 <a href="https://github.com/seajs/seajs/issues/242">CMD</a> 和其实现 <code>seajs</code> ，它是为了让服务端模块化和浏览器端模块化的差异能够最小化。</p><p>以上这些都是前辈们对 JavaScript 模块化的探索，虽然不是标准，但却推动了标准的发展，于是在 ES6 中，终于有了标准的、原生的模块化方案了，然鹅… </p><p>浏览器厂商：标准是标准，至于什么时候实现，fucked say (日后再议)。虽然现在大部分浏览器内核都实现了原生的模块化，但是我们不能确保用户都已将浏览器更新至最新了。</p><p>所以，在所有浏览器都实现模块化标准之前，我们还是不能够愉快的使用 <strong>import</strong> 和 <strong>export</strong> ，于是 webpack 来了，给乡亲们带了希望，让乡亲们再也不用看浏览器脸色，从此过上了没羞没臊幸福的生活了。</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>为了有更好更清晰的认识，建议读者跟着文章一起做一遍，可以先创建一个新的文件夹 <code>learn-webpack</code> ，在该目录中打开命令行，输入 <code>npm init</code> 命令初始化 package.json 文件。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i webpack webpack-cli -D</span><br></pre></td></tr></table></figure><p>可以全局安装，也可以本地安装，建议本地安装，因为 webpack 不同的版本之间还是有一定的差异，为了避免这个问题，我们选择本地。</p><p>在上面安装命令中，除了安装了 webpack 外，还安装了 webpack-cli 。那么这个工具是干什么用的？在 webpack4.x 之后，webpack 把命令行单独提取出来了，也就是说，我们想在命令行中执行 <code>webpack xxx</code> 等命令时，就需要先安装 webpack-cli 。 所以如你的使用的4.x版本的 webpack ，还需要额外安装一下 webpack-cli 。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>webpack 的使用还是比较简单的，并且提供了三种使用方法：</p><ol><li>不使用配置文件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack &lt;entry&gt; &lt;output&gt;</span><br></pre></td></tr></table></figure><p>entry：要打包的文件，可以是一个文件，也可以是一组文件。</p><p>output：打包后生成的文件。</p><p>例如将 <code>./src/index.js</code> 打包到 <code>dist/app.js</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack ./src/index.js dist/app.js</span><br></pre></td></tr></table></figure><ol start="2"><li>使用配置文件</li></ol><p>不使用配置文件的方式显然不够灵活多变，所以通常都是先编写 webpack 配置文件，然后根据配置文件内容进行打包。在根目录下创建 <code>webpack.config.js</code> 文件，然后在命令行中输入 <code>webpack</code> ，webpack 会自动读取 <code>webpack.config.js</code> 中的配置内容，然后进行打包，下文将会着重介绍如合编写配置文件。</p><ol start="3"><li>在node中启动</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="title function_">webpack</span>(&#123;</span><br><span class="line">  <span class="comment">/* webpack配置内容 */</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 打包后回调 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><span id="npm-script"></span></p><h3 id="npm-script"><a href="#npm-script" class="headerlink" title="npm script"></a>npm script</h3><p>在使用第二种方式的时候，我们也可以将一些配置内容以参数的形式添加在命令后面，比如我们想设置环境为 <code>production</code> ，可以在 webpack.config.js 中将 <code>mode</code> 设置为 <code>production</code> ，也可以在命令后面添加 <code> --mode production</code> ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack --mode production</span><br></pre></td></tr></table></figure><p>如果还需要其他的配置参数，可有继续在后面添加。这样做的好处是可以将一些多变的参数从配置文件中抽离出来，使用起来很灵活。</p><p>但是如果参数太多，每次使用的时候又要敲好多命令，可能还会敲错，为了方便管理我们可以将这些命令全部保存在 <code>package.json</code> 的 <code>scripts</code> 属性中：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --mode development&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --mode production&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这样就可以通过 <code>npm run build</code> 命令进行打包了。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>经常看到有人抱怨 webpack 太难太复杂了，“我们万事俱备，就差一个webpack配置工程师了”。确实如此，相比于 <code>gulp</code> 简洁的 api ，webpack 确实复杂了许多。</p><p>其实仔细的梳理一下，webpack 最重要也就4个核心概念：</p><ol><li>entry 入口</li><li>output 出口</li><li>loader 模块转换器</li><li>plugins 插件</li></ol><p>除了这四个核心的概念，剩下的那些都是为了优化代码、让我们能有更好的开发体验而设计的。</p><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>开头先讲一个 webpack4 中新增的选项：mode。可能是受 <a href="https://parceljs.org/">parcel</a> 的刺激，webpack4 终于也可以零配置打包了，主要原因是 webpack 终于明白了一个道理：约定大于配置。</p><p>model 的值有三种：<code>production</code>、<code>development</code>、<code>none</code> ，分别表示不同模式。</p><p>在 production 模式下，会默认启用下面这些插件：</p><ul><li>process.env.NODE_ENV 的值设为 production</li><li>FlagDependencyUsagePlugin：删除无用代码</li><li>FlagIncludedChunksPlugin：删除无用代码</li><li>ModuleConcatenationPlugin：作用域提升</li><li>NoEmitOnErrorsPlugin：编译出现错误，跳过输出阶段</li><li>OccurrenceOrderPlugin</li><li>SideEffectsFlagPlugin</li><li>UglifyJsPlugin：js代码压缩</li></ul><p>在 development 模式下，会默认启用下面这些插件：</p><ul><li>process.env.NODE_ENV 的值设为 development</li><li>devtool 设置为 evel</li><li>NamedChunksPlugin</li><li>NamedModulesPlugin</li></ul><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>既然是模块化开发，就需要有一个入口文件，相关的模块就可以根据这个入口文件形成一个树形的依赖关系。</p><p><img src="/2018/07/23/%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="模块依赖关系"></p><p>当然 webpack 还没有智能到可以自动识别出你的模块依赖关系，所以需要咱们来告诉它，如果你不告诉它，则会默认把 <code>src/index.js</code>(webpack4.x+) 当做入口文件。 </p><p>入口文件可以是一个文件(string)：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;src/main.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以是多个文件(array)：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: [<span class="string">&#x27;src/login.js&#x27;</span>, <span class="string">&#x27;src/logout.js&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至也可以是一个对象(object)：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">login</span>: <span class="string">&#x27;src/login.js&#x27;</span>,</span><br><span class="line">    <span class="attr">logout</span>: <span class="string">&#x27;src/logout.js&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三种写法的区别是：</p><ol><li>传入一个文件(string)的时候，会把所有具有依赖关系的模块打包生成一个文件;</li><li>传入多个文件(array)的时候，还是会打包生成一个文件，webpack会把这些文件合并在一起，但是执行的时候会按照数组内文件的顺序依次执行;</li><li>传入对象的时候，则会根据对象key的个数，打包出对应数量的文件;</li></ol><p>很显然，传入对象的方式更复杂，但也更利于扩展，同时也适合用来打包多页应用。</p><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>有进必有出，webpack 也需要我们指定打包后的文件存放位置，也叫做出口文件，和 entry 一样，output 也有默认值 <code>dist/main.js</code>(webpack4.x+) 。</p><p>下面是 output 常见的配置项：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;/assets/&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>path</li></ul><p>指定打包后的文件存放位置，注意这是一个 <strong>绝对路径</strong>  ！上面的例子中用了 node 内置的常量 __dirname ，该常量表示当前执行文件所在的目录，所以我们打包出的文件就存放在和 webpack 配置文件同级的 <code>dist</code> 目录下面。</p><ul><li>filename</li></ul><p>打包后的文件名称，该选项有5个可配置项：</p><table><thead><tr><th>配置项</th><th>作用</th></tr></thead><tbody><tr><td>[name]</td><td>模块名称，对应 entry 中的 key 值，如果 entry 传入的是 string 或 array 默认为 main</td></tr><tr><td>[id]</td><td>模块id，由 webpack 生成</td></tr><tr><td>[hash]</td><td>模块的 hash 值，当有文件修改时，这个值就会重新计算并改变</td></tr><tr><td>[chunkhash]</td><td>这也是一个 hash 值，webpack中每打包生成一个文件，就叫一个chunk ，它是 chunk 本身的 hash ，<strong>通常用它来做文件缓存</strong></td></tr></tbody></table><p>补充一个小知识，如果 entry 中传入的是对象，且对象的 key 值像这种形式 <code>&quot;a/b&quot;</code> ，并且在 <code>output.filename</code> 中设置了 <code>[name]</code> 那么打包出的文件会存放在 <code>a</code> 文件夹下的 <code>b.js</code> 中（<code>a/b.js</code>）。</p><p><span id="public-path"></span></p><ul><li>publicPath</li></ul><p>关于这个配置，笔者曾经纠结了好久，知道它的作用，却总是无法理解，在网上看了很多关于 publicPath 的介绍，包括 webpack 的官网，但一直没有豁然开朗的感觉，直到后来在自己的项目中遇到了一些问题，才算是明白了为什么会有这个选项。</p><p>如果不想看下面这些内容，可以直接查看 <a href="#public-path-summary">总结</a> ，建议第一次阅读的时候跳过下面这一小段，等到了 <a href="#dev-public-path">devServer.publicPath</a> 再回过来看一遍。</p><p>这里我们可以反向的分析一下。首先，在设置了 path 和 filename 这两个属性之后，便可以确定打包出的文件在本机存放的具体路径了。然后需要明确一点，打包出的代码需要上传到 Web 服务器上，这些文件中可能有 .css .js .png 等等，它们最终都要以 .html 为载体，假设这个文件是 index.html 就像这样：</p><p>注意：index.html 是通过 <a href="#html-webpack-plugin">html-webpack-plugin</a> 插件生成的，下文会介绍到。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;hello.png&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;index.bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从这段简单的 html 中我们可以得到一个信息，那就是 <code>index.css</code>、 <code>hello.png</code>、 <code>index.bundle.js</code> 这个三个文件都放在相对于 index.html 的 同一级别下面，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dist</span><br><span class="line">├── index.html</span><br><span class="line">├── hello.png</span><br><span class="line">├── index.css</span><br><span class="line">└── index.bundle.js</span><br></pre></td></tr></table></figure><p>如果我们的 webpack 设置是下面这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么打包出来的文件结构应该是和上面的一模一样的，我们按照这个结构上传到 Web 服务器，不需要修改什么就可以直接访问了。</p><p>一般公司都有专门的 cdn 服务器，那么你可以把 <code>index.css</code>、 <code>hello.png</code>、 <code>index.bundle.js</code> 这些资源传到 cdn 服务器上，假设你 cdn 地址是 <code>https://mycdn.com</code> 那么你可以通过 <code>https://mycdn.com/index.css</code> 的方式来访问相应的资源。这时候为了使我们的网站不报错，我们就需要将 index.html 中的资源引用方式改为 ：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://mycdn.com/index.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://mycdn.com/hello.png&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://mycdn.com/index.bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>很明显，这种打包完成后还需要手动修改的方式很智障，而如果我们不想做这样修改的话，只需要将 output.publicPath 设置为 <a href="https://mycdn.com/">https://mycdn.com/</a> ，便会在打包出来的 index.html 文件内自动加上 output.publicPath 设置的值。</p><p>还有一种情况，就是笔者所遇到的情况了。假设你的项目还是传统的开发方式，并没有采用前后端分离，用的还是后端模板的方式。而你作为一个前端开发，你想要模块化开发所以引入了 webpack 来打包，后端的哥们跟你说，你把你打包出的文件放在咱们项目的 static 文件夹下面就行了。一开始都没什么问题，但是在做某一个功能的时候，你发现打包出来的文件体积有点大，而且有些代码可以通过按需加载的方式拆分一下，这时候你想到了用 <code>import()</code> 来动态加载，于是除了打包出了 <code>index.js</code> ，还有一些需要动态加载的 .js 文件，你把它们都放进了 static 下面。但是在调试的时候却发现，那些需要按需加载的资源无法加载了，全都是 404 ，咦？怎么回事小老弟！打开控制台看一下，所有 404 的资源地址都是 <code>https://test.com/assets/xxx.js</code> 。干！说好的 <code>static</code> 怎么变成了 <code>/assets/</code> 了？后端的哥们跟你说，这是后端框架的原因，虽然你是放在 static 下面，但是请求的时候请求的是 <strong>相对于当前页面的 <code>/assets/</code> 这个路径</strong> ，总之 <strong>后端没法改，需要前端想办法解决</strong>。这个时候，我们只要把 output.publicPath 设置为 <code>/assets/</code> 就可以解决这个问题了。</p><p><span id="public-path-summary"></span><br>总结：</p><p>这个选项默认是 <code>&#39;&#39;</code> ，一般情况是不需要修改的。但是在有些情况下，打包出的资源部署上线后，可能会出现 <code>404</code> 访问不到的情况。这个时候就需要配置一下这个选项来解决这个问题了。</p><p>如果你将打包后的资源上传到 cdn 上面，那么需要将它设置为可以通过 cdn 方式访问的地址，比如 <code>publicPath: &#39;https://mycdn.com/assets/&#39;</code> ；</p><p>如果你的项目在服务器上面目录结构和你打包出的文件结构不一样，比如你打包出来的 .html 和 .js 是平级的，但是在服务器上却把 .js 文件都放在 &#x2F;assets 下面，那你需要设置为 <code>publicPath: /assets/&#39;</code> 。</p><p>所以这个值<strong>并不会影响你打包出的文件路径，它只是用来设置在线上运行的时候，所请求的资源相对于 服务 &#x2F;html页面 的路径</strong>。</p><p>简单的说，在线上运行的时候，所请求的资源具体路径是 <code>https://你的域名/publicPath/资源</code> 或者 <code>https://你设置的cdn地址/资源</code> 。</p><p>output 的常用配置项就这三个，如果你想用 webpack 把你的代码打包成类库，你还需要配置一下 <code>output.library</code> 、 <code>output.libraryTarget</code> 等，不过笔者建议直接使用 <a href="https://rollupjs.org/">rollup</a> 打包类库。</p><p>所以如果有下面这样一份 webpack 配置文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会打包出如下这些文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">├── src // 源代码文件夹</span><br><span class="line">│   ├── main.js</span><br><span class="line">│   ├── login.js</span><br><span class="line">│   └── logout.js</span><br><span class="line">├── dist // 打包后生成的文件夹</span><br><span class="line">│   └── app.bundle.js</span><br><span class="line">└── webpack.config.js // webpack 位置文件</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>个人认为 loader 是 webpack 中最厉害的一个功能了，它让我们可以在项目随意 <code>import</code> 各种类型的文件，css scss html img 等等都不在话下，如果有相关的 loader 支持，甚至可以 <code>import</code> 其它语言的代码。</p><p>简单的说 loader 就是一个处理器，在 webpack 中配置好相应的 loader 之后，就可以在代码中像加载 JavaScript 模块一样使用 <code>import</code> 把其它类型的代码当做 JavaScript 模块加载。</p><h3 id="loader-的用法有三种"><a href="#loader-的用法有三种" class="headerlink" title="loader 的用法有三种"></a>loader 的用法有三种</h3><ol><li>在 <code>webpack.config.js</code> 中配置，这种方式是最常用的，下面会着重介绍。</li><li>在代码中显示的指定 loader ，下面的代码表示从 styles.css 加载样式文件，用 <code>style-loader</code> 和 <code>css-loader</code> 来处理 css 文件。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>在命令行中为某些类型文件执行 loader 。下面的命令表示在打包过程中，对 <code>.css</code> 文件使用 <code>style-loader</code> 和 <code>css-loader</code> 来处理。</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack --module-bind <span class="string">&#x27;css=style-loader!css-loader&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="loader-的配置"><a href="#loader-的配置" class="headerlink" title="loader 的配置"></a>loader 的配置</h3><p>loader 的配置其实比较简单，只是提供了太多简写，让新手有点摸不着头脑，首先用  JavaScript、TypeScript、css、scss来展示常用的几种配置方式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123; <span class="attr">presets</span>: [<span class="string">&#x27;env&#x27;</span>] &#125;,</span><br><span class="line">      <span class="attr">include</span>: __dirname + <span class="string">&#x27;/src&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>, <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123; <span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123; <span class="attr">modules</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">loader</span>: <span class="string">&#x27;sass-loader&#x27;</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以发现，<code>use</code> 这个选项的配置是最没节操了，它可以是字符串、数组、甚至被 <code>loader</code> 这个选项代替，其实这都是简写。<code>rules.loader</code> 和 <code>loader.options</code> 是 <code>rules.use: [ &#123;loader, options&#125; ]</code> 的简写。这些配置项的含义分别是：</p><ul><li><code>test</code>: 正则表达式，用来匹配文件的扩展名。</li><li><code>use</code>: 对匹配出的文件使用的 loader 配置，如上面所说，该选项配置灵活，可以简写</li><li><code>loader</code>: loader 名称</li><li><code>options</code>: loader 的额外配置选项</li><li><code>include / exclude</code>: 包括 或 排除 的文件夹，两个选项只能同时出现一个，上面的例子中 <code>include: __dirname + &#39;/src&#39;</code> 表示 <code>babel-loader</code> 只编译 <code>/src</code> 文件下的文件，其它的不做处理；相反的，<code>exclude: __dirname + &#39;/src&#39;</code> 表示不编译 <code>/src</code> 下的文件。</li></ul><p>下面就来详细的介绍一下常用的 loader 和其配置。</p><p>（题外话，本来是先将 babel-loader 放到第一个介绍的，但是由于篇幅较长，且有些难懂，所以将其放到了后面）</p><h3 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i style-loader css-loader less less-loader node-sass sass-loader postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure><p>对于样式文件的处理，我们（我）通常会用到以下这些 loader ：</p><ul><li>style-loader</li><li>css-loader</li><li>postcss-loader</li><li>less-loader</li><li>sass-loader</li></ul><p>那么这些 loader 的使用场景和区别是什么呢？</p><ol><li><p>首先介绍 less-loader 和 sass-loader 。less 和 sass 都是 css预处理器，可以让 css 编写起来更爽，但是不能直接在浏览器中运行，所以需要先将 <code>.less</code> 或 <code>.scss</code> 文件先转换成 css 。这就是 less-loader 和 sass-loader 的作用。</p></li><li><p>无论是直接编写的 css ，还是由 less 或 sass 转换而来的 css 都不是 JavaScript 模块，这时候就要用到 css-loader ，它的作用就是把 css 转成 JavaScript 模块插入到代码中。</p></li><li><p>样式文件已经转换好了，但并不会产生任何效果。因为这些样式还没有添加到页面中，这时候就该轮到 style-loader 出场了，它的作用就是把转换后的样式添加到页面中，就像下面这样。</p></li></ol><p><img src="/2018/07/23/style-loader.png" alt="style-loader将样式插入到页面中"></p><ol start="4"><li>最后还有 postcss-loader 它的作用也很强大，最常用的功能就是帮助我们自动为一些样式属性名添加私有前戳（-moz、-ms、-webkit）。写过 vue 的同学都知道，当我们给 style 标签添加 scope 属性的时候，打包后的类名会自动添加自定义属性（<code>例如 .panel[_v-72f4cef2]</code>），这个功能就是基于 postcss-loader 实现的。</li></ol><p>  postcss 需要一份配置文件，这份配置文件以写在单独的文件中 (<code>postcss.config.js</code>)，也可以写在 <code>package.json</code> 的 <code>postcss</code> 属性中：</p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;postcss&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;autoprefixer&quot;</span>:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   对 postcss 感兴趣的同学可以看看这篇文章: <a href="https://segmentfault.com/a/1190000014782560">PostCSS真的太好用了！</a></p><p>这些 loader 的执行顺序是 ：</p><p><code>sass-loader</code> or <code>less-loader</code> → <code>postcss-loader</code> → <code>css-loader</code> → <code>style-loader</code></p><p>通过对这些 loader 的配置，我们就可以把样式文件当做 js 文件一样引入了。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// styles<span class="selector-class">.css</span></span><br><span class="line"><span class="selector-class">.red</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里需要在额外提一下 css module ，这也是一个很好的特性，写 react 的朋友对它应该很熟悉：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./styles.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="title function_">default</span> () =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&#123;styles.red&#125;</span>&gt;</span>css module<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看出，我们将样式当做 对象 <code>styles</code> 导入 jsx 中，那么该样式下的所有类名就是 <code>styles</code> 的属性名了。</p><p>这样的写法也同样适用于 ES6 的模板字符串：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./styles.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> html = <span class="string">`&lt;h2 class=&quot;<span class="subst">$&#123;styles.title&#125;</span>&quot;&gt;css module&lt;/h2&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = html;</span><br></pre></td></tr></table></figure><p>只要在 css-loader 的 options 中设置 <code>&#123; modules: true &#125;</code> 既可以开启此功能。</p><p>上面的这些配置，可以帮我们将 css 封装成 js对象 ，打包在 .js 文件中，然后运行的时候，以 <code>&lt;style&gt;&lt;/style&gt;</code> 的方式动态插入到页面中，但我们更希望可以将这些样式从 js 文件中抽取出来放到 css 文件，一来这样显得更优雅一些，二来可以减少 js 为文件体积，避免动态创建 style 标签所带来的性能损耗。这个功能需要在 plugins 中进行设置，下面也会讲到。</p><h3 id="file-loader、url-loader"><a href="#file-loader、url-loader" class="headerlink" title="file-loader、url-loader"></a>file-loader、url-loader</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i file-loader url-loader -D</span><br></pre></td></tr></table></figure><p>如果我们在页面中通过相对路径来引入图片、音频、视频、字体等文件资源时，在 webpack 环境中可能出现路径错误404的问题。主要原因是 <strong>开发时的目录结构</strong> 和 <strong>打包后的目录结构</strong> 一般都是不一样的，因此导致路径失效，而 file-loader 就是为了解决这个问题的。</p><ul><li><p>file-loader 可以解析页面中引入的资源的路径，然后根据配置，将这些资源拷贝到打包后的目录中。</p></li><li><p>url-loader 则是对 file-loader 进行了一次封装，如果解析的资源是图片，则可以将改图片转成 base64 从而减少 http 请求一提升性能，同时也可以设置 limit。 只对指定大小的图片进行转换。</p></li></ul><p>同样的也可以在 js 中引入资源</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">&#x27;./images/logo.png&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img));</span><br><span class="line">img.<span class="property">src</span> = logo;</span><br></pre></td></tr></table></figure><p>下面是 url-loader 的简单配置参考：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [&#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">limit</span>: <span class="number">10000</span>, <span class="comment">// 10KB 转换为base64</span></span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;images/[name].[ext]&#x27;</span> <span class="comment">// 拷贝到 images 目录下</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i html-loader -D</span><br></pre></td></tr></table></figure><p>在 Web 开发中，通常会用到很多 html 模板，传统的方式是将模板存在服务端，前端通过 http 请求加载模板，或者在 JavaScript 中拼接字符串，或者在页面中将模板内容写在 <code>&lt;script type=&quot;text/template&quot;&gt;&lt;/script&gt;</code> 内。</p><p>而在 webpack 环境下，我们也可以把 html模板 当做 JavaScript 的模块来加载，以 Vue 为例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> tpl <span class="keyword">from</span> <span class="string">&#x27;./template.html&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: tpl,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Hello Webpack&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面代码中，我们将 <code>template.html</code> 的内容以字符串方式导出，这正是 html-loader 的功能，也可以在配置只启用压缩功能。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [&#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">minimize</span>: <span class="literal">true</span> <span class="comment">// 开启压缩</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="babel-loader-重点"><a href="#babel-loader-重点" class="headerlink" title="babel-loader(重点)"></a>babel-loader(重点)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @babel/core babel-loader @babel/preset-env @babel/runtime @babel/plugin-transform-runtime -D</span><br></pre></td></tr></table></figure><blockquote><p>Babel is a compiler for writing next generation JavaScript.</p></blockquote><p>从官方的简短介绍中可以知道， babel 属于编译器，输入 JavaScript 源码，输出 JavaScript 源码（source to source），其作用就是将目前部分浏览器目前还不支持的 ES2015+ 语法转换为 ES5 语法。</p><p>babel-loader 则是让 babel 可以在 webpack 中使用的工具，同理如果你使用的是 gulp ，则需要用到 gulp-babel 这个包。</p><p>实际上，如果只是用 babel 的话，输入的代码和编译后输出的代码是相同的（被 webpack 混淆打包的代码与 babel 无关）。<strong>因为 babel 的转换工作全都是由 babel 的插件来完成的</strong>。</p><p>关于 babel 的介绍和使用，仅仅一个小节的篇幅是完全不够，所以这里贴一个链接，有兴趣的读者一点要点进去看一下 <a href="https://zhuanlan.zhihu.com/p/43249121">一口（很长的）气了解 babel</a>。</p><p>babel 也是需要进行配置的，一般有两种方式：</p><ol><li>在根目录创建 <code>.babelrc</code> </li><li>在 <code>package.json</code> 的 <code>babel</code> 属性中进行配置</li></ol><p>我更倾向于在 <code>package.json</code> 进行配置，因为根目录放置太多文件，强迫症实在无法接受。无论是在 <code>.babelrc</code> 还是 <code>package.json</code> 中配置，配置的内容都是一样的，下面以在 <code>package.json</code> 中配置为例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;babel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;modules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;targets&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;browsers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="string">&quot;&gt; 1%&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;last 2 versions&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;not ie &lt;= 8&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;@babel/plugin-syntax-dynamic-import&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在该配置中，<code>presets</code> 和 <code>plugins</code> 对应的值都是数组，同时数组的每一项可以是 <code>string</code> （只指定名字），也可以是 <code>array</code> （指定名字，并进行更具体的配置）</p><p><code>plugins</code> 表示用到的插件，比如我们在代码中使用到了 <code>import()</code> 动态加载模块这个语法，那么就要在 <code>plugins</code> 添加 <code>@babel/plugin-syntax-dynamic-import</code> 这个插件了；我们需要对 babel 编译后的代码进行去重，就需要用到 <code>@babel/plugin-transform-runtime</code> 。 当然，这两个插件也是需要单独安装的 <code>npm i @babel/runtime @babel/plugin-transform-runtime @babel/plugin-syntax-dynamic-import -D</code> 。</p><p><code>presets</code> 一组 <code>plugins</code> 的集合。比如我们可以把 @babel&#x2F;plugin-transform-runtime 和 @babel&#x2F;plugin-syntax-dynamic-import 打包到一起，叫 preset-my ，这样我们只需要在 presets 中添加 preset-my 就可以了，省去了对 plugins 的配置 。上面的配置文件只配置一个 <code>@babel/preset-env</code> ，这是最常用的配置，<code>@babel/preset-env</code> 后面的对象是对 <code>@babel/preset-env</code> 具体配置。我们注意到，其中有一个 <code>targets.browsers</code> 属性，指定了浏览器版本，这个属性也可以放在 <code>package.json</code> 的 <code>browserslist</code> 中。</p><p>为什么配置了 presets 还需要配置 plugins 呢？很简单，如上面所说， presets 是一组 plugins 的集合，也就说 babel 对不同阶段的语法做了整合，方便我们使用。但是在上面的配置中，我们只使用了 <code>@babel/preset-env</code> 这个集合里的插件，而 <code>import()</code> 处于 <code>stage-3</code> 阶段（记不太清了，也可能是 <code>stage-2</code>），不包含于 <code>@babel/preset-env</code> ，所以就需要在 plugins 单独添加 <code>@babel/plugin-syntax-dynamic-import</code> 插件来对 <code>import()</code> 语法进行转换了。</p><p>社区中也提供了一些 presets ，比如 react 的 <a href="https://babeljs.io/docs/en/babel-preset-react/">@babel&#x2F;preset-react</a> ， vue 的 <a href="https://www.npmjs.com/package/@vue/babel-preset-app">@vue&#x2F;babel-preset-app</a></p><p>babel 的执行顺序是：</p><p><code>读取plugins数组</code> → <code>按正序执行plugins内插件</code> → <code>读取presets数组</code> → <code>按倒序执行presets内容</code></p><p>简单的介绍了 babel 后，开始配置 babel-loader ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="comment">// options: &#123; presets: [&#x27;env&#x27;] &#125;, 该项的配置和上面babel的配置完全相同，已经在package.json配置过，这里不需要再配置</span></span><br><span class="line">      <span class="attr">include</span>: __dirname + <span class="string">&#x27;/src&#x27;</span> <span class="comment">// 只对 ./src 目录下的代码进行编译</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ts-loader"><a href="#ts-loader" class="headerlink" title="ts-loader"></a>ts-loader</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i typescript ts-loader -D</span><br></pre></td></tr></table></figure><p>如果你的项目是用 <code>typescript</code> 开发的，这时候就要样到 ts-loader 了。</p><p>ts-loader 的配置比较简单，但是有许多需要注意的细节，详情可以参照这里：<a href="https://github.com/TypeStrong/ts-loader/blob/master/README.md#configuration">https://github.com/TypeStrong/ts-loader/blob/master/README.md#configuration</a></p><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>讲完了 entry、output 和 loader，下面开始讲讲 plugins 。细心的读者应该已经发现，还没有提到代码的压缩，而且按照上面的方式打包会把 <code>.css</code> 和 <code>.js</code> 文件打包在一起，并且打包后的文件体积很大，可能还会存在冗余的代码等等一些问题，plugins 就是为了解决这类问题而产生的。</p><p>这里不要把 <code>loader</code> 和 <code>plugins</code> 搞混了，<strong>laoder 只是把特定的文件类型转换成 JavaScript 模块</strong>，<strong>plugins 是在打包过程中对所有模块进行特定的操作</strong> 。<code>plugins</code> 的值是一个数组，所有的 webpack 都需要手动通过关键字 <code>new</code> 来实例化。 下面就介绍一些常见的插件。</p><p><span id="html-webpack-plugin"></span></p><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>webpack 是对 JavaScript 进行打包的，打包出的只能是 <code>.js</code> 文件。 而 JavaScript 要想在浏览器中运行，那就必须在 html 中通过 script 的方式引入。在没有其他工具帮助的情况下，我们只能手动创建 html 文件，然后再把打包后的 <code>.js</code> 文件和 <code>.css</code> 文件写到这个文件中，这样做很麻烦。这时候可以用 <code>html-webpack-plugin</code> 这个插件来自动完成上面的工作。</p><p><code>html-webpack-plugin</code> 提供了一些配置项，如果不行配置，它会自动帮我创建一个空的 html 文件，然后将打包后的资源插入到这个页面内：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>() <span class="comment">// 创建 /dist/index.html 文件，并将 index_bundle.js 插入到这个页面中。</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，我们也可以为其指定一个模板页：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>, <span class="comment">// 生成的文件名称，默认为 index.html</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;src/index.html&#x27;</span>, <span class="comment">// 以 src/index.html 为模板文件</span></span><br><span class="line">      <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>, <span class="comment">// 将打包后的文件注入到 body 区域内</span></span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Hello webpack&#x27;</span>, <span class="comment">// 生成文件的标题</span></span><br><span class="line">      <span class="attr">minify</span>: &#123;       <span class="comment">// 对生成的文件进行压缩，可以设置为 true ，也可以是对向，进行更具体的配置</span></span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,   <span class="comment">// 删除空格</span></span><br><span class="line">        <span class="attr">minifyCSS</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minifyJS</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">removeAttributeQuotes</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">removeTagWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件也可以通过多次实例化来重复使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;src/index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">chunks</span>: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;vendor&#x27;</span>] <span class="comment">// 只注入 index.bundle.js 和 vendor.bundle.js </span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;about.html&#x27;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;src/about.html&#x27;</span>,</span><br><span class="line">      <span class="attr">excludeChunks</span>: [<span class="string">&#x27;index&#x27;</span>] <span class="comment">// 将 index.bundle.js 排除，其余的都注入</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分离css和js"><a href="#分离css和js" class="headerlink" title="分离css和js"></a>分离css和js</h3><ul><li>webpack v4<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure></li></ul><p>前面在介绍用 loader 处理样式的时候说到，这些样式最终会被混入到打包后的 <code>.js</code> 文件中，在页面运行的时候，在以 <code>&lt;style&gt;&lt;/style&gt;</code> 的方式动态的插入到 DOM 节点中，这种做法有两个很明显的缺点：</p><ol><li>js 和 css 糅杂在一起，增加了单个文件的体积。</li><li>在页面运行时动态的去创建 style 标签，多多少少会有些性能影响</li></ol><p>如果能把这些 css 从打包后的 js 中抽取出来，就可以解决上面的两个问题，这时候就要用到 <code>mini-css-extract-plugin</code> 这个插件了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash].css&#x27;</span>,</span><br><span class="line">      <span class="attr">chunkFilename</span>: <span class="string">&#x27;[id].[contenthash].css&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的配置中可以看出，<code>mini-css-extract-plugin</code> 并不是单独作为一个 <code>plugin</code> 来使用的，它还充当了 loader 的作用，代替了 style-loader 。前面在介绍 style-loader 的时候提到，它的作用是将转换后的样式插入到页面中，既然我们现在需要将 css 和 js 分离开，所以也就不需要再用到 style-loader 了。</p><p>当作为插件使用的时候， mini-css-extract-plugin 可以接受两个可选参数：</p><ul><li>filename ：分离出的css文件名称，写法和 output 的 filename 选项相同，唯一区别是当你想使用缓存的时候，填写的是 contenthash 而不是 chunkhash</li><li>chunkFilename ：切割出的css文件块名称，写法和 filename 相同</li></ul><p>最近发现 extract-text-webpack-plugin 也支持 webpack4 用法了 mini-css-extract-plugin 完全相同，而且相较于 mini-css-extract-plugin 还多了一些可选的配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i extract-text-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ExtractCssChunksPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;extract-css-chunks-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="title class_">ExtractCssChunksPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;style-loader&#x27;</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ExtractCssChunksPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash].css&#x27;</span>,</span><br><span class="line">      <span class="attr">chunkFilename</span>: <span class="string">&#x27;[id].[contenthash].css&#x27;</span>,</span><br><span class="line">      <span class="attr">hot</span>: <span class="literal">true</span>, <span class="comment">//HMR 下面会着重介绍</span></span><br><span class="line">      <span class="attr">orderWarning</span>: <span class="literal">true</span>, <span class="comment">// Disable to remove warnings about conflicting order between imports</span></span><br><span class="line">      <span class="attr">reloadAll</span>: <span class="literal">true</span>, <span class="comment">//当启用HMR时，强制重新加载所有css</span></span><br><span class="line">      <span class="attr">cssModules</span>: <span class="literal">true</span> <span class="comment">//如果启用了 cssModules 此选项设置为 true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>在将 css 从 js 中分离出来不之前，我们是不需要考虑压缩 css 的，因为样式都被打包进了 js 文件中，当我们设置 mode 为 production 时，webpack 会自动压缩 js 文件。但是我们现在将 css 从 js 中分离出来了，webpack 目前还不能自动压缩 css 文件。干！真是麻烦！这时候又要用到插件来帮我压缩分离出来的 css 文件了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizeCssAssetsPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">OptimizeCssAssetsPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里讲一个坑，在 webpack4 之前，压缩都是通过 webpack.optimize.UglifyJsPlugin 这个插件来完成。webpack4 新增了 mode 和 optimization 两个选项，当 mode 设置为 production 时会自动压缩 js 文件(这个已经提过多次了)，其实将 mode 设置为 production 时， optimization.minimize 便会默认设置为 true ，意思就是在打包的时候对 js 进行压缩。而如果你想用第三方压缩插件，你可以将插件写在 plugins 中，也可以写在 optimization.minimizer 中。但是如你将压缩插件写在 optimization.minimizer 中时，webpack 就会默认读取 ptimizatio.minimizer 这个选项了，这也就意味着，这时候如果你不手动的配置 js 压缩插件，js 文件是不会被压缩，这时候又需要寻找压缩 js 的插件，比如 <a href="https://www.npmjs.com/package/uglifyjs-webpack-plugin">uglifyjs-webpack-plugin</a> ，然后再配置一下，说实话这样真的很烦，所以我直接将压缩的插件配置在了 plugins 中，这样就省去了对 js 压缩插件的配置。webpack 的文档中描述了相关说明 <a href="https://webpack.js.org/plugins/mini-css-extract-plugin/#minimizing-for-production">Minimizing For Production</a></p><p><span id="copy-webpack-plugin"></span></p><h3 id="复制静态资源"><a href="#复制静态资源" class="headerlink" title="复制静态资源"></a>复制静态资源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i copy-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>有时候我们的项目中会有一些静态资源，比如网站的favicon、你从不知道的地方找来的不知名的js插件等等，这些静态资源并不会在项目中通过 <code>import</code> 的方式显式的加载进来，而是在直接写在页面中</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;static/favicon.ico&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/xxx.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这些静态资源，webpack 在打包过程中不会对它们进行处理，所有需要我们 copy 到打包后的目录中，从而保证项目不会因为缺少这些静态文件而报错， copy-webpack-plugin 的作用便是 copy 这些静态资源到指定的目录中的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CopyWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CopyWebpackPlugin</span>([</span><br><span class="line">      &#123; <span class="attr">from</span>:<span class="string">&#x27;static/**&#x27;</span>,<span class="attr">to</span>: <span class="string">&#x27;dist/static&#x27;</span> &#125;</span><br><span class="line">    ])</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置表示将 static 文件夹下所有的文件都复制到 dist&#x2F;static 下面，如果你熟悉 gulp 的话，你会发现这其实就是一个移除了 pipe 的 gulp。</p><p>其实对于copy文件这种脏活累活你也可以用你熟悉的方式来完成，比如 gulp、<a href="https://www.npmjs.com/package/fs-extra">fs-extra</a> 等。</p><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>如果我们打包输出的文件使用了 chunkhash 、 hash 等来命名的话，随着文件的变更和打包次数的增加，dist 目录会淤积很多无用的打包文件，这时候便可以借助 clean-webpack-plugin 帮我们清除一些这些无用的文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CleanWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 copy 文件一样，删除文件这种话不一定非得让 webpack 来做，我们也可以借助其他的方式来完成，比如我要再提一遍的的 gulp ，又或者 <a href="https://www.npmjs.com/package/rimraf">rimraf</a> 、 <a href="https://www.npmjs.com/package/del">del</a> 等。但是区别是你需要手动的控制一下任务的流程，总不能在打包完成才删除问吧，所以用 webpack 提供的插件是不需要考虑任务流程的问题。</p><p>上面介绍了5个 webpack 的 plugin ，主要目的是让大家体会 webpack plugin 的作用基本用法。 实际上 webpack 的 plugin 还有很多很多，几乎可以满足你在项目构建中的各种需求，webpack 官网了列举很多官方推荐的 plugin <a href="https://webpack.js.org/plugins/">https://webpack.js.org/plugins/</a> ，有兴趣的同学可以前往查看。</p><h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h2><p>tree-shaking 这个技术在 webpack2 就已经被添加进来了，作用是在打包过程中，将模块内没有使用的代码删除，从而减小打包后的文件体积。</p><p>这个单词表面的意思是，有一棵小树，你去抖动这棵树，那么树上多余没用的树叶就会掉落，那在代码中具体是什么样子呢。假设我们现在将一些常用的方法都封装在了 util.js 这个文件中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util.js </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, currrent, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + currrent;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, currrent, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev * currrent;</span><br><span class="line">  &#125;, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  add,</span><br><span class="line">  multiply</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在 index.js 中需要用到 add 这方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./util.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>这样打包后的代码是不含有 multiply 这个函数的，这就是 tree-shaking 的作用。</p><h2 id="splitChunk"><a href="#splitChunk" class="headerlink" title="splitChunk"></a>splitChunk</h2><p>现在我们再回顾一下 webpack 打包过程</p><ol><li>以 entry 为起点，将所依赖的模块组织成一个树形的结构</li><li>通过不同的 loader 对不同的文件进行编译</li><li>使用 plugins 对文件打包后的文件进行特定的操作</li><li>根据 output 将打包后的文件输出到指定的位置</li></ol><p>如果只有一个入口文件，最终也只会打包出一个文件(下文用 <code>chunk</code> 表示，每打包出的一个文件就叫一个 chunk)（排除动态加载的情况(<code>import()</code>)）。这里有一个很明显的缺陷，就是将所有的模块打包成一个文件，打包后的体积一定会很大。同时，如果我们使用了 chunkhash 做文件缓存的话，每次项目修改的时候，无论修改哪个文件，即使是修改了一个换行，chunkhash 的值都会发生改变，那么每次改动上线之后，用户都要重新加载这个巨大的文件，这样用户体验非常糟糕。如果你说我不做文件缓存，那么由于浏览器缓存的原因，用户首次加载的文件会被缓存到本地，下次即使你更新了代码，用户执行的还是首次加载的文件，这样老板会找你聊天的。</p><p>为了解决这个问题，我们可以考虑设置多个入口文件，就像在介绍 entry 的例子代码中那样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">login</span>: <span class="string">&#x27;src/login.js&#x27;</span>,</span><br><span class="line">    <span class="attr">logout</span>: <span class="string">&#x27;src/logout.js&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的配置，我们就可以将 login.js 和 logout.js 打包成两个文件，而且修改其中一个文件不会影响到另一个的 chunkhash。看起来好像已经解决了上面的问题，但是我们再结合实际的项目深入的分析一下，我们通常会在项目中引入一些类库，比如常见的 lodash ，假设 login.js 和 logout.js 中都用到了 lodash ，这就需要在这个两个文件中显式的 <code>import _ from &#39;lodash&#39;;</code> 这样一来，打包出来的两个文件都包含了 lodash ，这就属于重复引用了，另外如果我们的项目是单页应用，理应只有一个入口，在需要的时候再去加载 login.js 或 logout.js 的代码。</p><p>所以我们要解决我们一开始的问题，应该从下面两个点出发：</p><ol><li>分离代码中公共的部分，打包成一个或多个chunk</li><li>将不需要立刻执行的代码分离出来，打包成多个 chunk ，然后通过动态加载的加载这些chunk</li></ol><p>针对第一点，我们可以使用 webpack 提供的 SplitChunksPlugin 插件，这个插件和上面介绍的 minimize 一样，需要在 <code>optimization.splitChunks</code> 中配置。在 production 模式下 webpack 会默认做一下代码分离的工作，但是没多大的卵用，所以还是需要我们自己动手配置。</p><p>第一步先将来自 node_modules 中的包分离出来，因为这些都是项目所依赖的第三方库，我们是不会改动的（除非升级版本），这些可以做通过 <code>chunkhash</code> 做长期缓存，我们把这写代码打包为 <code>chunk-vendors</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span> <span class="comment">// 只取chunkhash的前8位</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="attr">vendors</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">`chunk-vendors`</span>,</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">          <span class="attr">chunks</span>: <span class="string">&#x27;initial&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的配置中，我们用 <code>cacheGroups</code> 将 node_modules 的代码全部分离出来。 cacheGroups 直译成中文就是缓存组，其实就是存放分离代码块规则的对象，第一个对象的 key 值是 vendors ，这个 key 值没什么用，主要还是看对应的 val 。</p><ul><li>name：分离后打包出的文件名称。我们设置为 chunk-vendors ，那么打包出来的文件就叫 chunk-vendors.js 。因为在 output.filename 设置了 chunkhash:8，所以最终打包出的文件名称是 chunk-vendors.ac96737b.js 。后面的一串字符就是 chunkhash 的前8位。前面介绍过 chunkhash 是每一个打包出来的文件的 hash ，只要文件的内容没有改变，这个值就不会发生变化，所以只要不对我们依赖的包进行版本升级，或者增加新的包，这个值就不会变动，因此可以用这个办法进行长期缓存。</li><li>test：用于匹配的文件位置，<code>test: /[\\/]node_modules[\\/]/</code>  表示所有来自 node_modules 下面的代码，可以填写具体的路径</li><li>priority：权重，这个值还是很重要的，webpack 会优先分离权重高的 cacheGroups 。</li><li>chunks：作用范围，可以设置为 async 表示对异步模块起作用， initial 表示对初始模块起作用， all 则表示对所有模块起作用。</li></ul><p>如果打包出的 chunk-vendors 体积很大，而且包含一些经常升级的依赖，那么我们可以继续做拆分</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="attr">vendors</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">`chunk-vendors`</span>,</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">          <span class="attr">chunks</span>: <span class="string">&#x27;initial&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">vue</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;chuank-vue&#x27;</span>,</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]vue[\\/]/</span>,</span><br><span class="line">          <span class="attr">priority</span>: <span class="number">10</span>,</span><br><span class="line">          <span class="attr">chunks</span>: <span class="string">&#x27;initial&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我就将 vue 分离成单独一个 chunk 了，不仅减小了 chunk-vendors 的体积 ，当我们升级 vue 版本的时候，也不会影响 chunk-vendors 的 chunkhash 。<strong>注意：不要忘了设置 priority 。</strong></p><p>除了将 node_modules 中的类库分离出来，我们自己写的代码中也有些公共的部分，比如在讲 tree-shaking 提到了 util.js ，作为一个工具方法，跟定会在项目中好多处用到，那么我们也可以将会这个公共代码分离出来：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="attr">common</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">`chunk-common`</span>,</span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">          <span class="attr">chunks</span>: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的配置中，我们把被依赖超过两次（<code>minChunks: 2</code>）的 chunk 都分离到了 chunk-common.f4786e34.js 中。</p><p>在解决了对公共代码的分离，下一步即使处理动态加载的代码，之一部分相对简单一些，就像在介绍 babel 时提到的那样，通过 <code>import()</code> 来切分动态加载的代码。</p><p>webpack 在将我们的代码打包后，也会生成一些在运行时所必须的代码，这些代码默认会打包进主文件中，我们也可以将它分离出来单独打包成一个文件，这需要在 <code>optimization.runtimeChunk</code> 中单独配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">runtimeChunk</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;manifest&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以将运行时的代码也分里出来，打包为 manifest.js。</p><p>其实代码拆分是需要反复尝试的，一般情况下我们只会将 node_modules 里的包分离成一份（<code>chunk-vendors.js</code>）， 业务中公共的代码分离成一分（<code>chunk-common.js</code>），剩下的都放在了主模块（main.js） 和动态加载的 chunk 中了。但是由于项目的不同，这种方式未必是最好的，所以这需要我们反复的去尝试一各种分离的方式，为了让我们对打包后的代码有更为直观的认识，我们可以借助 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a> 来帮我们很直观的看到打包后每一个 chunk 的大小。</p><p><img src="/2018/07/23/webpack-bundle-analyzer.gif" alt="webpack-bundle-analyzer"></p><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>在上面的介绍中，都是面向打包的，也就是说我们默认代码是无误可以直接打包上线运行，当然这是不可能滴，实际开中需要配合 Google 和 fuck 来 debug 代码，如果用上面的方法来 debug 我相信不管是谁，都会想砸电脑的，因为每次 debug 都要重新的打包，然后再想办法再本地启动一个web服务，用来托管我们打包出的静态文件。那么 webpack 可不可以帮我做到这两点呢:</p><ol><li>监听文件变化，自动重新编译</li><li>创建一个web服务，用来托管打包后的静态文件，方便本地调试</li></ol><p>为了解决上面两点，webpack 提供了 webpack-dev-server 这个包，它可以轻松的帮助我们实现上面两功能，这个包需要单独安装一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure><p>然后在 <a href="#npm-script">npm script</a> 中添加一行 ：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --mode development&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --mode production&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候在命令行中执行 <code>npm run dev</code> ，便会在本地启动一个Web服务,当命令行中出现 <code>Compiled successfully</code> 便表示服务启动成功，然后打开浏览器，输入 <code>localhost:8080</code> 便可以直接访问项目了。当源代码发生变化时，便会自动重新编译，然后刷新浏览器。</p><p>webpack-dev-server 同样也提供了一些配置选项，可以在配置文件的 <code>devServer</code> 中进行配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8080</span>, <span class="comment">// 设置端口为8080，默认就是8080</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 编译完成后自动打开浏览器</span></span><br><span class="line">    <span class="attr">historyApiFallback</span>: <span class="literal">true</span>, <span class="comment">// 如果你的项目使用了 HTML5 history API ，开启此项可以将所有的跳转将指向index.html</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些配置也可以以参数的形式添加在加命令行后面，但是有的配置只能以参数的形式使用，比如我们想查看编译的进度，就需要加上 <code> --progress</code> :</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --mode development --progress&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --mode production&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>学会了如何使用，在简单的介绍一下 webpack-dev-server 的工作原理，webpack-dev-server 是一个基于 express 封装的 Web 服务，当我们在执行 webpack-dev-server 时候，虽然可以看到打包之后的运行效果，但是实际上并没有生成打包后的文件，这是因为 webpack-dev-server 将打包后的内容放在了内存中，当某一个源代码文件发生变更的时候，它也不会重新的再将所有的文件打包一遍，而是只更新了一部分文件，这样的好处是可以加快重新编译的速度，加大程度的减少了开发模式下的编译时间。</p><p>讲到这里，你可能也意识到了，如果是开发模式下，有许多事情都不需要做。比如不需要设置 output ，不需要对代码压缩，不需要分离 css 和 js 等等，如果省去这些工作，首次编译的速度又会有大幅度的提升，这是一个优化点，会在后面讲到。</p><h3 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h3><blockquote><p>HMR (hot module replace) 模块热替换，在不刷新页面的情况下更新代码。</p></blockquote><p>在引入了 webpack-dev-server 之后，我们可以做到监听源代码变化，然后刷新浏览器及时看到修改效果。但是在前端开发中，每一步操作往往都伴随着状态和 dom 的变化，比如我们开发一个定外卖的网站，此时正在调试购物车功能，先加了一份煲仔饭，为了满减，再加一份荷包蛋，但是这时候后出现了bug，加了荷包蛋还是没有满减，原来是计算满减的方法写错了，修复这个bug之后，我们发现页面刷新了，回到最开始的样子，于是又要从选择店铺开始在走一遍流程。那可不可以在修复计算满减的方法之后，不要刷新页面也能看到正确的效果呢？这就是 HMR 实现的功能了。</p><p>开启 HMR 需要将 devServer.hot 设置为 true ，然后在 plugins 中添加 HotModuleReplacementPlugin 插件，该插件是 webpack 自带的一个插件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">/* 其他配置 */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种更简便的方法来开启 HRM ，那就是在命令行中添加参数 <code> --hot</code> ，然后在执行 <code>npm run dev</code> 的时候也会自动添加 HotModuleReplacementPlugin 插件。</p><p>现在我们在 webpack 中开启了 HMR 功能，webpack 可以将老模块替换为编译后的新模块，但是从浏览器层面考虑，浏览拿到新模块之后，并不知道要做什么处理，就像我们前面举的例子中提到，在修改计算满减方法之后，我们希望重新执行一遍这个方法，很明显这个需求不太现实，浏览名没那么聪明。所有这就需要我们显式的用代码来告诉浏览器来做哪些事情。</p><p>我们可以在项目代码中通过 <code>module.hot</code> 来判断是否启用了 HMR ，通过 <code>module.hot.accept</code> 来处理模块更新后的要做的事情，现在假设我们的项目入口文件是 index.js ，还有一个 util.js 里面封装了 add 方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">├── src </span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── util.js</span><br><span class="line">│   └── index.html</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, currrent, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + currrent;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; add &#125;</span><br></pre></td></tr></table></figure><p>然后我们在 index.js 中导入 add 方法，并且将计算结果显示在页面上：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./util.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h2&#x27;</span>);</span><br><span class="line">h2.<span class="property">innerHTML</span> = <span class="title function_">add</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(h2);</span><br></pre></td></tr></table></figure><p>将项目跑起来之后，发现 add 方法计算的结果错了，经排查发现原来 add 方法忽略了对 string 类型的转换，只要修改一下 util.js 中的 add 函数就好了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, currrent, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + currrent * <span class="number">1</span>;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; add &#125;</span><br></pre></td></tr></table></figure><p>这时候可以发现，页面中虽然显示了正确的结果，但是页面刷新了，而我们希望的是在页面不刷新的情况下显示正确结果，这时候就要在 index.js 添加热更新后需要执行的代码了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./util.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h2&#x27;</span>);</span><br><span class="line">h2.<span class="property">innerHTML</span> = <span class="title function_">add</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(h2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./util.js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    h2.<span class="property">innerHTML</span> = <span class="title function_">add</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样再去修改 add 方法的时候，h2 显示的内容会发生变化，但是页面却不会刷新，这才是我们想要的热更新。</p><p>讲到这里你可能已经发现，实现一个完美的热更新，难点不是在 webpack 的配置，而是在我们的项目代码中，我们要针对所有需要热更新的模块加上热更新之后的回调( <code>module.hot.accept</code> )，不过社区中已经提供了一些 loader 使 HMR 与各种框架平滑地进行交互 <a href="https://webpack.js.org/guides/hot-module-replacement/#other-code-and-frameworks">https://webpack.js.org/guides/hot-module-replacement/#other-code-and-frameworks</a> ，</p><p>如果需要样式热更新的话，我们需要判断当前的环境变量是否为 development ，然后将 MiniCssExtractPlugin.loader 换成 style-loader ，因为 MiniCssExtractPlugin 还不支持 HMR ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> styleLoader = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span> ? <span class="string">&#x27;style-loader&#x27;</span> : <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [styleLoader, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="content-base"><a href="#content-base" class="headerlink" title="content-base"></a>content-base</h3><p>在 plugins 这一章节中，提到了 <a href="#copy-webpack-plugin">copy-webpack-plugin</a> 这个插件，它是用来将一些静态资源拷贝到打包后的目录，但是在开发环境下，我们是通过 webpack-dev-server 创建一个 Web 服务，它的根目录默认是配置文件所在的目录，所以在开发模式下，如果需要请求一些静态资源，那么我们就需要设置一下 <code>contentBase</code> 。</p><p>假设我们的静态资源放在了项目根目录下的 static 文件夹下面，而且配置文件 webpack.config.js 也放在了项目根目录下，那么我么就可以将 <code>devServer.contentBase</code> 设置为 <code>static</code> ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: <span class="string">&#x27;static&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 static 下面有一个图片 logo.png ，我们就可以通过 localhost:8080&#x2F;logo.png 来访问这张图片了。</p><p><span id="dev-public-path"></span></p><h3 id="public-path"><a href="#public-path" class="headerlink" title="public-path"></a>public-path</h3><p>在介绍 <a href="#public-path">output.publicPath</a> 的时候提到，这个值并不会影响打包后输出的文件路径，他只是设置在线上运行的时候，所请求的资源路径，当我们在 webpack-dev-server 这个 Web 服务下调试我们的代码的时候，可能也会出现和类型的情况，这时候就需要设置一下 devServer.publicPath 了。它 output.publicPath 的区别的是 一个作用于线上环境，一个作用于我们调试的开发环境。</p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>在开发过程，经常需要调用后端提供的接口，一般情况会把接口部署在测试环境，比如 <a href="http://test.api.com/">http://test.api.com</a> 然后我们在项目中通过 ajax 的方式去调用。由于同源策略，我们在开发的时候通过 webpack-dev-server 启动的 Web 服务的域是 localhost:8080 ，很明显跨域了，接口无法调用了。这个时候有两种办法解决，一是在测试上环境上配置 cors ，将我们的 localhost 加入允许跨域的名单；二是我们在本地利用 node 去请求这个接口，然后再将请求内容发送给前端，在整个过程中 node 扮演的角色就是一个可靠的跑腿子，你去把请求交给它，它把请求送给测试环境，测试环境把响应交给它，它再把响应送到你这边。</p><p><img src="/2018/07/23/proxy%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="proxy示意图"></p><p>在 webpack-dev-server 集成了中间件 (http-proxy-middleware)[<a href="https://github.com/chimurai/http-proxy-middleware]">https://github.com/chimurai/http-proxy-middleware]</a> 可以很轻松的完成接口转发，比如我们想将所有的以 &#x2F;api 开头的请求都转发到 <a href="http://test.api.com/">http://test.api.com</a> 只要在 <code>devServer.proxy</code> 像下面这样配置即可：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: <span class="string">&#x27;http://test.api.com&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>devServer.proxy</code> 暴露出的配置项和 (http-proxy-middleware)[<a href="https://github.com/chimurai/http-proxy-middleware]">https://github.com/chimurai/http-proxy-middleware]</a> 的配置项完全一样，具体可以点击链接查看。</p><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><p>后端已经写好的接口我们我们可以用转发的方式调用，而对于还没有写好的接口我们可以通过 mock 的方式来调用，这样可以解决因为接口调用通而导致我们开发不畅的问题。因为 webpacl-dev-server 是基于 express 封装了，并且将 express 的实例暴露在了 <code>devServer.before</code> 和 <code>devServer.after</code> 这两个配置项下面，所以我们完全可以将后端没有写好的接口在 devServer.before 通过 express 去 mock 。假设我们现在需要调用 <code>/api/user/creation</code> 这个接口来创建用户，我们可以这样 mock</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="title function_">befor</span>(<span class="params">app</span>) &#123;</span><br><span class="line">      app.<span class="title function_">post</span>(<span class="string">&#x27;/api/user/creation&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// some code</span></span><br><span class="line">        res.<span class="title function_">json</span>(&#123;<span class="attr">success</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你需要 mock 的接口后端，那你完全可以像写 express 那样去写接口，当然有些常用的中间件需要我们自己去安装。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="source-maps"><a href="#source-maps" class="headerlink" title="source-maps"></a>source-maps</h3><p>webpack 打包压缩之后的代码可读性几乎为零，同时也不方便调试，这时候可以通过设置 <code>devtool</code> 选项来帮助我们在开发环境调试，具体效果是：在 chrome 中(其它高级浏览器同样支持)打开控制台，我们可以在 <code>Sources</code> 中看到一个以 <code>webpack://</code> 开头的资源，里面的内容和我们编写代码大致相同(这取决于 <code>devtool</code> 的值)。</p><p><img src="/2018/07/23/devtool.png" alt="source maps"></p><p>由于 devtool 会影响打包的速度和打包后的代码质量，所以在生产环境的构建中，不建议开启此项(默认为<code>none</code>)，只要在开环境设置为 <code>eval-source-map</code> 即可。其它配置和打包速度可以参考 <a href="https://webpack.js.org/configuration/devtool/#devtool">官网</a> 。</p><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>当项目的目录结构越来越深，模块变得越来越多的时候，模块间的引用会变得很混乱，时常会看到下面这样的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ComponentA</span> <span class="keyword">from</span> <span class="string">&#x27;../../../../../components/a.component.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ServiceA</span> <span class="keyword">from</span> <span class="string">&#x27;../../../../../service/a.service.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>有没有想骂人的冲动？这时候可以使用 webpack 的 <code>alias</code> 选项来解决这个问题，配置文件的内容如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">      <span class="string">&#x27;components&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;src/components&quot;</span>),</span><br><span class="line">      <span class="string">&#x27;services&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;src/services&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置表示为 <code>src</code>、<code>src/components</code>、<code>src/services</code> 分别设置一个别名，我们就可以在代码中用 <code>@</code> 表示相对路径 <code>src</code> 而不必再使用 <code>../../</code> 一层一层的向上查找了。假设我们现在的项目结构是下面这样子:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">├── src</span><br><span class="line">│   ├── components</span><br><span class="line">│   └── services</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><p>这样我们可以在任意文件夹下的代码内使用 <code>@</code> 来表示根目录 <code>src/</code>，使用 <code>components</code> 来表示路径 <code>src/components/</code> ，所以上面例子中的代码可以在简化为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ComponentA</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/a.component.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ServiceA</span> <span class="keyword">from</span> <span class="string">&#x27;services/a.service.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样配置之后，webpack 在打包编译的时候能识别简化之后的路径，但是编辑器却未必能识别，这又给我们开发带来了一些困扰，如果你是 <code>vscode</code> 用户的话，这个问题可以很好的解决。只要在项目的根目录添加一份配置文件 <code>jsconfig.json</code> 即可，配置文件的内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span>   <span class="comment">// 根目录</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;./src/*&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;components/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;./src/components/*&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;services/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;./src/services/*&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这个配置文件和 webpack 是没有关系的，它是给 <code>vscode</code> 用的，想请可以查看这里：<a href="https://code.visualstudio.com/docs/languages/jsconfig">https://code.visualstudio.com/docs/languages/jsconfig</a></p><h3 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h3><p>在原生的 JavaScript 中，使用 <code>import</code> 加载一个模块是可以不用写文件的扩展名的，nodejs 中的 require 也是一样，就像这样：<code>import ModuleA from &#39;a&#39;</code> ，现在有了 loader 我们也希望 <code>import</code> 其它类型文件的时候也不写扩展名，比如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;@/styles/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> html <span class="keyword">from</span> <span class="string">&#x27;@/tpl/login&#x27;</span>;</span><br></pre></td></tr></table></figure><p>只需在 webpack 中配置 extensions 即可，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.html&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该选项的值是一个数组，默认值为 <code>[&#39;.js&#39;, &#39;.json&#39;]</code> ，当我们手动配置之后，默认值会被覆盖，所以为了不影响之前的写法，要在配置中将 <code>.js</code> 和 <code>.json</code> 也加上。</p><p>个人建议不要配置此项，尽量把文件的扩展名写全，这样不仅可以知道引入的文件是什么类型，而且在打包的时候速度也相对快一些。</p><h3 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h3><p>开发一个 Web 项目肯定会用到第三方的类库比如 <code>jQuery</code>、<code>lodash</code> 等，有人会选从 npm 下载，有人会选择从 cdn 加载。这两种方式使用起来都很简单：</p><ul><li>从 npm 下载的包只需在用到的时候 <code>import</code> 就行了：<code>import _ from &#39;lodash&#39;</code></li><li>从 cdn 加载类库只要在 html 页面通过 <code>script</code> 引入之后（注意引用顺序），便可以在任何地方使用</li></ul><p>但是从 cdn 引入的资源在开发过程有一个很不好的地方：既然已经是模块化开发了，突然冒出一个全局变量会让人觉得很莫名其妙，而且这个变量也不能类型提示。</p><p>那可不可以这样子呢：</p><ol><li>从 cdn 加载第三方类库（速度快）</li><li>在代码中依然使用 <code>import</code> 的方式来引入资源（代码模块清晰）</li><li>打包的时候排除从cdn加载的资源（减小打包后的代码体积）</li></ol><p>答案是可以的，配置一下 externals 就可以轻松实现，以 <code>jQuery</code> 为例，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="attr">externals</span>: &#123;</span><br><span class="line">    <span class="attr">jquery</span>: <span class="string">&#x27;jQuery&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中就可以这样使用 <code>jQuery</code> :</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"></span><br><span class="line">$(() =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello jQuery&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而且打包的时候会自动的把 <code>jquery</code> 排除掉。</p><p>从上面的配置中可以看出，<code>externals</code> 是一个对象，它的 key (<code>jquery</code>) 对应的是代码中引入的包名，也就是 <code>from</code> 后面的字符串，它的 val (<code>jQuery</code>) 就是暴露在全局的变量名，jQuery 暴露在全局的变量名为 <code>jQuery</code> 和 <code>$</code> ，所以这里换成 <code>$</code> 同样是可以的。</p><p>所以上面的代码可以理解为是下面这种写法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="variable language_">window</span>.<span class="property">jQuery</span>;</span><br><span class="line"></span><br><span class="line">$(() =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello jQuery&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果想对这个选项有更多的理解，可以参考这里：<a href="https://github.com/zhengweikeng/blog/issues/10">https://github.com/zhengweikeng/blog/issues/10</a></p><h2 id="分离配置文件"><a href="#分离配置文件" class="headerlink" title="分离配置文件"></a>分离配置文件</h2><p>上面的配置中，有的是适用于生产环境的，有的是适用于开发环境的，所以我们要将配置文件做一下分离。在项目中创建 <code>build</code> 文件夹，用来存放我们的构建脚本，在 build 中创建 <code>webpack.common.js</code> 我们可以将一些通用的配置写在这里面，比如 entry、output、loader 等等。然后我们在创建 <code>webpack.prod.js</code> 和 <code>webpack.dev.js</code> 两份配置文件，分别用来编写打包和开发是的脚本，已经在<code>webpack.common.js</code> 中写好的配置，就不需要在写了。然后我们利用 <a href="https://github.com/survivejs/webpack-merge">webpack-merge</a> 将通用的配置分别和 dev、prod 的配置合并：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build/webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackCommonConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(webpackCommonConfig, &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 针对打包到生产环境的配置 */</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后再利用 <code>npm script</code> 设置不同的脚本</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --mode development --color --progress --config  build/webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node build/build.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这里我已经写好一份可以直接使用的配置，大家可以参考一下 <a href="https://github.com/onlymisaky/webpack-workbench">webpack-workbench</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;嫌啰嗦想直接看最终的配置请戳这里&lt;a href=&quot;https://github.com/onlymisaky/webpack-workbench&quot;&gt;webpack-workbench&lt;/a&gt; &lt;/p&gt;
&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="webpack" scheme="http://onlymisaky.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>震惊！JavaScript竟然可以类型推断！</title>
    <link href="http://onlymisaky.github.io/2018/07/04/"/>
    <id>http://onlymisaky.github.io/2018/07/04/</id>
    <published>2018-07-04T07:53:51.000Z</published>
    <updated>2024-09-11T03:04:29.086Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为弱类型的 <code>JavaScript</code> 写起来爽，维护起来更<strong>爽</strong>。<br><div style="text-align: right;">—— 鲁迅·沃梅硕果</div></p></blockquote><p>近几年，前端技术的发展可以用 <code>Big Boom</code> 来形容，因此 <code>JavaScript</code> 也被大规模的运用在项目中，由此也产生了代码的维护问题，所谓 <code>动态类型一时爽，代码重构火葬场</code> 。</p><p>其实不仅仅是代码重构，在日常开发中也能感受到弱类型语言的不足。举个例子，现在有个函数 <code>renderUserList</code> , 作用是将用户列表显示在界面上</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderUserList</span>(<span class="params">el, userList</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> user <span class="keyword">of</span> userList) &#123;</span><br><span class="line">    html += <span class="string">` &lt;div&gt;</span></span><br><span class="line"><span class="string">    姓名：<span class="subst">$&#123;user.age&#125;</span></span></span><br><span class="line"><span class="string">    年龄：<span class="subst">$&#123;user.age&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/div&gt; `</span></span><br><span class="line">  &#125;</span><br><span class="line">  el.<span class="property">innerHTML</span> = html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我敢打赌，大家在写这种类型函数的时候，都是在盲写，因为我们不知道传入的 <code>el</code> 和 <code>userList</code> 到底是什么类型。更不知道 <code>el</code> 下面有哪些方法，写的时候都如此费劲，跟别谈维护了。其实我们可以通过一些简单的操作，让这个函数写起来更轻松，就像下面一样：</p><p><img src="/2018/07/04/%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA1.png" alt="类型提示1"><br><img src="/2018/07/04/%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA2.png" alt="类型提示2"></p><p>那么，到底是怎么实现的呢？接下来就要介绍本文的主角 <a href="http://usejsdoc.org/">JSDoc</a> 和 <a href="https://code.visualstudio.com/">VSCode</a></p><blockquote><p>JSDoc是一个根据javascript文件中注释信息，生成JavaScript应用程序或库、模块的API文档 的工具。你可以使用他记录如：命名空间，类，方法，方法参数等。</p></blockquote><p>在 <code>VSCode</code> 中会自动根据 <code>JSDoc</code> 的标注对变量、方法、方法参数等进行类型推断，通过 <code>TypeScript</code> 来进行智能提示，因此从编写注释开始学习 <code>TypeScript</code> 也是一个不错的选择。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>用 <code>@type</code> 标注变量的类型</p><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">boolean</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">string</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> str;</span><br></pre></td></tr></table></figure><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>如果一个变量可能是多种类型，则可以使用联合类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">string | boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>我们经常用到自定义类型，也就是 <code>JavaScript</code> 中的对象，对于简单的对象，可以用下面的写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">&#123;name: string, age: number</span>&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> user;</span><br></pre></td></tr></table></figure><p>对于键值对比较多的复杂对象，可以使用 <code>@typedef</code> 来定义复杂类型，用 <code>prop</code> 或者 <code>property</code> 来定义对象的属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef</span> &#123;<span class="type">Object</span>&#125; <span class="variable">goods</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> &#123;<span class="type">string</span>&#125; <span class="variable">name</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@prop</span> &#123;<span class="type">number</span>&#125; <span class="variable">code</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@prop</span> &#123;<span class="type">string=</span>&#125; thumbnail 用 = 表示该属性是可能存在，也可能不存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@prop</span> &#123;<span class="type">string</span>&#125; [introduction] 也可以给属性名加上 [] 表示这是一个可选属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@prop</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">label</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@type</span> &#123;<span class="type">goods</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">let</span> phone;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>可以使用 <code>[]</code> 或者 <code>Array</code> 表示数组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> numList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">Array&lt;string&gt;</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> strList;</span><br></pre></td></tr></table></figure><p>对于已经定义的类型或者已经声明的变量，也是可以直接使用，下面分别声明一个 <code>user</code> 数组和 <code>goods</code> 数组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">user[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> userList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">goods[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> goodsList;</span><br></pre></td></tr></table></figure><p>如果不确定数组的每一项具体类型，可以使用 <code>any</code> <code>*</code> 或者交叉类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">any[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> arr1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">*[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> arr2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">(user | goods)[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> arr3</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@template</span> <span class="variable">T</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">T</span>&#125; <span class="variable">p1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">T</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gen</span>(<span class="params">p1</span>) &#123; <span class="keyword">return</span> p1 &#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>用 <code>@name</code> 表示函数的名称</p><p>用 <code>@param</code> 表示函数的参数</p><p>用 <code>@return</code> 或 <code>@returns</code> 表示函数的返回值</p><p>一般函数的写法大致分为两种：声明式函数和函数表达式。</p><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">function (number, number): number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">getSum</span> = (<span class="params">n1, n2</span>) =&gt; n1 + n2;</span><br></pre></td></tr></table></figure><h3 id="声明式函数"><a href="#声明式函数" class="headerlink" title="声明式函数"></a>声明式函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@name</span> <span class="variable">fn</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">str</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; <span class="variable">flag</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">*[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">str, flag</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的注释写法，便可以在函数 <code>fn</code> 内部正确的识别出两个参数的类型，并且该函数返回值类型为数组。</p><p>对于函数参数的类型，写法和上面的变量写法一致，区别是将 <code>@type</code> 换成了 <code>@param</code>，函数的返回值也是同样的道理。</p><h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><p>对函数的注释同样适用于对象的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">msg</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">say</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内置类型和其它类型"><a href="#内置类型和其它类型" class="headerlink" title="内置类型和其它类型"></a>内置类型和其它类型</h2><p>上面的例子只是简单的用到了一些常见的类型，然而在实际开发中，我们用到的不止这些，比如开始文章开头的例子中，有用到了 <code>DOM</code> 对象，那该怎么编写注释呢？其实 <code>VSCode</code> 已经为我们提供了很多的类型了，比如 <code>DOM</code> 对象对应的类型是 <code>HTMLElement</code> , 事件对象对应的类型是 <code>Event</code>，同时 <code>DOM</code> 对象还可以更细化，比如 <code>HTMLCanvasElement</code> 、<code>HTMLImageElement</code> 等等。</p><p>同时，我们在开发中也会用到第三方的类库或框架，通常情况下，这些类库都会有一份以 <code>d.ts</code> 结尾的声明文件，该声明文件中包含了所用到类型的所有提示，以最为经典的 <code>jQuery</code> 为例，如果在时在 <code>webpack</code> 环境下，在通过 npm 安装 jQuery 后，需要再单独安装对应的声明文件 <code>@types/jquery</code> ，这样 VSCode 就可以正确的识别 <code>$</code> 符号，也可以在 JSDoc 中使用 <code>JQuery</code>, <code>JQueryStatic</code> 等这都类型了，就像下面这样</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">JQuery</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> $btn = $(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">userId</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">JQuery.jqXHR</span>&#125; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> $.<span class="title function_">get</span>(<span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分情况下，通过 npm 发布的包，都会包含其对应的声明文件，如果没有的话，可以通过这个地址 <a href="http://microsoft.github.io/TypeSearch/">TypeSearch</a> 来搜索一下并安装  ，如果感兴趣可以到这个仓库 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 看看。当然你也可以提供一些仓库内目前还没有声明文件，别人会非常感谢你的！</p><p>当然并不是所有的项目都用到了 npm ，仍有很多项目在使用 <code>script</code> 这种方式从 cdn 来引入 <code>.js</code> 文件，这种情况下用不到 webpack ，也用不到 npm ，那这个时候就要从上面所提到的仓库地址 <strong><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a></strong> 来下载对应的声明文件了，然后通过 <code>/// &lt;reference path=&quot;&quot; /&gt;</code> 这种形式来引入声明文件，就像下面这样</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;./node_modules/@types/jquery/index.d.ts&quot;/&gt;</span></span><br></pre></td></tr></table></figure><p>个人建议：即使是通过 cdn 方式来引入 <code>.js</code> 文件，也可以通过 npm 来安装 <code>@types/</code> ，这样和在每个文件中通过 <code>/// &lt;reference path=&quot;&quot; /&gt;</code> 引入声明文件相比，还是方便很多的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是关于利用 JSDoc 实现 JavaScript 的类型提示。当然还有一些更深入的用法，比如全局模板文件，命名空间等，但是这些和 TypeScript 关系更大一些。当有一天你发现 JSDoc 已经不能满足你的时候，便是向着 TypeScript 大举进攻的时候了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作为弱类型的 &lt;code&gt;JavaScript&lt;/code&gt; 写起来爽，维护起来更&lt;strong&gt;爽&lt;/strong&gt;。&lt;br&gt;&lt;div style=&quot;text-align: right;&quot;&gt;—— 鲁迅·沃梅硕果&lt;/div&gt;&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://onlymisaky.github.io/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="http://onlymisaky.github.io/tags/TypeScript/"/>
    
    <category term="JSDoc" scheme="http://onlymisaky.github.io/tags/JSDoc/"/>
    
  </entry>
  
</feed>
