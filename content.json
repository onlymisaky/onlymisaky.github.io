{"meta":{"title":"Mikasa","subtitle":null,"description":null,"author":"onlymisaky","url":"http://onlymisaky.github.io","root":"/"},"pages":[{"title":"","date":"2024-09-11T03:04:29.086Z","updated":"2024-09-11T03:04:29.086Z","comments":true,"path":"data/iconfont.css","permalink":"http://onlymisaky.github.io/data/iconfont.css","excerpt":"","text":"@font-face { font-family: \"iconfont\"; /* Project id */ src: url('iconfont.ttf?t=1708347364873') format('truetype'); } .iconfont { font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .icon-xueli:before { content: \"\\e63c\"; } .icon-dianhua:before { content: \"\\e88b\"; } .icon-youxiang:before { content: \"\\e908\"; } .icon-npm:before { content: \"\\f1fe\"; } .icon-github:before { content: \"\\e50e\"; } .icon-boke1:before { content: \"\\e502\"; }"},{"title":"","date":"2024-09-11T03:04:29.086Z","updated":"2024-09-11T03:04:29.086Z","comments":true,"path":"data/resume.bak.html","permalink":"http://onlymisaky.github.io/data/resume.bak.html","excerpt":"","text":"基本信息 Key Value 姓名 朱士奇 性别 男 年龄 25 专业 计算机应用技术 电话 15052745277 邮箱 onlymisaky@gmail.com GitHub https://github.com/onlymisaky Bolg http://onlymisaky.github.io 求职意向 工作性质：全职 目标职位：前端工程师 工作地点：上海 面议 专业技能JavaScript 熟练掌握JavaScript，掌握es6/esnext新特性及语法，熟悉原生模块化开发，ECMA规范 熟悉原型链、闭包，继承机制，了解Event Loop 熟悉 typescript 熟悉Ajax、fetch，了解jsonp原理 了解CMD/AMD/UMD规范，熟悉requirejs 熟练原生DOM操作，熟练使用jQuery、及相关插件，实现快速开发 前端框架 熟练掌握 Vue、 Vuex、Vue-Router，熟练组件的封装，组件间通信 熟练 elementUI、Vant antd-vue 等组件库 熟悉 AngularJs，了解React.js 具备良好模块划分能力，组件拆分能力和页面拆分能力 HTML &amp; CSS 熟练掌握HTML、CSS，能根据设计稿独立完成网站静态页面开发，掌握标签语义化 熟悉HTML5、CSS3、能够利用流式布局、rem等方式实现移动端web开发 了解flex布局，熟悉响应式布局，能够利用Bootstrap快速构建页面 掌握CSS预处理器，掌握less、sass语法 构建工具 &amp; 管理工具 熟悉webpack，利用webpack构建前端项目 熟练使用git，熟悉多分支开发模式 熟悉 rollup 掌握gulp，编写gulp脚本处理、压缩、打包文件 熟练使用 npm 包管理工具 具有良好的代码编写风格、注释习惯，追求完美的代码 工作经历 时间 公司 职位 2018-04 - 至今 杏仁医生 前端工程师 2017-03 - 2018.04 上海铝神信息科技有限公司 前端工程师 2015-03 - 2017-01 江苏楚淮软件科技开发有限公司 软件工程师 项目经验企鹅杏仁门诊平台(https://clinic.xingrengo.com)2018.04 - 至今 关键词：重构、webpack、vue、vue-router、vuex、Element-UI、jQuery 企鹅杏仁线下门诊使用的HIS系统(Hospital Information System)，用于预约、挂号、就诊、检查、开药、收费等。 企鹅医生(http://xiaoxing.aihaisi.com/#/m/chat-list)2019.02 - 2019.03 关键词：mobile、WebSocket、vue、vue-router、vuex、Vant 杏仁先知2019.01 - 2019.02 xrshop关键词：后台管理、vue、vue-router、vuex、Element-UI 2018.05 - 2019.06 门诊主页(https://sz.xingren.com/wap/e/home)关键词：mobile、react 智造ERP(https://erp.thinkerx.com/)关键词：进销存、vue、vue-router 2017.08 - 2018.04 智造2017，为大型铝材厂商提供库存管理、材料销售、加工生产、客户管理、财务管理、采购管理等多种功能，帮助门窗厂实现3倍增长 使用vue-cli快速构建项目模型 使用webpack实现接口转发、多环境开发、打包部署功能 通过对element-UI进行二次开发，编写符合本项目需求的通用组件 编写项目所需要的组件，如文件上传组件，CDA预览组件等 使用axios调用接口，完成前后端联调 使用sass编写样式，方便管理 使用ES6&#x2F;ES7语法，减少代码量 Venus材料中心(https://venus.thinkerx.com/)2017.10 - 2018.02 关键词：独立开发、vue、vue-router、webpack 为其它各线产品提供型材、五金、玻璃、板材、配件等材料的基础数据和配套组合方案 该项目技术栈与智造ERP完全相同，并且由个人独立完全重构。 旺材(http://wangcai.cshen.cn/)2017.03 - 2018.02 关键词：AngularJS、ui-router、gulp、进销存 旺材仓库管理系统，卖家把控好材料的存放、销售问题，为其完善好后勤工作，没有后顾之忧 使用angularJS开发项目 使用gulp处理、打包文件，完成项目构建 使用http-proxy-middleware转发接口，方便本地开发调试 使用bootstrap提供的样式快速完成页面编写 使用sass编写样式 材神网(http://cshen.cn/)2017.03 - 2017.09 关键词：AngularJS、ui-router、gulp、商城 材神网商城，为原材料商与客户提供方便、快捷的服务，构建更良好的交流和沟通平台，打通门窗行业上下游产业链，实现上下游无缝高效对接，市场发展前景广阔 该项目技术栈与旺材完全相同 材神网移动端(http://m.cshen.cn/)2017.03 - 2017.09 关键词：AngularJS、ui-router、gulp、商城、mobile 该项目为材神网移动端技术栈与旺材完全相同 手机信访2016.04 - 2016.08 关键词：zepto、asp.net、ADO.net、SQL Server、混合app 江西赣州手机网上信访 该项目为混合APP,技术栈与招商管理系统相同 招商管理系统2015.12 - 2016.03 关键词：zepto、asp.net、ADO.net、SQL Server、混合app 盱眙招商局招商管理系统，在外招商人员进行工作、项目汇报 使用HTML、CSS配合easyui完成后台界面的搭建 使用CSS3配合流式布局，完成移动端网页（混合app开发） 使用CSS3提供的transition等特性配合js，实现手势操作、动画效果 使用HTML5离线缓存功能，本地存储、缓存部分页面和数据，提升用户体现 利用Zepto完成DOM操作 利用ajax调用后台接口，进行数据的增删改查操作 配合android端利用js实现对android方法的调用，完成文件上传、地理位置获取等功能 配合android端完成软件升级、按键操作等 使用.NET、SQL server完成后端开发 网上信访2015.06 - 2016.12 关键词：jQuery、asp.net、ADO.net、SQL Server、独立开发 山东、江西各市网上信访平台，为群众提供网上信访的功能，主要包括网上投诉、信访件办理进度查询、信访件办理结果评价、信访信息发布管理等功能 使用HTML、CSS配合通栏布局完成页面开发，并兼容低版本IE 使用jQuery完成DOM操作，动画及用户交互 通过对ajaxfileupload插件修改实现多文件上传，为用户提供上传信访附件的功能 使用ASP.NET、SQL server完成后端开发 使用Aspose完成对word，pdf文件的转码，实现在线预览 触摸屏信访2015.04 - 2016.06 关键词：C/S、winfrom、asp.net、ADO.net、Html、Css 为信访局办公大厅的触摸屏设备提供信访功能，方便群众完成自助信访 使用winfrom开发触摸屏客户端软件 使用HTML+CSS完成触摸屏操作界面开发 使用ASP.NET完成触摸屏后端开发 使用JavaScript调用客户端提供的方法完成文件操作 自我评价 热爱且喜欢钻研新技术 性格开朗，乐于沟通 责任心强，有良好的团队合作意识，善于分析问题且能解决问题 工作认真负责，做事踏实严谨"},{"title":"","date":"2024-09-11T03:04:29.090Z","updated":"2024-09-11T03:04:29.090Z","comments":true,"path":"data/resume.css","permalink":"http://onlymisaky.github.io/data/resume.css","excerpt":"","text":".markdown-body { padding: 10px 32px 0px; border-style: none; } a { color: #409eff !important; } strong > code { background-color: #fff !important; color: #000 !important; padding: 5px 6px !important; border-radius: 10px !important; border: 1px solid #ccc !important; font-size: 13px !important; font-weight: 700 !important; }/*# sourceMappingURL=resume.css.map */"},{"title":"","date":"2024-09-11T03:04:29.090Z","updated":"2024-09-11T03:04:29.090Z","comments":true,"path":"data/resume.html","permalink":"http://onlymisaky.github.io/data/resume.html","excerpt":"","text":"朱士奇8年前端 1年后端 本科 15052745277 onlymisaky@gmail.com https://github.com/onlymisaky https://onlymisaky.github.io https://www.npmjs.com/~onlymisaky 专业技能 熟悉 Vue2 &#x2F; Vue3 &#x2F; React ，可独立承担项目开发。 熟悉前端基建、前端⼯程化，并有一定项目实战经验，有项目微前端改造经验。 熟悉 Webpack 和 Vite ，可以从0到1搭建项目和优化性能，开发过 Webpack 插件。 熟练掌握 TypeScript 以及 es6/esnext 新特性及语法，并在团队内部推⼴ TypeScript 落地使⽤。 了解 Node.js 和常⻅开发框架( Express &#x2F; Nest )。 有一定的团队管理能力。 工作经历 时间 公司 职位 2024-05 ~ 至今 上海领健信息技术有限公司 资深前端开发工程师 2022-11 ~ 2024-01 数库(上海)科技有限公司 前端组长 2022-03 ~ 2022-11 海澜智云科技有限公司 高级前端工程师 2018-04 ~ 2022-02 成都医联科技有限公司 高级前端工程师 2015-03 ~ 2018-04 上海铝神信息科技有限公司 前端工程师 项目经验Clue 组件库 2023.08~2024.01 项目描述：基于公司现有成熟稳定业务，开发基础组件、封装业务组件，沉淀出可复用的组件库，赋能其它业务线实现快速交付。 技术栈：Vue、Vue-Demi、Vue-Cli、Jenkins、Vuepress、Nodejs 负责内容： 负责组件库的整体架构设计，制定组件库开发规范。 负责组件库的迭代开发，包括新组件开发、组件优化、组件重构等。 负责组件库的文档编写，提供组件使用文档。 负责组件库的版本发布，保证组件库的稳定性和兼容性。 项目亮点： 使用 vue-demi 抹平 Vue2 和 Vue3 的差异，实现组件库的跨版本兼容。 从0到1完成组件库脚手架搭建，包括第三方工具库集成、发布、文档等。 提供可复用的组件，覆盖了公司现有业务场景，兼容老项目原有写法，接入方便。 使⽤ Vuepress 搭建组件库⽂档，提供组件使⽤⽂档 Clue 智拓客 2023.08~2023.12项目描述：银行对公数字化平台，为商业银行公司条线打造对公数字化营销系统。 技术栈：Vue、Vue-Cli、Mirco-App、Vite、D3.js 负责内容： 负责日常需求评审、技术评审、任务分配、代码审核、提供技术方案。 对业务流程逻辑梳理，制定子应用划分、模块划分。 负责项目微前端改造、构建工具升级与迁移、Vue 版本升级。 主要成果: 使用 Mirco-App 进行项目的微前端改造，实现子项目的独立运行、独立开发和独立部署。 构建⼯具迁移⾄ Vite ，并对Vite进行性能优化，项⽬冷启动事件减少 40s +，提升开发效率。 完成前端异常监控SDK，实现 JS、Promise、Vue 组件等常见错误捕获和上报。 设计并实现客服问题一键上报插件，实现录屏和自动错误收集还原问题，提升异地客服问题反馈解决效率。 设计并实现配置化表单方案，只通过配置configjs数据，即可实现表单的自动渲染和使用，提升了开发效率。 设计并实现前端权限管理方案，实现登录权限、页面权限和内容权限的控制，可以更加细粒度对页面进行管理。 未来医生门诊平台 (HIS) 2018.04~2022.02 长期迭代项目描述: 为未来医生线下门诊提供预约、挂号、就诊、检查、开药、收费等服务。 技术栈: Vue、Element UI、TypeScript、vue-property-decorator 负责内容： 设计并验证传统MPA项目升级到SPA项目方案。 封装基础的业务组件。 引入 TypeScript ，并在团队内推广。 负责日常需求评审、开发、任务分配。 主要成果: 将项目由传统 MPA 项目升级到 SPA 项目，提升门诊医生使用体验和效率。 解决项目启动需要 Java 后端支持的困境，极大提升启动速度和开发效率。 拆分 git 仓库，前端实现自主部署发布，不依赖后端。 相关文章: HIS前端重构经验 https://onlymisaky.github.io/2019/09/20/ 让Vue老项目支持js与ts混用 https://onlymisaky.github.io/2019/12/27/ 未来医生云诊室 2020.02~2022.02 移动端项目描述： 为未来医生提供线上问诊、聊天平台。 技术栈: Preact、socket.io、rem、viewport 负责内容： 负责技术选型，项目搭建，项目迭代。 负责IM聊天模块，ping&#x2F;pong心跳检测，断线重连。 负责移动端适配。 项目亮点： 使⽤ Preact 作为开发框架，解决 React &#x2F; Vue 体积较⼤的问题。 通过定时发送应用层心跳、断线重连和主动拉取等方式，实现WebSocket连接的高稳定性，防止消息或通知的遗漏。 完成前端性能上报SDK，可自动收集FCP、LCP、资源加载时间等数据，支持主动和自动上报。 开发可拖拽列表组件，实现列表的拖拽排序。"},{"title":"","date":"2024-09-11T03:04:29.090Z","updated":"2024-09-11T03:04:29.090Z","comments":true,"path":"data/resume.min.css","permalink":"http://onlymisaky.github.io/data/resume.min.css","excerpt":"","text":".markdown-body{padding:10px 32px;border-style:none;}a{color:#409eff !important}strong>code{background-color:#fff !important;color:#000 !important;padding:5px 6px !important;border-radius:10px !important;border:1px solid #ccc !important;font-size:13px !important;font-weight:700 !important}"},{"title":"slides","date":"2019-05-29T10:32:00.000Z","updated":"2024-09-11T03:04:29.090Z","comments":true,"path":"slides/index.html","permalink":"http://onlymisaky.github.io/slides/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2024-09-11T03:04:29.090Z","comments":false,"path":"tags/index.html","permalink":"http://onlymisaky.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-09-11T03:04:29.102Z","updated":"2024-09-11T03:04:29.102Z","comments":true,"path":"xr/platform-2.html","permalink":"http://onlymisaky.github.io/xr/platform-2.html","excerpt":"","text":"关于Platform平台组成立于2015年10月，由Emac组建，初创成员有赵龙凯（后端）、Hugo（运维），取名平台组的初心是打造杏仁自有PaaS平台。 我们的口号：10倍速成长！ 成员风采团队相册：https://www.tapd.cn/61940682/documents/file_list/1161940682001000621相册地址（旧）：https://www.tapd.cn/44641644/documents/file_list/1144641644001000168 开发小组 HIS开发组：⭐️杨洋Young，⭐️牛在舒，⭐️姜日游Ryan，⭐️王金龙，⭐️刘长鑫，⭐️桑元成，⭐️钱光辉 门诊前端组：⭐️王旋，⭐️葛敬培，⭐️朱士奇，⭐️马靖Fiona，⭐️陈元皓Joey，⭐️张珊Aminsey 门诊测试组：⭐️孙计登，⭐️任雅琴，⭐️邵盼盼 财务和供应链组：⭐️张帆，⭐️高建Aiden，⭐️颜杰，⭐️谢宏博，⭐️徐振阳 星光大道上海：!!#ffd966 凌晨Darcy，陈传洞，陈阳，曹金霖Don，孟慧杰，骆袁凯，蒋楠鑫Park，郑爱美Amanda，李增光，黄永灿Ronnie，喻涛，王利，冯明益，杨碧佳Ellin，江奎，童辉Aaront，张怀雷Jerry（实习生），周东Jear，赵龙凯，简伟林；!! 北京：!!#ffd966 王鹏，谷军宇，张红霞，郝敬伟；!! DevOps：!!#ffd966 徐剑菲Evan，陈鹏任Hugo;!! IT：!!#ffd966 郝远明Hayes，李闻渊（实习生），孙发松Andou，吴欢，周晓丹Tim（实习生），刘成博Robber, 俞耀峰Fisher;!!"},{"title":"","date":"2024-09-11T03:04:29.102Z","updated":"2024-09-11T03:04:29.102Z","comments":true,"path":"xr/platform.html","permalink":"http://onlymisaky.github.io/xr/platform.html","excerpt":"","text":"关于Platform平台组成立于2015年10月，由Emac组建，初创成员有赵龙凯（后端）、Hugo（运维），取名平台组的初心是打造杏仁自有PaaS平台。 我们的口号：10倍速成长！ 成员风采相册地址：https://www.tapd.cn/44641644/documents/file_list/1144641644001000168 开发小组 白羊组：杨洋，金霖，Ellin，增光； 金牛组：小牛，Ronnie； 双鱼组：谷哥，强哥，刚哥；王旋，敬培，敬伟 星光大道后端（上海）：⭐️沈斌Emac，⭐️杨洋Young，⭐️牛在舒，⭐️曹金霖Don，⭐️夏梓耀Milo，⭐️任旭东Jack，⭐️黄永灿Ronnie，⭐️杨碧佳Ellin，⭐️李增光，⭐️喻涛，⭐️姜日游，⭐️李祥，⭐️郑爱美，⭐️骆袁凯，⭐️邹济懋Pep，⭐️陈传洞，⭐️高建Aiden，⭐️曹恒源，⭐️谢宏博，⭐️孙旺； !!#999999 江奎，童辉Aaront，张怀雷Jerry（实习生），周东Jear，赵龙凯，简伟林!! 后端（北京）：⭐️谷军宇 后端（成都）：⭐️张强，⭐️徐刚 前端：⭐️王旋，⭐️葛敬培，⭐️郝敬伟； 测试：⭐️孙计登； 产品：⭐️张红霞； DevOps：⭐️黄超；徐剑菲Evan，陈鹏任Hugo IT：⭐️洪鑫Golden，⭐️郝远明Hayes； !!#999999 李闻渊（实习生），孙发松Andou，吴欢，周晓丹Tim（实习生），刘成博Robber, 俞耀峰Fisher!!"},{"title":"","date":"2024-09-11T03:04:29.146Z","updated":"2024-09-11T03:04:29.146Z","comments":true,"path":"不部署/docker.html","permalink":"http://onlymisaky.github.io/%E4%B8%8D%E9%83%A8%E7%BD%B2/docker.html","excerpt":"","text":"https://juejin.cn/post/7139724794672447518https://juejin.cn/post/6844903946234904583 docker build t [镜像名称] .docker run –name [容器名称] -d –restart&#x3D;always -p [外部端口]:[内部端口] [镜像名称] docker ps -adocker stop [容器名称] &amp;&amp; docker rm [容器名称] docker image lsdocker images docker rmi [镜像名称]docker logs -f [镜像名称]docker exec -it [镜像名称] &#x2F;bin&#x2F;sh docker save [镜像名称] &gt; [文件名].tar"},{"title":"linux基础命令","date":"2018-04-28T04:10:56.000Z","updated":"2024-09-11T03:04:29.146Z","comments":true,"path":"不部署/linux基础命令.html","permalink":"http://onlymisaky.github.io/%E4%B8%8D%E9%83%A8%E7%BD%B2/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4.html","excerpt":"","text":"文件操作 command 作用 ls ls -a ls -lsh cat FileName 查看文件 mkdir PathName 创建文件夹 touch FileName 创建文件 mv FileName PathName 移动文件 cp FileName PathName 复制文件 rm FileName 删除文件 rm -f FileName 强制删除 rm -rm PathName 强制递归删除 open -a SoftName FileName 用 SoftName 打开 FileName cat &#x2F;etc&#x2F;shells 查看mac系统中内置的几种shell echo $SHELL 输出当前终端 ls -lsg -a 查看子目录 pwd 查看当前路径 $path 查看环境变量 env 查看环境变量 sudo chown -R 用户名 目录 修改目录的所有者 defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder mac 显示隐藏目录和文件 rz 上传 sz 下载 scp -r &#x2F;app&#x2F;workflow-docker&#x2F;workflow.tar &#97;&#112;&#112;&#x61;&#100;&#x6d;&#105;&#x6e;&#x40;&#x31;&#x36;&#x38;&#x2e;&#x36;&#51;&#46;&#55;&#48;&#46;&#50;&#x34;&#50;:&#x2F;app&#x2F;webTestunzip taiji.zip sbin&#x2F;nginx -tsbin&#x2F;nginx -s reload chmod -R 755 dist2"},{"title":"vi基本操作","date":"2018-04-28T04:32:04.000Z","updated":"2024-09-11T03:04:29.146Z","comments":true,"path":"不部署/vi基本操作.html","permalink":"http://onlymisaky.github.io/%E4%B8%8D%E9%83%A8%E7%BD%B2/vi%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html","excerpt":"","text":"vi有三种模式 命令行模式 插入模式 底行模式（莫行模式） 命令行模式 command 作用 l 向右移动一个字符 h 向左移动一个字符 j 向下移动一行 k 向上移动一行 ctrl+f 向前翻页 ctrl+b 向后翻页 &#x2F;test 查找test i 进入编辑模式，当前光标处插入 a 进入编辑模式，当前光标后插入 A 进入编辑模式，光标移动到行尾 o 进入编辑模式，当前行下面插入新行 O 进入编辑模式，当前行上面插入新行 ZZ 保存并退出 u 撤销 dd 删除当前行 yy 复制当前行 p 粘贴内容 底行模式 command 作用 :w 保存 :w path&#x2F;file 另存为 :q 退出 :wq 保存并退出 :e! 撤销更改，返回到上一次保存的状态 :q! 不保存强制退出 :set nu 设置行号 linux 命令"},{"title":"","date":"2024-09-11T03:04:29.146Z","updated":"2024-09-11T03:04:29.146Z","comments":true,"path":"不部署/折线图.html","permalink":"http://onlymisaky.github.io/%E4%B8%8D%E9%83%A8%E7%BD%B2/%E6%8A%98%E7%BA%BF%E5%9B%BE.html","excerpt":"","text":"06.21 300206.22 1087606.23 647006.24 982806.25 缺失06.26 216306.27 235606.28 69606.29 66906.30 1116607.01 922907.02 1105407.03 缺失 09:07:3907.04 7534 15:47:0807.05 5020 meet07.06 缺失07.07 缺失07.08 77207.09 78707.10 2397 goodbey07.11 12535 beijing07.12 1169907.13 37507.14 1716407.15 989007.16 37707.17 1563907.18 1415307.19 1828207.20 1755107.21 451107.22 851607.23 111107.24 244007.25 233307.26 280607.27 74407.28 149507.29 225707.30 3800 back 上海07.31 424608.01 433308.02 861608.03 1498508.04 59808.05 507708.06 452408.07 328108.08 414508.09 330908.10 30508.11 110408.12 264908.13 352208.14 488308.15 289208.16 121408.17 33408.18 75008.19 281008.20 406308.21 335908.22 416608.23 219608.24 35108.25 77408.26 249208.27 449408.28 403608.29 282508.30 2353 2019年08月30日19:00:4308.31 44109.01 91109.02 278809.03 511009.04 503609.05 524709.06 2623 2019年09月06日18:46:5409.07 675409.08 1007609.09 301909.10 1153509.11 471709.12 473509.13 721409.14 2227109.15 141109.16 602409.17 546009.18 4110 2019年09月18日20:18:46 464809.19 441209.20 1179 2019年09月20日14:51:19 1770 2019年09月20日19:01:15 684509.21 482409.22 50309.23 1316 2019年09月23日10:16:27 482009.24 383409.25 445409.26 312409.27 3570 2019年09月27日18:44:47 445909.28 542409.29 149109.30 xxxx10.01 200410.02 457710.03 417210.04 497110.05 275910.06 220610.07 4035 2019年10月7日22点40分10.08 512110.09 376410.10 504710.11 484410.12 502410.13 13310.14 735 2019年10月14日11:11:20 299010.15 475610.16 277610.17 545210.18 6905 2019年10月18日19:33:35 874410.19 482610.20 75310.21 1490 2019年10月21日10:35:34 373910.22 1162 2019年10月22日11:20:50 375210.23 344410.24 388810.25 3549 2019年10月25日19:44:15 385910.26 57010.27 28810.28 2280 2019年10月28日10:36:03 674610.29 482910.30 412810.31 560711.01 4649 2019年11月01日19:03:27 537711.02 1189611.03 18211.04 543111.05 859511.06 3502 2019年11月06日20:05:40 535011.07 565311.08 2455 2019年11月08日14:38:4011.09 xxxx11.10 xxxx11.11 xxxx11.12 xxxx11.13 xxxx11.14 xxxx11.15 xxxx11.16 xxxx11.17 xxxx11.18 xxxx11.19 xxxx11.20 xxxx11.21 xxxx11.22 xxxx11.23 xxxx11.24 xxxx11.25 xxxx11.26 xxxx11.27 xxxx11.28 xxxx11.29 xxxx11.30 xxxx 面包服短款米白牛仔裤工装款阔腿裤呢料西裤羊羔绒卫衣雾霾蓝棉服休闲西装裤"}],"posts":[{"title":"rollup 快速入门与上手","slug":"rollup 快速入门与上手","date":"2022-02-17T11:40:42.000Z","updated":"2024-09-11T03:04:28.942Z","comments":true,"path":"2022/02/17/","permalink":"http://onlymisaky.github.io/2022/02/17/","excerpt":"","text":"前言之前一直用 webpack 来打包前端项目，虽说配置复杂，但用多了也沉淀出了自己的配置，能够应对多数的打包和构建场景。然而最近在折腾一些自己的小项目时，需要打包一些类库发布到 npm 。虽说 webpack 也可以构建 library ，但是打包出的产物体积过大，而且代码也不是那么的“干净”，并且当想通过 webpack 一次打包出不同的版本，比如 esm 、 CommonJS 、 umd 等，webpack 就显得更加难用，于是就把目光锁定到了 rollup 。 什么是 rolluprollup 和 webpack 一样，都是 JavaScript 模块打包器，用于打包和构建 JavaScript 应用程序和 library 。而 rollup 则更适合打包 library 且自身更为小巧和简单，所以有些开发应用时需要的功能，rollup 反而不支持，比如模块热更新(HMR)。我们熟知的 Vue 、 React 都是通过 rollup 打包。并且 rollup 进入大多是开发者的视野也要得益于 React 。2017年4月初，Facebook 将一个巨大的 pull 请求 合并到了 React 主分支中，将其现有的构建流程替换为基于 rollup ，这一举动让 rollup 得到了更多开发者的关注。 快速上手首先创建项目，我们将会实现一个计算器类库，用于解决 js 在计算加减乘除时产生的精度丢失问题。项目目录如下: 仓库地址: https://github.com/onlymisaky/calculator calculator├── src│ ├── index.js| └── utils.js└── package.json index.js 文件中包含 加减乘除 四个方法，并通过匿名导出向外部暴露这些方法: export default &#123; addition, subtraction, multiplication, division&#125; utils.js 中则是一些辅助方法，无需多言。 由于只是一个简单的计算功能，并不设计和平台有关的功能或 API ，所以我们要实现的这个 library 可以在任意的 js 环境下使用，比如浏览器、 node 、 Electron 等等。所以我们也需要构建出不同版本的包。 接下来就开始正式进入 rollup 的正式使用。首先就是安装 rollup : npm i rollup -D 和 webpack 一样， rollup 可以通过命令的方式直接使用(需要将 rollup 全局安装): rollup src/index.js -f umd -o dist/index.js 上面的命令表示将 src/index.js 以 umd 形式打包，输出到 dist/index.js 。 很显然这种方式及其不灵活，所以只提一下不做详细的参数介绍。 最常用的方法还是使用配置文件的方式，不必担心， rollup 的配置文件比 webpack 简单多了，甚至比 gulp 的还简单。 核心概念在介绍如何编写 rollup 的配置文件前，我么需要先了解几个它的核心概念，这有助于我们更好使用。 input : 入口文件，对标 webpack 的 entry ，指明了库文件入口位置 output : 输出文件，对标 webpack 的 output ，指明了打包后输出文件的位置、包名、格式等等 plugins : 插件，在构建过程中，需要一些辅助功能，都通过插件实现，比如语法转换、别名解析 external : 当我们的库是基于另一个库开发时，就需要用到它，比如开发一个基于 Vue 的指令，为了不将 Vue 打包到我们的库中，就需要将 Vue 写在 external 中。 以上就是 rollup 的一些核心概念，相较于 webpack 确实简化了许多，在了解核心概念后，编写 rollup 配置文件就简单多了。 编写和使用配置文件在项目根目录创建 rollup.config.js 文件，代码内容如下: import pkg from &#x27;./package.json&#x27;;const banner = `/** * @license * author: $&#123;pkg.author&#125; * $&#123;pkg.name&#125; v$&#123;pkg.version&#125; * (c) 2022-$&#123;new Date().getFullYear()&#125; * Released under the $&#123;pkg.license&#125; license. */`;/** @type &#123;import(&#x27;rollup&#x27;).RollupOptions&#125; */const rollupConfig = &#123; input: &#x27;src/index.js&#x27;, output: [ &#123; file: pkg.main, format: &#x27;umd&#x27;, name: &#x27;Calculator&#x27;, exports: &#x27;default&#x27;, banner, &#125;, ],&#125;;export default rollupConfig; 上面的配置代码中，只涉及到了 input 和 output 两个概念，需要额外解释的是 output 这个选项。 output 允许传入一个对象会数组，当传入数组时，会依次输出多个文件。 output.file : 表示输出的文件路径 output.format : 表示输出文件的格式，可选项有 umd 、 commonjs 、 esm 等。 output.name : 当 format 值为 umd 时，需要设置 output.name ，在浏览器环境下就可通过 name 使用。 output.name : 导出方式，可选值有 default 、 named 、 none 、 auto ，我们是匿名导出，就填写 default 。 output.banner : 文件头部添加的内容，当然也有对应的 output.footer 选项用于文件末尾添加的内容 。 接下来使用 rollup -c 命令便可以打包，就可以在 dist 文件夹输出 index.js 文件。为了方便，将 rollup -c 加入 npm scripts 中，运行 npm run build，得到的输出文件内容大致如下: /** banner */(function (global, factory) &#123; typeof exports === &#x27;object&#x27; &amp;&amp; typeof module !== &#x27;undefined&#x27; ? module.exports = factory() : typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define(factory) : (global = typeof globalThis !== &#x27;undefined&#x27; ? globalThis : global || self, global.Calculator = factory());&#125;)(this, (function () &#123; &#x27;use strict&#x27;; /** some code */ var index = &#123; addition, subtraction, multiplication, division &#125;; return index;&#125;)); 这是一个标准的 umd 格式的包，我们可以在 浏览器环境下通过 Calculator 直接使用，也可以在 node 环境下通过 requrie 调用。 babel 插件大致浏览打包出的代码后，可以发现有些较新的语法被没有转换，比如 模板字符串 、 箭头函数 、 rest参数 等等，这些代码在 es5 环境下是无法运行的。为什么会这样呢？因为 rollup 是不会转换这些的，那么就需要用到 babel 插件，来转换这些新的语法。 npm i @babel/core @babel/preset-env @rollup/plugin-babel -D rollup.config.js 文件中添加 plugin 配置项: import babel from &#x27;@rollup/plugin-babel&#x27;;export default &#123; input: &#x27;...&#x27;, output: [&#123;...&#125;], plugins: [ babel(), ]&#125; 创建 babel.config.js 配置文件: /** @type &#123;import(&#x27;@babel/core&#x27;).TransformOptions&#125; */const transformOptions = &#123; presets: [ [ &#x27;@babel/preset-env&#x27;, ] ],&#125;;module.exports = transformOptions; 配置好 babel 之后，再次打包，我们以发现一些高级的语法和 API （这里笔者偷懒了，实际上在没有安装和配置 @babel/runtime 等相关插件前，babel 只能转换语法，不能转化 API ，比如代码中的 includes 就是新的 API 但是并没有被转换，等笔者写完 babel 相关文章后再来更新） 已经被转换可以在低版本环境中运行了。 resolve 插件在上述场景中，我们并没有引用其他的包，但在实际开发中引用第三方包辅助快速开发是非常常见的场景。 在默认情况下，如果我们直接导入 node_modules 中的包，打包完成之后，node_modules 中的包并不会和我们编写的库合并。为了举例说明，我们将安装一个用于迭代字符串的包 repeat-string ，然后在 index.js 导入并使用: import repeat from &#x27;repeat-string&#x27;;console.log(repeat(1, args.length)); 在运行 npm run build 之后可以发现，虽然打包成功了，但是控制台确有一些警告提示: (!) Unresolved dependencieshttps://rollupjs.org/guide/en/#warning-treating-module-as-external-dependencyrepeat-string (imported by src/index.js) 打包后的代码中也可以看到，repeat-string 默认是以参数的形式注入其中，而不是与我们的代码合并。 为了解决这个问题，就要用到 @rollup/plugin-node-resolve 插件，他可以帮助我们解析 node_modules 中的第三方包。 npm i @rollup/plugin-node-resolve -D rollup.config.js : import babel from &#x27;@rollup/plugin-babel&#x27;;import resolve from &#x27;@rollup/plugin-node-resolve&#x27;;export default &#123; input: &#x27;...&#x27;, output: [&#123;...&#125;], plugins: [ resolve(), babel(), ]&#125; 再次运行 npm run build 之后，你会惊讶的发现，直接报错了: src/index.js → dist/index.js...[!] Error: &#x27;default&#x27; is not exported by node_modules/repeat-string/index.js, imported by src/index.jshttps://rollupjs.org/guide/en/#error-name-is-not-exported-by-module 这是因为 repeat-string 是 commonjs 格式的包，而我们是以 ESModule 的方式引入的，所以就报错了。所以需要继续借助插件将 commonjs 转换为 ESM ，就是接下来要介绍的 commonjs 插件。 commonjs 插件安装和配置: npm i @rollup/plugin-commonjs -D import babel from &#x27;@rollup/plugin-babel&#x27;;import resolve from &#x27;@rollup/plugin-node-resolve&#x27;;import commonjs from &#x27;@rollup/plugin-commonjs&#x27;;export default &#123; input: &#x27;...&#x27;, output: [&#123;...&#125;], plugins: [ resolve(), commonjs(), babel(), ]&#125; npm run build 之后，可以发现不仅正确的解析了 repeat-string ，而且也将代码和我们的库合并了。 其他常用插件除了上述的三个插件之外，还有一些常见的插件: @rollup/plugin-json : 解析编译源码中的 json 文件，并且配合 rollup 的 Tree Shaking 可只打包 .json 文件中我们真正用到的部分。 @rollup/plugin-typescript : 解析和转换 typescript @rollup/plugin-eslint : eslint 插件 rollup-plugin-terser : 压缩代码 其它更多插件可以到官方仓库中查找: https://github.com/rollup/plugins external 属性当配置了 @rollup/plugin-node-resolve 和 @rollup/plugin-commonjs 之后， 所有从 node_modules 中导入的包都会合并到我们的库中，有时候我们并不希望如此，比如 Vuex 和 VueRouter 都基于 Vue 开发，但打包出的代码中若包含了 Vue 的源码，那显然不合适，所以需要将 Vue 设置为外部项，也就是通过 external 属性来设置。如果回到我们的案例中，我们想将 repeat-string 也设置为外部项，只需做如下修改: import resolve from &#x27;@rollup/plugin-node-resolve&#x27;;import commonjs from &#x27;@rollup/plugin-commonjs&#x27;;import babel from &#x27;@rollup/plugin-babel&#x27;;export default &#123; input: &#x27;...&#x27;, output: [&#123;...&#125;], plugins: [ resolve(), commonjs(), babel(), ], external: [ &#x27;repeat-string&#x27;, // 外部依赖的名称 path.resolve( &#x27;./src/some-local-file-that-should-not-be-bundled.js&#x27;) // 一个已被找到路径的ID（文件的绝对路径) ]&#125;","categories":[],"tags":[{"name":"rollup","slug":"rollup","permalink":"http://onlymisaky.github.io/tags/rollup/"},{"name":"打包","slug":"打包","permalink":"http://onlymisaky.github.io/tags/%E6%89%93%E5%8C%85/"},{"name":"构建","slug":"构建","permalink":"http://onlymisaky.github.io/tags/%E6%9E%84%E5%BB%BA/"}]},{"title":"认识前端脚手架","slug":"认识前端脚手架","date":"2021-08-25T12:32:45.000Z","updated":"2024-09-11T03:04:29.078Z","comments":true,"path":"2021/08/25/","permalink":"http://onlymisaky.github.io/2021/08/25/","excerpt":"","text":"什么是 CLICLI (Command Line Interface) ，顾名思义是一种通过命令行来交互的工具或者说应用。前端常用的 CLI 有 @angular&#x2F;cli 、 @vue&#x2F;cli 、 create-react-app 。它们可以帮助开发者减少低级重复劳动，专注业务提高开发效率，规范 develop workflow。 为什么要用 CLI我们可以将工作中繁杂、有规律可循、或者简单重复劳动的工作用 CLI 来完成，只需一些命令，快速完成简单基础劳动。现有工作中的可以用 CLI 完成的工作有： 快速生成应用模板，创建 module 模板文件 服务启动，如 ng serve eslint ，代码校验 自动化测试 编译build 总体而言就是一些快捷的操作替代人工重复劳动，提升开发效率。 与 npm scripts 相比npm scripts 也可以实现开发工作流，通过在 package.json 中配置 scripts 字段，执行相关命令，但 CLI 与 npm scripts 相比仍有自己优势： npm scripts 只能在项目中使用， CLI 可以全局安装，到处使用 npm scripts 与业务耦合度高，而 CLI 可以和业务代码剥离 CLI 可以单独迭代开发，改进原有功能，增加新特性 package.json每一个以 node 为基础为项目，在根目录中都有 package.json 文件，用于存储项目的信息、配置、运行环境和所依赖的模块等。 接下来介绍一些实现一个 CLI 需要了解的 package.json 中的字段。 name项目名称 只能是小写字母、数字、~、-、_ 这些内容 不支持空格，使用连字符区分多个单词 支持 scope ，以 @name&#x2F; 开头，不过该形式的包托管到npm是收费的 (just 7$) 在创建 js 项目的时候，我们通常会通过 npm init 来快速初始化 package.json 文件，也可以通过 npm int -y 使用默认是值，快速创建。 也可以通过 npm init &lt;initializer&gt; 来快速执行某个包中的脚本创建项目，比如常见的： npm init react-app project-name npm init vite@latest my-vue-app --template vue 其实背后执行的是 npx create-react-app project-name而npx 则相当于执行： npm i create-react-app 安装到临时目录，使用完之后会删除，不占用户存储空间 create-react-app project-name 所以细心的你也可以发现，如果一个包名以 create 开头，那就可以通过 npm init &lt;initializer&gt; 来快速调用该包提供的脚本命令，创建新项目 命令 等同 npm init foo npx create-foo npm init @user&#x2F;foo npx @user&#x2F;create-foo npm init @user npx @user&#x2F;create 我们也可以利用这个形式创建一些简便的脚手架工具 bin指定内部命令所对应可执行文件的位置 编写一个脚手架，我们肯定需要用户安装好我们的包之后，通过命令行的方式直接使用，那就非常有必要设置该字段了，比如 @vue&#x2F;cli 中： &#123; &quot;bin&quot;: &#123; &quot;vue&quot;: &quot;bin/vue.js&quot; &#125;&#125; 在安装 @vue&#x2F;cli 后，就可以通过 vue 命令来使用了。命令对应的可执行文件需要在文件首行设置下面代码： #!/usr/bin/env node 该行代码告诉操作系统,使用 env 来找到 node，并使用 node 来作为程序的解释程序。 scripts这个可能是所有前端使用率最高的一个字段了，开发者通过设置 scripts 字段来自定义一些脚本 &#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;node ./build.js&quot;, &quot;start&quot;: &quot;node ./server.js&quot; &#125;&#125; 这样就可以通过 npm run build 和 npm start 来执行对应的文件了。不过关于 npm-scripts 还有一些容易遗漏的知识点需要知道： 有些命令是不需要加 run 的，比如 npm start 、npm test 、 npm lint 使用 &amp; 符号并行执行多个 npm scripts ，使用 &amp;&amp; 符号串行执行脚本 npm script 也是有钩子，分别是 pre 和 post ，对应执行前和执行后 &#123; &quot;scripts&quot;: &#123; &quot;prebuild&quot;: &quot;eslint&quot;, &quot;build&quot;: &quot;node ./build.js&quot;, &quot;postbuild&quot;: &quot;npm start&quot;, &quot;start&quot;: &quot;node ./server.js&quot; &#125;&#125; 当执行 npm run build 时，会依次执行 npm run prebuild 、npm run build 、 npm run postbuild 可以通过 process.env.npm_** 来获取一些值 process.env.npm_lifecycle_event 获取正在运行的脚本名称 process.env.npm_package_** 获取 package.json 相关字段的值 process.env.npm_config_argv 获取参数 npm scripts 原理在执行 npm run xx 的时候会自动根据不同平台创建一个 shell ， 类 UNIX 中代指 /bin/sh ，Windows 中使用的是 cmd.exe ， npm scripts 脚本就在这个新创建的 shell 中被运行。所以可以得出一些结论： 只要是 shell 可以运行的命令，都可以作为 npm scripts 脚本 npm 脚本的退出码，也自然遵循 shell 脚本规则 如果系统里安装了 Python ，可以将 Python 作为 npm scripts npm scripts 脚本可以使用 shell 的通配符等常规能力 { “scripts”: { “lint”: “eslint **&#x2F;*.js” } } 不过 npm scripts 创建的 shell 也有一些特殊之处： 创建出来的 shell 会将当前目录的 node_modules/.bin 子目录加入 PATH 变量中，执行完成后，再将 PATH 变量恢复。比如我们在项目中安装 webpack 后，不用写出完成整路径便可以使用 webpack： &#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot; &#125;&#125; 等同于 &#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;./node_modules/.bin/webpack&quot; &#125;&#125; dependencies 和 devDependencies分别对应项目运行所需依赖和开发所需依赖，这里需要知道依赖版本符号的含义： version 完全匹配 version 大于该版本 &#x3D;version 大于等于该版本 &lt;version 小于该版本 &lt;&#x3D;version 小于等于该版本 ~version 非常接近该版本 ^version 与该版本兼容 (默认，常用) 任意版本 latest 最新版本 description、keywords 分别对应项目的描述和关键词，在 npm search 时会用到 npm link在开发 npm 包的时候，我们需要调试包的功能是否正确，直接发布到 npm 是不太现实的，直接将包拷贝到项目中这种方式也显得很傻。这时候我们就可以借助 npm link 命令创建软链接，将其链接到全局 node 模块安装路径中，同时也会将 package.json 中的 bin 字段对应的脚本生成一个可执行文件。 命令行参数在执行 node 脚本或通过 npm scripts 执行命令的时候，也是可以传递参数的： npm run serve --prot=80node serve.js prot=80 上面两种方式都传入了参数 prot&#x3D;80 ，在 npm 中通过 process.env.npm_config_argv 获取参数，在 node 中通过 process.argv 获取参数。在构建 cli 工具时，我们需要考虑参数风格，常见的参数风格有三种： Unix 风格：前面加 -， 后面跟的是单个字符，例如 ls -l , ls -al 则相当于 ls -a -l GNU 风格：前面加 – ，例如上面的 npm run serve –prot&#x3D;80 BSD 风格：前面不叫任何修饰符 例如上面的 node serve.js prot&#x3D;80 参数别名优秀的 cli 工具在参数的解析上都支持设置参数名，例如 --version -V 这种常见的形式。实现别名和很简单，只要创建一个别名映射表，然后转化为双向映射即可： const alias = &#123; &#x27;save-dev&#x27;: &#x27;S&#x27;, &#x27;S&#x27;: &#x27;save-dev&#x27;&#125;; 依托于强大的 npm ，我们可以直接使用已有且成熟的额命令行参数解析库，比如 nopt 、mri 、minimist 、yargs-parser 等，其中 mri 解析效率最高， minimist 覆盖参数输入形式最全。 命令行交互在 web 开发中，可以使用 prompt 显示对话框进行交互，在 node 中也有类似的功能 readline ，它提供了 question 和 prompt 方法构建命令行界面。 const readline = require(&#x27;readline&#x27;);const questions = [&#x27;请输入姓名:&#x27;, &#x27;请输入年龄:&#x27;, &#x27;请输入性别:&#x27;];const answers = [];const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout, prompt: questions[0]&#125;);rl.prompt();rl .on(&#x27;line&#x27;, (line) =&gt; &#123; answers.push(line.trim()); while (answers.length === questions.length) &#123; rl.close(); &#125; rl.setPrompt(questions[answers.length]) rl.prompt(); &#125;) .on(&#x27;close&#x27;, () =&gt; &#123; const result = questions .map((v, i) =&gt; v.replace(&#x27;请输入&#x27;, &#x27;&#x27;) + answers[i]) .join(&#x27;，&#x27;) console.log(result); process.exit(0); &#125;); 上面的交互的形式相信每为学习编码的同行都写过，只不过当初我们学习的时候用的 c++，而现在换成了 node.js 。 对于常见的问答形式，我们使用原生的 readline 还可以应付，但是在 cli 中，不仅仅是只有问答形式的交互，还有单项选择、进度条等等，同上文提到参数解析一样，我们也可以借助现有的库去完成，比如 inquirer 、enquirer 、prompts 等等。 在编写 cli 工具的时候，通常选用 tj 大神开发的 commander , 完整的 node.js 命令行解决方案，包含了参数解析、命令行交互等等。 前端脚手架常见功能 通过交互收集用户输入的信息，并创建 package.json 提供 Babel 、TypeScript 、ESLint 、 StyleLint 、CSS 预处理器 这些常见的前端工具 从 github 拉取模板并创建项目 创建项目通过 npm init -y 快速创建 package.json ，在 bin 字段中添加我们要暴露的命令名称，同时为了适配 npm init &lt;initializer&gt; 的形式使用我们的脚手架，我们的项目要以 create 开头，同时在 bin 字段中添加相关脚本 &#123; &quot;name&quot;: &quot;@onlymisaky/create-project&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;bin&quot;: &#123; &quot;@onlymisaky/create-project&quot;: &quot;.bin/create-project.js&quot;, &quot;create-project&quot;: &quot;.bin/create-project.js&quot;, &quot;pj&quot;: &quot;.bin/index.js&quot; &#125;, &quot;author&quot;: &quot;onlymisaky&quot;&#125; .bin&#x2F;create-project.js 负责接收并处理 create-project 传入的参数，调用相关方法创建项目 .bin&#x2F;index.js 则负责处理 pj 命令相关的功能，由于 demo 先对简单所以 pj 和 create-project 的功能相同，只是调用方式不同。 commander这里我们使用上文提到 commander 来注册命令 create-project&#x2F;.bin&#x2F;create-project.js #!/usr/bin/env nodeconst &#123; program &#125; = require(&#x27;commander&#x27;);program .arguments(&#x27;&lt;项目名称&gt;&#x27;) .action((name) =&gt; &#123; require(&#x27;../lib/create&#x27;)(name); &#125;) .parse(); create-project&#x2F;.bin&#x2F;index.js #!/usr/bin/env nodeconst &#123; program &#125; = require(&#x27;commander&#x27;);const pkg = require(&#x27;../package.json&#x27;);program .version(pkg.version) .description(pkg.description) .usage(&#x27;&lt;command&gt; [options]&#x27;);program .command(&#x27;create &lt;项目名称&gt;&#x27;) .description(&#x27;创建一个新项目&#x27;) .action((name) =&gt; &#123; require(&#x27;./../lib/create&#x27;)(name); &#125;);program.parse(); arguments 接收参数，command 注册命令，在执行命令时( action ) 调用 lib&#x2F;create 创建项目。 inquire在 lib&#x2F;create 中通过 inquire 完成用户和脚手脚手架的交互。inquire 的关键用法就是 prompt 函数，该函数接收一个数组，用于依次询问用户需要做哪些事情 prompt 参数介绍 message: 终端显示的消息 name: 答案对用的 key type: 消息类型，常用的类型如下 input&#x2F;number&#x2F;password: 需要用户输入文本 checkbox: 提供一组选项供用户选择(多选) list&#x2F;rawlist: 提供一组选项供用户选择(单选) confirm: 询问用户 是或否 default: 默认值 when: 是否执行该步骤，可以是 bool 值 或函数，由于 prompt 需要一次性所有的操作步骤，而有些步骤是前后连续的，所以需要通过 when 函数的参数（已经获取的答案）来判断是否需要执行该步骤 choices: 当 type 为 list&#x2F;rawlist&#x2F;checkbox 时，需要为此字段配置选项 const answerMap = await inquirer.prompt([ &#123; name: &#x27;name&#x27;, message: &#x27;项目名称&#x27;, type: &#x27;input&#x27;, default: projectName &#125;, &#123; name: &#x27;description&#x27;, message: &#x27;项目描述&#x27;, type: &#x27;input&#x27;, &#125;, &#123; name: &#x27;author&#x27;, message: &#x27;作者&#x27;, type: &#x27;input&#x27;, &#125;, &#123; name: &#x27;features&#x27;, message: &#x27;检查项目所需的功能&#x27;, type: &#x27;checkbox&#x27;, choices: [ &#123; name: &#x27;Babel&#x27;, value: &#x27;babel&#x27;, short: &#x27;Babel&#x27;, link: &#x27;https://babeljs.io/&#x27;, checked: true, &#125;, &#123; name: &#x27;TypeScript&#x27;, value: &#x27;ts&#x27;, short: &#x27;TS&#x27;, link: &#x27;https://www.tslang.cn/&#x27;, &#125;, &#123; name: &#x27;ESLint&#x27;, value: &#x27;eslint&#x27;, short: &#x27;ESLint&#x27;, link: &#x27;https://eslint.org/&#x27;, checked: true, &#125;, &#123; name: &#x27;StyleLint&#x27;, value: &#x27;stylelint&#x27;, short: &#x27;StyleLint&#x27;, link: &#x27;https://stylelint.io/&#x27;, &#125;, &#123; name: &#x27;CSS 预处理器&#x27;, value: &#x27;css-preprocessor&#x27;, short: &#x27;CSS 预处理器&#x27;, &#125; ], &#125;, &#123; name: &#x27;eslint&#x27;, message: &#x27;选择预设的 ESLint 规则&#x27;, when: (answers) =&gt; &#123; return answers.features.includes(&#x27;eslint&#x27;); &#125;, type: &#x27;list&#x27;, choices: [ &#123; name: &#x27;ESLint with error prevention only&#x27;, value: &#x27;base&#x27;, short: &#x27;Basic&#x27; &#125;, &#123; name: &#x27;ESLint + Airbnb config&#x27;, value: &#x27;airbnb&#x27;, short: &#x27;Airbnb&#x27; &#125;, &#123; name: &#x27;ESLint + Standard config&#x27;, value: &#x27;standard&#x27;, short: &#x27;Standard&#x27; &#125;, &#123; name: &#x27;ESLint + Prettier&#x27;, value: &#x27;prettier&#x27;, short: &#x27;Prettier&#x27; &#125;, ], &#125;, &#123; name: &#x27;stylelint&#x27;, message: &#x27;选择预设的 StyleLint 规则&#x27;, when: (answers) =&gt; &#123; return answers.features.includes(&#x27;stylelint&#x27;); &#125;, type: &#x27;list&#x27;, choices: [ &#123; name: &#x27;StyleLint with error prevention only&#x27;, value: &#x27;base&#x27;, short: &#x27;Basic&#x27; &#125;, &#123; name: &#x27;StyleLint + Standard config&#x27;, value: &#x27;standard&#x27;, short: &#x27;Standard&#x27; &#125;, ], &#125;, &#123; name: &#x27;git&#x27;, message: &#x27;是否创建 git 仓库&#x27;, type: &#x27;confirm&#x27;, default: true, &#125;, &#123; name: &#x27;git-msg&#x27;, message: &#x27;git message&#x27;, type: &#x27;input&#x27;, when: (answers) =&gt; &#123; return answers.git; &#125;, default: &#x27;initial project&#x27;, &#125;]);console.log(answerMap); 该函数会返回一个 promise ，参数是用户输入的所有答案，我么接下来要做的就是分析答案执行创建 package.json 、下载模板、配置项目等等事情了。 &#123; name: &#x27;my-project&#x27;, description: &#x27;pj创建的项目&#x27;, author: &#x27;onlymisaky&#x27;, features: [&#x27;babel&#x27;, &#x27;ts&#x27;, &#x27;eslint&#x27;, &#x27;stylelint&#x27;, &#x27;css-preprocessor&#x27;], eslint: &#x27;airbnb&#x27;, stylelint: &#x27;standard&#x27;, git: true, &#x27;git-msg&#x27;: &#x27;initial project&#x27;&#125; 生成项目模板方案一般生成项目都是采用以现有的模板为基础，同时解析用户输入的答案创建用户想要的初始化项目。CLI 提供了多样化配置，我们不可能编写 n 多份模板，常规做法是编写一份功能配置完善的模板，借助模板引擎来时先多样化配置，常用的模板引擎有 ejs 、handlebarsjs &#123;&#123;#eslint&#125;&#125;const createLintingRule = () =&gt; (&#123; test: /\\.(js|vue)$/, loader: &#x27;eslint-loader&#x27;, enforce: &#x27;pre&#x27;, include: [resolve(&#x27;src&#x27;), resolve(&#x27;test&#x27;)], options: &#123; formatter: require(&#x27;eslint-friendly-formatter&#x27;), emitWarning: !config.dev.showEslintErrorsInOverlay &#125;&#125;)&#123;&#123;/eslint&#125;&#125; 也需要考虑模板的存放位置，对于简单且不常更新的模板，可以随 CLI 一起打包发布至 npm ，而稍微复杂一点的还是建议将模板和 CLI 分开，因为放在一起有一个明显的缺陷，当模板需要更新的时候，即使是更新一个依赖这种和 CLI 毫无关系的操作，也要被迫的提升 CLI 的版本号，增加用户的使用负担。所以模板一般都存放在远程，比如 github ，然后借助 download-git-repo 下载到本地。 在模板下载并解析完成后，就需要将文件写入到项目中，可以使用 fs.writeFile ，也可以使用 metalsmith ，不过要考虑边界值得情况，比如文件是否已经存在，删除原有文件等等。 插件方案模板的方案也有明显的缺陷，就是模板需要增加新功能时，需要在原有基础上做修改，随着不断的迭代，模板会变得越来越复杂。可以采用 vue-cli3 的插件方案解决该问题，模板只提供最小最基础的功能，其余的功能皆交给插件方案，比如 @vue&#x2F;cli-plugin-babel 只负责 babel 相关的功能，而插件的实现其实和模板方案差不多，都是读写文件，编译模板之类的。这样做既方便维护和扩展，也避免了去修改一份庞大的模板项目。 自动执行命令在项目创建完成之后，需要执行一些常规的初始化命令， 比如 git init 初始化 git 仓库； npm install 安装依赖等等，我们可以使用 node 内置的 process.exce 或者使用 shelljs 之类包来完成。 优化体验虽然 CLI 是运行在一个简陋的终端里面，但我们也要尽可能的提升 CLI 的使用体验，比如： 使用 chalk ，对不同类型的提示设置不同的颜色 在需要等待的操作过程中，使用 ora 让命令行输出 loading ，或使用 progress 显示进度条 使用 boxen 在命令行中花去 boxes 区块 编写通俗易懂、完善的usage 没有提到，也很重要 编写 cli 要考虑在不同平台的兼容性问题 命令要避免和常见的命令冲突 考虑到可扩展性","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://onlymisaky.github.io/tags/node/"},{"name":"cli","slug":"cli","permalink":"http://onlymisaky.github.io/tags/cli/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://onlymisaky.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"前端脚手架","slug":"前端脚手架","date":"2021-08-17T06:44:17.000Z","updated":"2024-09-11T03:04:29.054Z","comments":false,"path":"2021/08/17/","permalink":"http://onlymisaky.github.io/2021/08/17/","excerpt":"","text":"前端脚手架&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 什么是 CLI—-分段—- CLI (Command Line Interface) ，顾名思义是一种通过命令行来交互的工具或者说应用。前端常用的 CLI 有 @angular&#x2F;cli 、 @vue&#x2F;cli 、 create-react-app 。 它们可以帮助开发者减少低级重复劳动，专注业务提高开发效率，规范 develop workflow。 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 为什么要用 CLI—-分段—- 我们可以将工作中繁杂、有规律可循、或者简单重复劳动的工作用 CLI 来完成，只需一些命令，快速完成简单基础劳动。现有工作中的可以用 CLI 完成的工作有： —-分段—- 快速生成应用模板，创建 module 模板文件 服务启动，如 ng serve eslint ，代码校验 自动化测试 编译build 总体而言就是一些快捷的操作替代人工重复劳动，提升开发效率。 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 与 npm scripts 相比—-分段—- npm scripts 也可以实现开发工作流，通过在 package.json 中配置 scripts 字段，执行相关命令，但 CLI 与 npm scripts 相比仍有自己优势： —-分段—- npm scripts 只能在项目中使用， CLI 可以全局，到处使用 npm scripts 与业务耦合度高，而 CLI 可以和业务代码剥离 CLI 可以单独迭代开发，改进原有功能，增加新特性 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; package.json&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; name 只能是小写字母、数字、~、-、_ 这些内容 不支持空格，使用连字符区分多个单词 支持 scope ，以 @name&#x2F; 开头，不过该形式的包托管到npm是收费的 (just 7$) —-分段—- npm init &lt;initializer&gt; npm init react-app project-namenpm init vite@latest my-vue-app --template vue —-分段—- npx create-react-app project-name 等同于npm i create-react-appcreate-react-app project-name —-分段—- 命令 等同 npm init foo npx create-foo npm init @user&#x2F;foo npx @user&#x2F;create-foo npm init @user npx @user&#x2F;create &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; bin指定内部命令所对应可执行文件的位置 —-分段—- —-分段—- &#123; &quot;bin&quot;: &#123; &quot;vue&quot;: &quot;bin/vue.js&quot; &#125;&#125; #!/usr/bin/env node &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; scriptsNode.js 在设计 npm 之初，允许开发者在 package.json 文件中，通过 scripts 字段来自定义项目的脚本。 —-分段—- &#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;node ./build.js&quot;, &quot;start&quot;: &quot;node ./server.js&quot; &#125;&#125; npm run buildnpm run build —-分段—- 有些命令是不需要加 run 的，比如 npm start 、npm test 、 npm lint 使用 &amp; 符号并行执行多个 npm scripts ，使用 &amp;&amp; 符号串行执行脚本 —-分段—- npm script 也是有钩子，分别是 pre 和 post ，对应执行前和执行后 &#123; &quot;scripts&quot;: &#123; &quot;prebuild&quot;: &quot;eslint&quot;, &quot;build&quot;: &quot;node ./build.js&quot;, &quot;postbuild&quot;: &quot;npm start&quot;, &quot;start&quot;: &quot;node ./server.js&quot; &#125;&#125; —-分段—- 可以通过 process.env.npm_** 来获取一些值 process.env.npm_lifecycle_event 获取正在运行的脚本名称 process.env.npm_package_** 获取 package.json 相关字段的值 process.env.npm_config_argv 获取参数 —-分段—- npm scripts 原理 在执行 npm run xx 的时候会自动根据不同平台创建一个 shell ， 类 UNIX 中代指 &#x2F;bin&#x2F;sh ，Windows 中使用的是 cmd.exe ， npm scripts 脚本就在这个新创建的 shell 中被运行。 —-分段—- 只要是 shell 可以运行的命令，都可以作为 npm scripts 脚本 npm 脚本的退出码，也自然遵循 shell 脚本规则 如果系统里安装了 Python ，可以将 Python 作为 npm scripts npm scripts 脚本可以使用 shell 的通配符等常规能力 { “scripts”: { “lint”: “eslint **&#x2F;*.js” } } —-分段—- npm scripts 与 shell 的不同之处 npm scripts 创建出来的 shell 会将当前目录的node_modules&#x2F;.bin 子目录加入 PATH 变量中，执行完成后，再将 PATH 变量恢复。 &#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot; &#125;&#125; 等同于 &#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;./node_modules/.bin/webpack&quot; &#125;&#125; &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; npm link&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 命令行参数npm run serve --prot=80node serve.js prot=80 —-分段—- Unix 风格：前面加 -， 后面跟的是单个字符，例如 ls -l , ls -al 则相当于 ls -a -l； GNU 风格：前面加 – ，例如上面的 npm run serve –prot&#x3D;80 BSD 风格：前面不叫任何修饰符 例如上面的 node serve.js prot&#x3D;80 —-分段—- 参数别名 –version -V const alias = &#123; &#x27;save-dev&#x27;: &#x27;S&#x27;, &#x27;S&#x27;: &#x27;save-dev&#x27;&#125;; —-分段—- nopt 、mri 、minimist 、yargs-parser 等，其中 mri 解析效率最高， minimist 覆盖参数输入形式最全。 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 命令行交互 —-分段—- const readline = require(&#x27;readline&#x27;);const questions = [&#x27;请输入姓名:&#x27;, &#x27;请输入年龄:&#x27;, &#x27;请输入性别:&#x27;];const answers = [];const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout, prompt: questions[0]&#125;);rl.prompt();rl .on(&#x27;line&#x27;, (line) =&gt; &#123; answers.push(line.trim()); while (answers.length === questions.length) &#123; rl.close(); &#125; rl.setPrompt(questions[answers.length]) rl.prompt(); &#125;) .on(&#x27;close&#x27;, () =&gt; &#123; const result = questions .map((v, i) =&gt; v.replace(&#x27;请输入&#x27;, &#x27;&#x27;) + answers[i]) .join(&#x27;，&#x27;) console.log(result); process.exit(0); &#125;); —-分段—- 常用的 CLI 交互库有 inquirer 、enquirer 、prompts 、 commander &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 前端脚手架常见功能—-分段—- 通过交互收集用户输入的信息，并创建 package.json 提供 Babel 、TypeScript 、ESLint 、 StyleLint 、CSS 预处理器 这些常见的前端工具 从 github 拉取模板并创建项目 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 兼容 npm init &#123; &quot;name&quot;: &quot;@onlymisaky/create-project&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;bin&quot;: &#123; &quot;@onlymisaky/create-project&quot;: &quot;.bin/create-project.js&quot;, &quot;create-project&quot;: &quot;.bin/create-project.js&quot;, &quot;pj&quot;: &quot;.bin/index.js&quot; &#125;, &quot;author&quot;: &quot;onlymisaky&quot;&#125; &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; // create-project/.bin/create-project.js#!/usr/bin/env nodeconst &#123; program &#125; = require(&#x27;commander&#x27;);program .arguments(&#x27;&lt;项目名称&gt;&#x27;) .action((name) =&gt; &#123; require(&#x27;../lib/create&#x27;)(name); &#125;) .parse(); —-分段—- // create-project/.bin/index.js#!/usr/bin/env nodeconst &#123; program &#125; = require(&#x27;commander&#x27;);const pkg = require(&#x27;../package.json&#x27;);program .version(pkg.version) .description(pkg.description) .usage(&#x27;&lt;command&gt; [options]&#x27;);program .command(&#x27;create &lt;项目名称&gt;&#x27;) .description(&#x27;创建一个新项目&#x27;) .action((name) =&gt; &#123; require(&#x27;./../lib/create&#x27;)(name); &#125;);program.parse(); —-分段—- arguments 接收参数 command 注册命令 在执行命令时( action ) 调用 lib&#x2F;create 创建项目。 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; prompt —-分段—- message name type default when choices —-分段—- &#123; name: &#x27;my-project&#x27;, description: &#x27;pj创建的项目&#x27;, author: &#x27;onlymisaky&#x27;, features: [&#x27;babel&#x27;, &#x27;ts&#x27;, &#x27;eslint&#x27;, &#x27;stylelint&#x27;, &#x27;css-preprocessor&#x27;], eslint: &#x27;airbnb&#x27;, stylelint: &#x27;standard&#x27;, git: true, &#x27;git-msg&#x27;: &#x27;initial project&#x27;&#125; &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 生成项目—-分段—- 模板解析 ejs handlebarsjs &#123;&#123;#eslint&#125;&#125;const createLintingRule = () =&gt; (&#123; test: /\\.(js|ts|tsx)$/, loader: &#x27;eslint-loader&#x27;, enforce: &#x27;pre&#x27;, include: [resolve(&#x27;src&#x27;), resolve(&#x27;test&#x27;)], options: &#123; formatter: require(&#x27;eslint-friendly-formatter&#x27;), emitWarning: !config.dev.showEslintErrorsInOverlay &#125;&#125;)&#123;&#123;/eslint&#125;&#125; —-分段—- 本地模板 or 远程模板 —-分段—- 生成文件 fs.writeFile metalsmith —-分段—- 插件方案提供一份最小模板，其余功能交由插件实现 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 执行命令 require(‘child_process’).exce shelljs &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 优化体验—-分段—- chalk 使终端输出彩色文案 ora 让命令行显示loading progress 进度条 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 没有提到，也很重要—-分段—- 考虑平台兼容性 命令要避免和常见的命令冲突 可扩展性","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://onlymisaky.github.io/tags/node/"},{"name":"cli","slug":"cli","permalink":"http://onlymisaky.github.io/tags/cli/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://onlymisaky.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"扬帆起航","slug":"扬帆起航","date":"2021-02-11T08:25:17.000Z","updated":"2024-09-11T03:04:29.058Z","comments":true,"path":"2021/02/11/","permalink":"http://onlymisaky.github.io/2021/02/11/","excerpt":"","text":"Hi, boys: 进入大学已经有一学期了，你们也对期盼已久的大学生活有了一些自己的体验与感悟了吧。这样的生活是否满足你们当初对大学的期许呢？ 作为一个已经离开校园很久，且有这许多遗憾的人，我想以一个失败的过来人和你们聊聊大学生活。 学习 首先要聊的话题，肯定是关于学习。你们肯定也已经感受到了，在这里学习全靠自觉或压力的驱动(比如为了考试不挂科)，不知你们是属于哪种呢？ 其实学习这个话题可以展开聊很多很多，比如学习效率，学习方法，学习计划等等。但没有万能的方法，只有适合的方法，因此我给不了你们太多的建议，只能靠你们自己结合自身的情况去探索属于自己的最佳方法，这将会受益终身。我指的包括但不仅限于文化知识，专业知识。 由于我自己就是个学渣，所以对你们的期许就是 不要挂科 ，再稍微提高一点要求的话，就是可以轻轻松松的通过所有的学业考试，而不是每次考试前，到处求神拜佛，或是临时抱佛脚熬夜复习(也可能是预习)。当然我更希望你们 成绩可以在本专业进入前20%、前15% 。因为好的成绩不仅仅是学习能力的体现，也会成为你第一份简历上的谈资，更能给你带来更多的机会。 规划 谈到学习，不可避免的就要提及目标规划。先问一个问题，你们有想过为什么要读书吗？不管曾经是否想过这个问题，你们都已经在这条路上走了很久很久了，现在真的该考虑下一步的计划了。有了目标，你走的每一步都会更加沉稳。我见过太多太多临近毕业的人不知所措的学子，好像一个无力的孩子突然被推向了一群陌生人之中，彷徨无助。以我个人的经验，最好先提升学历(考研大三准备，专转本大二准备)，这是一个性价比极高的短期目标，至于更长远的需要你们自己去思考。但从功利的角度出发，可以面向招聘规划，没事可以多刷一些求职类App(boss直聘，拉钩等等)，看看用人单位到底需要什么样的人才，为了符合要求自己又能做哪些事情。我也有一个最低要求， 不要快毕业的时候，还去问简历该怎么写。 社交 我相信你们不止一次的听到过 大学就是一个小社会 这样的话。但实际上大学不只是一个小社会，它就是一个社会。在这里真的可以遇到形形色色的人，有时候要考虑到一些人情世故，也不能再用高中时候的那种思维去思考问题。这里我只讲一下如何交朋友。 如果我没猜错的话，一般情况下你们在大学里最好的朋友应该就是舍友了。但是这并不是主动选择的结果，只是巧了被分到了一个宿舍，每天接触的时间多了就成了好朋友。我并不是说这没什么不好，能分到一个宿舍也是一种缘分。但当如果你发现，和其相处起来并不是很融洽，甚至需要迁就的时候，这种所谓的友谊真的没必要维持下去，但是为了同宿舍之间不那么尴尬，表面关系还是要做到的。当然这种极端的情况并不会真的就发生在你们的身上，至于平时小的摩擦，男孩子嘛，有什么事就拿到明面上出来说，谁的错谁来认。 不过我还是建议你们有目的性的交友，交一群可以一起上进的朋友，交一群有共同爱好的朋友，如果你的朋友都只是聊天吃饭玩乐而已，在我看来这不算是友谊，只是关系较好的熟人。其实在人际交往方面，我也很失败，由于性格慢热，天生宅的属性，我的朋友圈也很小，只有高中同学和大学舍友两个圈子。去年(2020)有一段时间我也为此苦恼过，想认识更多的朋友，但是后来也都习惯了，学会了和自己相处。如果你们在社交上有什么问题，可以向我倾诉倾诉，可能帮不上大忙，至少吐吐苦水也是一种减压的方式。 恋爱 爱情是一种可遇不可求的美妙感觉，如果遇到心仪的女孩，就勇敢的去追求吧，大大方方一些，不要扭扭捏捏，没有女孩会看上比自己还腼腆的男生。如果有了女朋友，怎么相处是你们自己的事情，但身为一个男生，有两点一定要做到： 充分尊重女孩子的想法，不要大男子主义 有担当，必要时候做好安全措施，你们承担不起后果 再唠叨一下，如果不是真的喜欢、不是真心的，一个人其实也很好。不要因为别人的怂恿，不要被不谈恋爱，就不是完整的大学之类的言论所蒙骗。 再唠叨一句，尽早的和对方交换一下个人的价值观、家庭观念，不要等到出现问题，才发现彼此是多么的不合适。 自我认知 &amp; 信仰 &amp; 梦想 这是一个很长，很哲学，很深，也很无聊的话题。每天为了生活奔波的时候，根本无心思考这些。当衣食无忧的时候，就开始寻求自我价值。我是一个怎样的人，我为什么要存在于世。 二十岁之前，我们都在上学，有许许多多的同龄人并肩走着同样的路，年轻的身体里蕴藏着无限的活力，甚至有些年少轻狂，为数不多的烦恼，也就是来自学校和家长的压力。毕业之后可能会突然发现，身边的人越来少，生活从一群人变成了一个人。孤独、迷茫、困惑，终于熬过了这几年，又到了成家立业的时候，生活被动的进入了下一个篇章。这中间有多少决定是自己选择的，一路上又丢弃了多少想法与梦想，向现实低了多少次头，普通人的一生真的太像了。普通没什么，但某个失意的深夜，回想起曾经的时候，心中的不甘和叹息会灼烧你的心。如果可以，保持真我，守住初心。 其它 兼职、社团之类不是必须的。 多看书，我的说的不是电子书和网络小说之类的垃圾文学。 培养一个可以让自己一想到就觉得生活很有期待的兴趣爱好。 不要抽烟。 少熬夜，少熬夜，少熬夜。","categories":[],"tags":[]},{"title":"聊聊vue中的依赖注入","slug":"聊聊vue中的依赖注入","date":"2020-11-17T08:08:26.000Z","updated":"2024-09-11T03:04:29.074Z","comments":true,"path":"2020/11/17/","permalink":"http://onlymisaky.github.io/2020/11/17/","excerpt":"","text":"Vue 的组件通信方式开篇先俗套一下，在 Vue 中，组件间的通信有以下几种方式: prop作用: 父组件向子组件传值，单向数据流 $emit $on作用: 子组件发布事件，父组件订阅事件 vuex作用: 集中数据管理，数据共享 Event Bus作用: 作为全局事件池，发布订阅事件 ref作用: 通过ref获取子组件的引用(实例)，不是响应式的 $attrs $listeners作用: 获取父作用域中除了 props 中声明的属性( class 和 style 也不包含在内) 和 事件( .native 除外) $parent $children作用: 获取当前组件的父实例和所有子实例(非响应式) $root作用: 获取当前组件数的根实例，实际上和 vuex 有相似之处 provide inject作用: 依赖注入，将当前组件的方法和数据注入的子组件中，可以跨层级，非响应式 封装组件的方式与目的进入正题，通常情况下在设计一个组件的时候，我们会习惯性的将组件中的部分状态设计成 props 。以一个简单的 button 组件为例: const ButtonBase = &#123; name: &#x27;ButtonBase&#x27;, props: &#123; type: &#123; type: String, defualt: &#x27;default&#x27;, &#125;, size: &#123; type: String, defualt: &#x27;small&#x27;, &#125;, disabled: &#123; type: Boolean, defualt: false, &#125;, &#125;, template: &#x27;...&#x27;&#125;; 常用的事件则会通过 $emit 派发事件，例如 $emit(&#39;click&#39;, $event) 。如果还有更多不重要的属性和事件时，或者所写的组件只是对另一个更底层的组件进行包装(高阶组件)，就可以直接使用 v-bind=&quot;$attrs&quot; 和 v-on=&quot;$listeners&quot; 来进行事件和数据的绑定。 以上的这种思路，可以 cover 大部分的场景，但当涉及到双向数据流或非父子组件传值的时候，大家的方式就开始奔放起来了，常见的方式大概是以下几种: ref veux Event Bus 借助这些方式几乎所有的场景都可以解决了，那我们再进入具体的场景分析一下。 首先想一下为什么需要封装组件？ 为了复用 我猜你已经抢答了，但事实上除了组件库和项目中的基础组件，我们所写的业务组件几乎都不会有复用的场景，那我们在写业务代码的时候，为什么还要封装呢？ 为了代码的可维护性和可读性 机智的你又回答对了，确实如此，作为一个平淡无奇的打工人，在封装代码的时候，一开始都是从可复用的角度出发，最后发现根本没有太多可复用的场景，甚至只用到一次，那我们封装的作用剩下了一个: 可维护性。 业务组件的拆分站在 可维护性 这个角度再去思考组件该如何封装，以下面的原型图和需求为例，你会如何拆分组件？ 上半部分为表单，用于写处方 下半部分为表格，用于展示历史处方 写处方和获取历史处方都需要一个 patientId ，从路由中获取 处方提交完成之后，下方历史处方需要同步更新 可以将下方表格中的一条处方复制到上方表单中，方便快速开方 先简单分析一下，上半部分的表单和下半部分的表格功能虽然有耦合，但还是相对独立的，可以拆分为三个组件 Prescription.vue 根组件 PrescriptionAdd.vue 写处方 PrescriptionHistory.vue 历史处方 根组件用于接收路由参数，因为需求中提到写处方和历史处方有一些联动，所以它可能还会承担两个兄弟组件间的通信作用。 写处方组件有一部分独立的功能，那就是提交处方表单。需要联动的功能则是提交完成后通知历史处方组件更新数据。 历史处方组件的独立功能是拉取展示历史数据，需要联动的功能是将一行数据复制发送给写处方组件。 每个组件的独立功能都比较简单，具体代码不予赘述。我们直接探讨需要联动的部分如何去实现。 第一个要探讨的点是路由中的参数 patientId 如何传递。最简单暴力的方式就是随用随取了: this.$route.params.patientId 。但是很明显，作为一个稍微有一点点追求的人，都不会用这种方式，因为耦合度太高了，所以我们选择通过路由组件传参的方式将 patientId 以 prop 的方式传递给根组件。然后再继续通过 prop 的方式将其传递给写处方和历史处方组件。 我们再考虑的长远一些，随着业务的不断增长需求也不断变化，有可能写处方和历史处方两个组件也会变成类似根组件一样的容器组件，这样可能又会抽一些组件出去，又要继续将 patientId 向更深层的子组件传递。再极端一点，可能有时候我们为了传递一个 prop 中间隔了很多层组件，而这个 prop 在这些组件却不会被使用到。 那有没有其他方法呢？这里就要引出本文所介绍的 provide&#x2F;inject。两者配合可以跨层级传递数据和方法，ElementUI 的表单组件就大量运用了这个功能，但它有一个明显的缺陷， provide 和 inject 绑定不是响应式的，这是 Vue 故意这样设计的，当然如果传入的是一个可监听对象，那对象的属性还是响应式的。 所以，我们可以用 provide&#x2F;inject 代替 prop 传递数据。这时候你可能会问，通过 provide&#x2F;inject 传递数据，那组件的复用性不就大大降低了吗，因为在使用的时候，必须保证被注入数据的子组件在有同样 provide 的父组件中使用。确实如此，但其实这种担心全是多余的，因为这一原则只适用于业务组件，业务组件的封装主要目的是提升代码的可维护性，也很少有复用的场景，即使有也是一个完整的业务流程，既 provide 和 inject 一定会同时存在。 如果出现了特殊的场景，可能要考虑组件的粒度是否需要更细致一些。当然这种方式千万不要用在基础组件中，比如上文所提到 Button 。 这样一来，我们的三个组件代码类似下面这样: export default &#123; name: &#x27;Prescription&#x27;, // 强烈建议书写Name，方便在devtool调试 props: &#123; // 通过路由组件传参，将路由参数以 prop 方式传递给路由组件 patientId: &#123; type: [String, Number], required: true, &#125;, &#125;, provide() &#123; return &#123; // 通过 provide 将 patientId 注入到子孙后代组件中 patientId: this.patientId, &#125; &#125;,&#125; export default &#123; name: &#x27;PrescriptionHistory&#x27;, // 通过 inject 从父组件获取注入的 patientId inject: [&#x27;patientId&#x27;],&#125; 第二个要解决的问题是，如何解决两个兄弟组件间的数据通信。既在写处方完成之后如何通知历史处方组件更新数据，和如何将历史处方的数据发送到写处方组件中。 有一些经验的开发者可能早就想到用 Event Bus 了。在完成对应的操作之后，将相关的数据通过 Event Bus emit 一个事件发送出去，然后在需要订阅的组件内订阅相关事件，简略的代码大概如下: export default &#123; name: &#x27;PrescriptionAdd&#x27;, methods: &#123; onSubmit() &#123; /** some code */ // 提交表单完成后，发布事件 bus.$emit(&#x27;prescription-add-success&#x27;, this.prescriptionFormList); &#125;, /** 将历史数据转换为表单数据 */ history2From(data) &#123; &#125;, &#125;, mounted() &#123; /** 在生命周期中订阅和取消订阅事件 */ bus.$on(&#x27;copy-prescription&#x27;, this.history2From); this.$once(&#x27;hook:beforeDestroy&#x27;, () =&gt; &#123; bus.$off(&#x27;copy-prescription&#x27;, this.history2From); &#125;); &#125;,&#125; export default &#123; name: &#x27;PrescriptionHistory&#x27;, methods: &#123; onCopy(row) &#123; // 将选中的数据发送出去 bus.$emit(&#x27;copy-prescription&#x27;, row); &#125;, /** * 获取历史处方数据 * 不要怕名字长，一定要做到表意清晰 */ getPrescriptionHistoryList() &#123;&#125;, &#125;, mounted() &#123; /** 在生命周期中订阅和取消订阅事件 */ bus.$on(&#x27;prescription-add-success&#x27;, this.getPrescriptionHistoryList); this.$once(&#x27;hook:beforeDestroy&#x27;, () =&gt; &#123; bus.$off(&#x27;prescription-add-success&#x27;, this.getPrescriptionHistoryList); &#125;); &#125;,&#125; 这种方式实现起来很简单，甚至不需要父组件的参与。但是这就造成了事件满天飞的后果，一堆的 emit(‘xxx’) 这样的魔法自字符串不是很好维护，如果将这些事件名单独维护在一个文件中，又会像 redux 那样罗里吧嗦的。本人是很讨厌这样的模式，甚至因为魔法字符串的问题，我已经在新的项目中放弃了 Vuex 。 如果不用 Event Bus 的方式，还可使用 ref + $emit 的形式，主要思路就是由他们相同的父组件去订阅各自派发出的事件: &lt;PrescriptionAdd ref=&quot;PrescriptionAdd&quot; @prescription-add-success=&quot;onPrescriptionAddSuccess&quot;/&gt;&lt;PrescriptionHistory ref=&quot;PrescriptionHistory&quot; @copy-prescription=&quot;onCopyPrescription&quot;/&gt; export default &#123; name: &#x27;Prescription&#x27;, computed: &#123; PrescriptionAdd: &#123; cache: false, get() &#123; return this.$refs.PrescriptionAdd; &#125;, &#125;, PrescriptionHistory: &#123; cache: false, get() &#123; return this.$refs.PrescriptionHistory; &#125;, &#125; &#125;, methods: &#123; onPrescriptionAddSuccess() &#123; this.PrescriptionHistory .getPrescriptionHistoryList(); &#125;, onCopyPrescription(row) &#123; this.PrescriptionHistory .history2From(row); &#125; &#125;&#125; 这样可以从一定程度上减少事件满天飞情况，但是已经让父组件参与进来了。而且不论是哪一种，两个完整的功能都被分散到三个(或以上的)文件当中。那从站在可维护的角度来说，我们肯定希望相关功能的代码不要被拆的七零八散，写的到出都是。如果能写在一起，不仅对后续的维护者是一种便利，就连 code review 也变得轻松很多。 provide &amp; inject如何将这个功能写在一起呢？这时候就可以用到 provide&#x2F;inject 了。在 Vue 中用 js 写依赖注入有连个很明明显的缺陷: 非响应式 没有一点点的类型提示 这时候我们可以借助 vue-property-decorator 提供的一些装饰器，通过 ts 的方式来写 Vue ，社区中已经有很多很多关于 vue-property-decorator 的介绍了，这里不再便赘述了(安利一下自己写的ppt)。 这里主要使用 ProvideReactive 和 InjectReactive 这两个装饰器。 ProvideReactive&#x2F;InjectReactive 是 provide&#x2F;inject 的反射版本，直白的讲就是让注入的值由非响应变为响应式。 额外补充: ProvideReactive 是将所有被注入数据包装成名称为 __reactiveInject__ 的对象传入子孙组件，子孙组件中 的 InjectReactive 再通过属性计算的方式将 __reactiveInject__ 映射到当前组件中，从而实现数据的同步更新，原理还是利用 当然如果传入的是一个可监听对象，那对象的属性还是响应式的 。 接下来，我们忘记前面所有的，甚至忘记组件封装，原型图长什么样。要做的就是将开处方、查看历史处方、复制处方这些一连串的功能在一个类中实现，业务场景中也可以拆分成多个类，再通过 Mixins 的方式聚合到一起，这样一来我们大概会得到这样一份代码: import &#123; Component, Prop, Vue &#125; from &#x27;vue-property-decorator&#x27;;@Component(&#123; name: &#x27;Prescription&#x27;,&#125;)export default class Prescription extends Vue &#123; @ProvideReactive() @Prop(&#123; type: Number, required: true &#125;) readonly patientId!: number; prescriptionFormList = []; onDelFormItem(index) &#123; &#125; onSubmit() &#123; fetch(&#x27;&#x27;).then(() =&gt; this.getPrescriptionHistoryList()); &#125; prescriptionHistoryList = []; getPrescriptionHistoryList() &#123; &#125; onCopyPrescription(row: any) &#123; this.history2From(row); &#125; history2From(data: any) &#123; const item = &#123; /** */ &#125;; this.prescriptionFormList.push(item); &#125;&#125; 接下来我们再按照最初的思路去拆分并编写组件: @Component(&#123; name: &#x27;PrescriptionAdd&#x27;,&#125;)export default class Prescription extends Vue &#123; @InjectReactive() readonly patientId!: number; prescriptionFormList = []; onDelFormItem(index) &#123; &#125; onSubmit() &#123; &#125;&#125; @Component(&#123; name: &#x27;PrescriptionHistory&#x27;,&#125;)export default class Prescription extends Vue &#123; @InjectReactive() readonly patientId!: number; prescriptionHistoryList = []; getPrescriptionHistoryList() &#123; &#125; onCopyPrescription(row: any) &#123; &#125;&#125; 写到这里就会发现，父组件和子孙组件有很多相同的数据和方法，那就在父组件(根组件)中，为需要注入到子孙组件中的属性加上 @ProvideReactive 装饰器，在子孙组件中相对应的数据上加上 @InjectReactive 装饰器，同时删除细节只保留声明，需要注意的是，虽然通过 Reactive 注入的数据虽然是响应式的，但依旧是单向数据流，所以对子孙组件而言仍旧是只读的，所以需要像 prop 一样加上 readonly 修饰符；需要注入到子孙组件中的方法则加上 @Provide 装饰器，这也可以节省更多的内存开销，修改之后代码如下: @Component(&#123; name: &#x27;Prescription&#x27;,&#125;)export default class Prescription extends Vue &#123; @ProvideReactive() @Prop(&#123; type: Number, required: true &#125;) readonly patientId!: number; @ProvideReactive() prescriptionFormList = []; onDelFormItem(index) &#123; &#125; onSubmit() &#123; &#125; @ProvideReactive() prescriptionHistoryList = []; getPrescriptionHistoryList() &#123; &#125; onCopyPrescription(row: any) &#123; &#125; history2From(data) &#123; &#125;&#125; @Component(&#123; name: &#x27;PrescriptionAdd&#x27;,&#125;)export default class PrescriptionAdd extends Vue &#123; @InjectReactive() readonly patientId!: number; @InjectReactive() readonly prescriptionFormList!: any[]; @Inject() readonly onDelFormItem!: (index) =&gt; void; @Inject() readonly onSubmit!: () =&gt; void;&#125; @Component(&#123; name: &#x27;PrescriptionHistory&#x27;,&#125;)export default class PrescriptionHistory extends Vue &#123; @InjectReactive() readonly patientId!: number; @InjectReactive() readonly prescriptionHistoryList!: any[]; @Inject() readonly getPrescriptionHistoryList!: () =&gt; void; @Inject() readonly onCopyPrescription!: (row: any) =&gt; void; mounted() &#123; this.getPrescriptionHistoryList(); &#125;&#125; 这样我们就把主要的(连续的)逻辑全部塞进了 Prescription 组件当中。这样做的优势不言而喻， code review 简直太爽了，同样代码的可维护性也有一定的提升。 但缺点也很明显: 有太多冗余的声明 部分子孙组件完全弱化成了一个壳子，主要作用也就是模板了 在某些场景下，注入的数据可能会被子孙组件修改，虽然我们可以在父组件中为子孙组件 Provide 修改数据的方法，但还是会显得极为繁琐，比如上文例子中的 prescriptionFormList ，我们需要修改 给药途径, 单次剂量, 数量, 备注。虽然可以直接在子组件内修改(因为是引用类型，是可以直接修改的)，但是这毕竟违背了单向数据流的原则。而且对于浅层次的数据，直接在子孙组件中修改，也会在控制台中抛出错误。 Vue3 中的依赖注入虽有 Vue 中的依赖注入有这些缺点，官方文档中也不推荐使用，但不妨碍它成为一个组织业务代码的大杀器。而且随着 Vue3 的到来，上面的这些缺点也都统统解决了。 Vue3 的组合式 API 为我们提供了 provide 和 inject 这两个方法，它们的作用和 Vue2 的依赖注入相同。但是它们可以将响应式数据 ref 和 reactive 注入到子孙组件中，这意味着我们不需要再用 hack 的方式让注入的值变为响应式，也不用再考虑因单向数据流而带来的复杂更新操作了，再配合上自定义 hook ，也能省去很多繁琐的声明，如果非要确保通过 provide 传递的数据不会被 inject 的组件更改，则可以使用 readonly 方法。 同样是开处方的需求为例，我们用 Composition Api 的方式来实现一下: 首先写一个比较长的 hook ，将所需的业务代码代码组织起来 interface PrescriptionContext &#123; prescriptionFormList: Ref&lt;any[]&gt;; onDelFormItem(index: number): void; onSubmit(): void; prescriptionHistoryList: Ref&lt;any[]&gt;; getPrescriptionHistoryList(): void; onCopyPrescription(row: any): void;&#125;// 通过 InjectionKey 接口提供类型支持const PrescriptionToken: InjectionKey&lt;PrescriptionContext&gt; = Symbol(&#x27;PrescriptionToken&#x27;);export function usePrescriptionProvider(patientId) &#123; const prescriptionFormList = ref([]); function onDelFormItem(index: number) &#123; &#125; function onSubmit() &#123; &#125; const prescriptionHistoryList = ref([]); function getPrescriptionHistoryList() &#123; &#125; function onCopyPrescription(row: any) &#123; &#125; provide(PrescriptionToken, &#123; prescriptionFormList, onDelFormItem, onSubmit, prescriptionHistoryList, getPrescriptionHistoryList, onCopyPrescription, &#125;); onMounted(() =&gt; &#123; getPrescriptionHistoryList(); &#125;);&#125;export function usePrescriptionInject() &#123; const prescriptionContext = inject&lt;PrescriptionContext&gt;(PrescriptionToken); if (!prescriptionContext) &#123; throw new Error(&#x27;usePrescriptionInject must be used after usePrescriptionProvider&#x27;); &#125; return prescriptionContext;&#125; 剩下的工作就是愉快的复制粘贴模板了 defineComponent(&#123; name: &#x27;Prescription&#x27;, props: &#123; patientId: &#123; type: Number, required: true, &#125;, &#125;, setup(props) &#123; usePrescriptionProvider(props.patientId); &#125;,&#125;); defineComponent(&#123; name: &#x27;PrescriptionAdd&#x27;, setup() &#123; const &#123; prescriptionFormList, onDelFormItem, onSubmit, &#125; = usePrescriptionInject(); return &#123; prescriptionFormList, onDelFormItem, onSubmit, &#125;; &#125;,&#125;); defineComponent(&#123; name: &#x27;PrescriptionHistory&#x27;, setup() &#123; const &#123; prescriptionHistoryList, getPrescriptionHistoryList, onCopyPrescription, &#125; = usePrescriptionInject(); return &#123; prescriptionHistoryList, getPrescriptionHistoryList, onCopyPrescription, &#125;; &#125;,&#125;); 这样一番改造之后，有没有发现单文件组件完全沦为了 模板 和 setup 的容器，我们的将所有业务逻辑全都迁移到了自定义 hook 当中，是不是更加清爽了许多，而且还可以利用所学的设计模式，继续魔改我们的 usePrescriptionProvider 。什么？你觉得烦？但这不就是架构师该做的事情么(让别人参照自己的规范编写代码，同时提供周边的工具链)。 webpack 配置工程师是不会的。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://onlymisaky.github.io/tags/vue/"}]},{"title":"Event Loop","slug":"Event Loop","date":"2020-08-28T09:37:00.000Z","updated":"2024-09-11T03:04:28.922Z","comments":true,"path":"2020/08/28/","permalink":"http://onlymisaky.github.io/2020/08/28/","excerpt":"","text":"async function async1() &#123; console.log(&#x27;async1 start&#x27;); await async2(); console.log(&#x27;async1 end&#x27;);&#125;async function async2() &#123; console.log(&#x27;async2&#x27;);&#125;console.log(&#x27;script start&#x27;);setTimeout(function () &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0)async1();new Promise(function (resolve) &#123; console.log(&#x27;promise1&#x27;); resolve();&#125;).then(function () &#123; console.log(&#x27;promise2&#x27;);&#125;)console.log(&#x27;script end&#x27;); script startasync1 startasync2promise1script endasync1 endpromise2setTimeout","categories":[],"tags":[{"name":"自己看","slug":"自己看","permalink":"http://onlymisaky.github.io/tags/%E8%87%AA%E5%B7%B1%E7%9C%8B/"},{"name":"面试题","slug":"面试题","permalink":"http://onlymisaky.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://onlymisaky.github.io/tags/Event-Loop/"}]},{"title":"about me","slug":"about me","date":"2020-08-21T03:47:24.000Z","updated":"2024-09-11T03:04:28.934Z","comments":true,"path":"2020/08/21/","permalink":"http://onlymisaky.github.io/2020/08/21/","excerpt":"","text":"个人介绍 姓名：朱士奇 入职日期：2018年04月20日 担任职位：平台组前端开发 主要职责：HIS, 中控, 正夫HIS… &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 工作经历—-分段—- 江苏楚淮—-分段—- 上海铝神—-分段—- 企鹅杏仁💕💖&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 技术路线 Asp.Net Winform jQuery AngularJs(ng1.x) gulp Vue webpack react,php,hybrid &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 擅长 排查js方面的疑难杂症 爱造小轮子 喜欢追一些新的js技术 oop叛逃者 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 弱项😿 英语极差 css严重退化 移动端技巧几乎荒废 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 谢谢","categories":[],"tags":[]},{"title":"vue-property-decorator","slug":"vue-property-decorator","date":"2020-08-17T03:47:24.000Z","updated":"2024-09-11T03:04:28.942Z","comments":true,"path":"2020/08/17/","permalink":"http://onlymisaky.github.io/2020/08/17/","excerpt":"","text":"vue-property-decorator分享人：onlymisaky &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Why—-分段—- TypeScript—-分段—- 🤔🤔🤔Why TypeScript —-分段—- 😍🤤 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; How—-分段—-options api ![options api](options api.png) —-分段—-Vue.extends —-分段—- —-分段—- 💩💩💩 宁愿不用 —-分段—- 等一等，还有别的办法—-分段—- 借鉴大法！！—-分段—- —-分段—- —-分段—- 或许我们也可以😏…&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; vue-class-component—-分段—- —-分段—- —-分段—- 还是不好用😤😤 —-分段—-&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; @DecoratorAOP（面向切面） 装饰模式 TC39 ECMAScript ----分段---- * Stage 0: strawman（想法）——最初想法的提交。 * Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。 Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。 * Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈 * Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间 ----分段---- - ClassDecorator - PropertyDecorator - MethodDecorator - ParameterDecorator ====分页==== ClassDecorator —-分段—- —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; PropertyDecorator —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; MethodDecorator —-分段—- —-分段—- —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; ParameterDecorator —-分段—- notNull nestjs @Req() @Query @Param()&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Component —-分段—- —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Data Methods Computed Life cycle —-分段—- —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Mixins —-分段—- —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Prop —-分段—- —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; PropSync —-分段—-—-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Model —-分段—-—-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Watch —-分段—-—-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Provide —-分段—- —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Inject —-分段—-—-分段—-&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Emit —-分段—- —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Ref —-分段—- —-分段—- —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; other—-分段—- 增强类型提示src&#x2F;shims-vue.d.ts —-分段—- —-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; VueRouter—-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Vuex—-分段—- vuex-class vuex-module-decorators&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 提问环节 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 愣着干啥，快👏👏👏 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 没有了，别翻了，快去吃饭吧&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 我说的话你就这么不信吗&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 都翻到这里了，原来我在你心里的分量也不错如此，算了你走吧&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 我让你走你就走，你就不知道再多问一下吗，果然你的心里只有吃饭🥺🥺🥺","categories":[],"tags":[]},{"title":"vue3介绍","slug":"vue3介绍","date":"2020-06-30T09:53:25.000Z","updated":"2024-09-11T03:04:29.038Z","comments":false,"path":"2020/06/30/","permalink":"http://onlymisaky.github.io/2020/06/30/","excerpt":"","text":"逻辑复用 在做了一个又一个的xx管理系统后，好像生活变得更枯燥乏味了，逐渐的在一次又一次的复制粘贴中迷失自我。不甘如此的17开寻求新的出口，既然都是在 ctrl+c ctrl+v 那位了不 cv 的更上流一些呢？ 前端的逻辑复用一直是个讨论的热点话题，毕竟程序员都那么懒，懒到连复制粘贴都不想，所以就想尽办法的抽取封装通用的业务逻辑。那什么是业务逻辑呢，从代码层面来讲，就是一些数据( Data )和一些事件、方法( Method )的组合。 比如一个常见的列表页面，他可能会有以下这些数据、事件和方法: searchOptions 用于搜索查询过滤列表的参数 list 列表所展示所需要用到的数组数据 pagination 存储分页信息的数据 getList 用于拉取列表数据的接口调用 onChangePage onSearch onFilter 翻页搜索过滤等事件 所以像状态管理(redux,vuex等)和一些工具方法(表单校验,防抖节流等)都不能算是逻辑复用的方案。 接下来我们先看看当前比较主流的逻辑复用方案都有哪些。 探索MixinMixin 是一种借鉴 OOP 的逻辑复用方式，直觉上来讲，它很像多重继承，但实际上它是组合，将多个方法和属性合并到一个对象中，像 jQuery 中的 $.extend $.fn.extend ，早期的 React 和 Vue2.x 都是通过这种方式来实现逻辑复用的。 React 中的 Mixin const Mixin1 = &#123; getMessage() &#123; return &#x27;hello world&#x27;; &#125;&#125;;const Mixin2 = &#123; componentDidMount() &#123; console.log(&#x27;Mixin2.componentDidMount()&#x27;); &#125;&#125;;const MyComponent = React.createClass(&#123; mixins: [Mixin1, Mixin2], render() &#123; return (&lt;div&gt;&#123;this.getMessage()&#125;&lt;/div&gt;); &#125;&#125;); Vue 中的 Mixin const Mixin1 = &#123; data() &#123; return &#123; list: [] &#125; &#125;, methods: &#123; getList() &#123; return fetchData(this.searchOptions).then(res =&gt; &#123; this.list = res.data; return res; &#125;) &#125; &#125;&#125;const Mixin2 = &#123; created() &#123; console.log(&#x27;Mixin2.created()&#x27;); &#125;&#125;const MyComponent = &#123; mixins: [Mixin1, Mixin2], data() &#123; return &#123; searchOptions: &#123; name: &#x27;&#x27; &#125; &#125; &#125;, mounted() &#123; this.getList(); &#125;&#125;; 为了防止 Minix 的使用不当，React 和 Vue 又对其进行了一些限制和合并策略上的调整，比如在 React 中: 如果 mixins 中有相同的属性会直接抛出异常。 constructor 、render 和 shouldComponentUpdate 也是不允许重复的。 如果有重复的 compoentDidMount 生命周期，会先执行 mixins 中的生命周期，然后再执行组件内的 compoentDidMount； 在 Vue 中: 相同的 data 会保留组件自己的 data 相同的 method 会被封装为一个数组，在调用的时候则会依次执行 mixins 中的 method 组件内的 method 相同的生命周期会合并到一个钩子中，依次执行 mixins 中的钩子，最后执行组件内的钩子 Mixin虽然实现了业务逻辑的复用，但是却有着一些致命的缺陷: 引入了不清晰的依赖关系 Mixin1 可能还会依赖 Mixin2 ， Mixin2 可能还需要组件提供指定的方法，如果某个 Mixin 中的方法修改了，依赖它的 Mixin 可能会无法正常工作。这种复杂的依赖关系在 JavaScript 这种动态类型的语言中，会变成一种心智负担。 导致命名空间的冲突 多个 Mixin 之间可能会存在相同的属性和方法，造成冲突。 滚雪球般的复杂度 Mixin 是侵入式的，改变了原组，和组件之间高度耦合，尤其当依赖多个 Mixin 时，代码将变得难以预测，管理代码的复杂度也会直线上升。 所以 React 很早就宣布放弃了这种方式，当然 Vue 也快了。 HOC(Higher-Order Components)有时候一些英文单词的缩写看起来很唬人， HOC 便是其中之一了。它的中文名叫高阶组件，直白的解释一下，它和高阶函数一样，只不过高阶组件的参数是 Component 返回的也还是 Component ，既: const EnhancedComponent = higherOrderComponent(WrappedComponent);。在 React 放弃 Mixin 之后，HOC 就成为了逻辑复用的推荐方案。 HOC 实现逻辑复用的原理将需要复用的代码抽离到函数中，然后通过 props 将其传递到下层组件当中，实际上就是对下层组件进行了一次包装，其实这就是装饰器模式。所以 HOC 并不算是 React 的一部分，它是一种基于 React 的组合特性而形成的设计模式。我们常用的 react-redux 中的 connect 就是一个高阶组件，它通过 props 将 store 中的 state 以 prop 的方式传递给下层组件。HOC很好的解决的了 Mixin 的缺陷。 React 中的 HOC : function List(&#123; data &#125;) &#123; return ( &lt;ul&gt; &#123;data.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;function withLoadData(WrappedComponent) &#123; return class extends React.Component &#123; state = &#123; data: [] &#125;; componentWillMount() &#123; setTimeout(() =&gt; &#123; this.setState(&#123; data: [ &#123; id: 1, name: &#x27;11&#x27; &#125;, &#123; id: 2, name: &#x27;22&#x27; &#125; ] &#125;); &#125;, 1000); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...this.state&#125; /&gt; &#125; &#125;&#125;export default withLoadData(List); 这是一个很简单的例子， List 组件只负责展示数据，没有任何多余的逻辑，而 withLoadData 则负责加载数据，当然你还可以在写一个 withLoading 来控制组件的 laoding 状态。 在 Vue 很少有提及 HOC 这个概念，可能主要是因为 Vue 是以模板为主要方式，没有 jsx 那样灵活，而且 Vue 的 props 需要显式的定义出来(可以通过 $attrs 绕做)，相对于 React 也多了一个事件的概念(对应 React 中的回调，如 onInput 等，可以用 $listeners 绕过 )。当然你要是想在 Vue 是使用高阶组件也不是不可以，在 React 中 f(Component): NewComponent ，那在 Vue 中就是 f(Options): NewOptions。但是还是极力不推荐在 Vue 中使用 HOC 。同样以上面的场景为例，Vue 中的 HOC: const List = &#123; name: &#x27;List&#x27;, props: &#123; data: &#123; type: Array, required: true, &#125;, &#125;, render() &#123; return ( &lt;ul&gt; &#123;this.data.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; ); &#125;,&#125;;function withLoadData(WrappedOptions) &#123; return &#123; name: &#x27;withLoadData&#x27;, component: &#123; WrappedOptions &#125;, template: `&lt;Wrapped-Options v-on=&quot;$listeners&quot; v-bind=&quot;&#123;data:data, ...$attrs&#125;&quot; /&gt;` data() &#123; return &#123; data: [], &#125;; &#125;, created() &#123; setTimeout(() =&gt; &#123; this.data = [ &#123; id: 1, name: &#x27;11&#x27; &#125;, &#123; id: 2, name: &#x27;22&#x27; &#125;, ]; &#125;, 1000); &#125; &#125;;&#125;export default withLoadData(List); 同样的，HOC 自身也有一些令人不爽的小问题: 扩展性限制，并不能完全替代 Mixin ，例如无法获取子组件的 state 等 Ref 被隔断 静态方法丢失 Wrapper Hell ，一层函数嵌套不够，那就多嵌套几层 性能有一定的影响 hook的诞生介绍完了上面三种逻辑复用的方式，终于轮到 hook 出场了。 假想如前面所提到的，所谓业务逻辑 就是一些数据( Data )和一些事件、方法( Method )的组合。如果抛开框架的束缚，我们能想到最直接、最简单的复用方式就是函数了。我们可以将这些有关联性的 Data 和 Method 都写在一起，然后放在一个函数中。但是有一个问题，如何保证这些 Data 能和 View 进行关联呢？ Class Component 与 Vue 的问题在 React 中，我们可以在类组件中定义 state ，当显式的调用 this.setState 时，state 会发生改变，然后通过 vDOM diff 查找需要更新的区域，最后在更新真实的 DOM 树。如果用我们提到的方法，就遇到了一个问题，如何将这些 Data 和 Method 放进这个组件内，还有 this 指向也会是个不小的阻碍。 在 Vue 中也会遇到同样的问题，我们需要想办法将这些 Data 放进 data 或 computed 这个两个属性中，将 Method 放进 methods 属性中。而且 Vue 也需要考虑 this 指向的问题。 Function Component缺失的功能如果是函数式组件，那就更不好办，函数式组件是没有状态，没有生命周期，他只能接受 props 作为参数，只有当 props 变更时，才会更新对应的 DOM 。所以就更没有办法将 Data 放进函数式组件当中了。 Function Component + Hook不过 React 团队还是想出了办法让函数组件也能拥有自己的状态，且状态更新对应的视图也做出更新。那就是通过指定的方法在函数式组件内部创建和更新 state ： import React, &#123; useState &#125; from &#x27;react&#x27;;function Count() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useState 返回的结果是数组，数组的第一项是 state ，第二项是更新 state 函数，useState 函数的第一个参数就是默认值，也支持回调函数。在上述的例子中 count 和 setCount 分别对应逻辑中的 Data 和 Method 。这样便解决了函数式组件没有自己的状态的问题，为了让函数式组件能有和 class 组件类似的生命周期， react 还提供了 useState 方法。下面就介绍一下 react 中两个常用的 hook 。 React Hook在介绍 React Hook 之前，需要知道以两点规则(限制)： hook 只能在函数式组件中使用 不要在循环，条件或嵌套函数中调用 Hook useStateconst [count, setCount] = useState(0); useState 让函数式组件也能拥有了自己的状态。当需要在组件内部拥有自己的状态时，便可以通过调用 useState 来创建 state变量 ，不过你要遵循上面的两个条件。当你需要多个 state变量 的时候你就需要调用多次，这时候你可能就会遇到控制 state 粒度的问题了。 在传统的 class 组件中，我们是不用关心这个问题的，以 TodoList 组件为例，在 class 组件中，我们会这样写： class TodoList extends React.Component &#123; state = &#123; todoList: [], loading: false, filterText: &#x27;&#x27;, filterType: &#x27;all&#x27;, &#125;; getTodoList() &#123; this.setState(&#123; loading: true &#125;); fetch(&#x27;/todos&#x27;) .then((res) =&gt; res.json()) .then((data) =&gt; &#123; this.setState(&#123; todoList: data, loading: false, &#125;); &#125;) .catch(() =&gt; &#123; this.setState(&#123; loading: false, &#125;); &#125;); &#125;&#125; 但是在使用了 State Hook 之后，我们就要考虑这个问题了： function TodoList() &#123; const [todoList, setTodoList] = useState([]); const [loading, setLoading] = useState(false); const [filterText, setFilterText] = useState(&#x27;&#x27;); const [filterType, setFilterType] = useState(&#x27;all&#x27;); const getTodoList = () =&gt; &#123; setLoading(true); fetch(&#x27;/todos&#x27;) .then((res) =&gt; res.json()) .then((data) =&gt; &#123; setLoading(false); setTodoList(data); &#125;) .catch(() =&gt; &#123; setLoading(false); &#125;); &#125;&#125; 这时候我们已经发现了两个问题了: 函数开始很长一串的声明 state 变量的代码，这还仅仅是一个简单的组件 当需要同时更新多个 state 的时候，无法像 class 组件那样批量更新，而需要依次的去调用对应的 setXxx 方法。 Q: 连续多次调用不同的 setXxx 会触发几次更新呢？ 那可不可以将所有的 state 变量都通过一个 useState 生成呢？当然可以: const [state, setState] = useState(&#123; todoList: [], loading: false, filterText: &#x27;&#x27;, filterType: &#x27;all&#x27;,&#125;); 但是事情并不是像我们想象的那么美好，在 class 组件中， setState 会把更新的字段自动合并到 this.state 对象中。而在 State Hook 中，setXxx 做的是替换操作，所以每当我们需要更新某个 state 的时候，就需要这么写: setState(&#123; ...state, todoList: data, loading: false &#125;) 看起来好像也没什么，但是这样做又引入了新的问题，粒度过粗，代码的可复用性就会降低，也有些违背了 hook api 的初衷 。 所以，在使用 State Hook 的时候，结合业务场景，尽量遵循下面两点: 将完全不相关的 state 拆分为多组 state 如果某些 state 是相互关联的，或者需要一起发生改变，就可以把它们合并为一组 state useEffect已经通过 useState 让函数式组件拥有了自己的状态，那再提供个 hook 让函数式组件也能拥有自己的生命周期，这不算过分吧。这就是 useEffect 的作用就是，但是实际上官方文档中对它的描述却让人有些模糊: Effect Hook 可以让你在函数组件中执行副作用操作 。 OK, 先不着急。先看一下 useEffect 怎么使用: useEffect(() =&gt; &#123; /** * part1 * dosomething */ return () =&gt; &#123; /** * part2 * dosomething */ &#125;&#125;, [ /* part3 依赖的state */]) useEffect 的第一个参数是函数，我们可以在这个函数内发起网络请求、绑定事件、订阅消息、创建定时器、查找操作 DOM 等，这也就是所谓的副作用，对应的就是上述代码中的 part1 。还可以在函数内部再返回一个函数，在该函数内清除上一次副作用遗留下来的状态，比如解绑事件、取消订阅、消除定时器等等。它是可选的，你也可以不返回任何值，这取决你的业务场景，比如你只是在 part1 部分获取数据、记录一些日志，那就完全没必要再多一写一个 return 了。对应上述代码中的 part2 。第三个参数是一个数组，将 part1 和 part2 部分使用到的 state 或 prop 放进这个数组内，接下来我们先分析 useEffect 的执行过程，然后解释为什么需要 part3 。 组件初次 render 的时候执行 part1 组件更新之前执行 part2 组件更新完成后 执行 part1 所以我们可以把 useEffect 当做是 componentDidMount 、 componentDidUpdate 和 componentWillUnmount 的组合。 part1 对应 componentDidMount ， part3 对应 componentDidUpdate 和 componentWillUnmount 。 useEffect 和 useState 一样可以在一个组件内使用多次。这样我们就可以更好的将有关联的代码组织在一起了，但是随之而来就产生了一个问题，来看下面一段代码: function App() &#123; const [count, setCount] = useState(0); const [width, setWidth] = useState(document.body.clientWidth); const onResize = () =&gt; &#123; setWidth(document.body.clientWidth) &#125; useEffect(() =&gt; &#123; window.addEventListener(&#x27;resize&#x27;, onResize, false); return () =&gt; &#123; window.removeEventListener(&#x27;resize&#x27;, onResize, false); &#125; &#125;); useEffect(() =&gt; &#123; document.title = count; &#125;); return ( &lt;div&gt; 页面名称: &#123;count&#125; 页面宽度: &#123;width&#125; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;Click Me&lt;/button&gt; &lt;/div&gt; );&#125; 在上面的代码中，第一个 useEffect 在组件初始时监听 window 的 resize 事件，在组件更新或销毁的时候取消事件绑定；第二个 useEffect 在组件初始和更新的时候修改页面的 title 。 每当 state 或 prop 都会触发函数式组件的更新，所以只要触发了 resize 事件，第二个 useEffect 都会再执行一遍。所以在某些情况下，每次渲染后都 effect 可能会导致性能问题。那 useEffect 的第二参数 DependencyList 便是用来控制何时执行 effect : 在不传 DependencyList 的情况下，每次渲染、更新都会执行 part1 和 part2 在传 DependencyList 的情况下，只有当 DependencyList 中的值发生变化才会执行 part1 和 part2 如果传了空数组，只有在初次渲染和卸载的时候才会执行 part1 和 part2根据上面的规则，我可以对上面的代码做一些优化:useEffect(() =&gt; &#123; window.addEventListener(&#x27;resize&#x27;, onResize, false); return () =&gt; &#123; window.removeEventListener(&#x27;resize&#x27;, onResize, false); &#125;&#125;, []);useEffect(() =&gt; &#123; document.title = count;&#125;, [count]); 自定义 hook仅仅让有函数式组件拥有 state 和生命周期这远远不够，我们要讨论的是逻辑复用，这时候我们就可以用到自定义 hook 。自定义 hook 就是以 use 开头的函数，我们可以在该函数能使用 useState 、 useEffect 等等这些 React 提供的 hook ，还可以在函数内部返回一些 Date 或者 Method 。 Vue Composition API从框架使用者角度而言， Vue3 最大的改动就是从 Options API 表更为 Composition API 。Options API 是一种非常直观的分隔代码的方法， data, computed, watch, methods, lifecycle, 一切看看起来井井有条。但是它也有致命的缺点，比如你在刚写 Vue 的时候是否经常疑惑 this 的指向;当一个组件的代码有数百行，一个简单的功能所对应的代码可能会被分割在了不同的地方，从而变得难以阅读或调试;无法更便捷的使用类型推到，所以在 Vue2 中使用 ts 相对于 ng 和 react 要更麻烦一些;而且这种配置式的 API 注定想要复用逻辑，就只能使用 mixin 的方式。 而且 Vue3 的 Composition API 将上述的问题都统统解决了。为了更直观的对比，我们就一个计数器的例子来展示说明。 &lt;div&gt; &lt;span&gt;count is &#123;&#123; count &#125;&#125;&lt;/span&gt;&lt;br /&gt; &lt;span&gt;plusOne is &#123;&#123; plusOne &#125;&#125;&lt;/span&gt;&lt;br /&gt; &lt;button @click=&quot;increment&quot;&gt;count++&lt;/button&gt;&lt;/div&gt; Vue2 Options API export default &#123; data() &#123; return &#123; count: 0 &#125;; &#125;, computed: &#123; plusOne() &#123; return this.count + 1; &#125;, &#125;, methods: &#123; increment() &#123; this.count += 1; &#125;, &#125;, watch: &#123; count(val, oldVal) &#123; console.log(`oldVal is $&#123;oldVal&#125;`); &#125;, &#125;, mounted() &#123; console.log(&#x27;mounted&#x27;); &#125;,&#125;; Vue3 Composition API import &#123; defineComponent, ref, computed, watch, onMounted, &#125; from &#x27;vue&#x27;;export default defineComponent(&#123; setup() &#123; const count = ref(0); const plusOne = computed(() =&gt; count.value + 1); const increment = () =&gt; &#123; count.value += 1; &#125;; watch(count, (val, oldVal) =&gt; &#123; console.log(`oldVal is $&#123;oldVal&#125;`); &#125;); onMounted(() =&gt; &#123; console.log(&#x27;onMounted&#x27;); &#125;); return &#123; count, plusOne, increment &#125;; &#125;,&#125;); 从上面的例子中我们可以发现 Composition API 已经完全移除了 data, computed, methods, watch, 生命周期等等这些配置项(其实为了兼容 Vue2 并没有移除)，而是提供了 ref/reactive , computed , watch , onMounted 这些方法来代替。新增了 setup 方法，创建响应式数据，业务逻辑也全都移到了 setup 之中。如果需要在模板中访问数据调用方法，只需在 setup 中将相应的数据&#x2F;方法 return 出去即可。 底层主要是从 flow 切换到 typescript ，用 Proxy 取代了 Object.defineProperty ，重构了 Virtual DOM 。 Composition API 在一定程度借鉴了 react hook ，但是实现方式是完全不同的，并且确实解决了 Vue 中逻辑复用和代码组织的问题，同时提供了更好的类型推导。而且 Composition API 相较于 React Hook 使用起来心智负担要很多，所以没必要对 Composition API 有过多的质疑甚至是否定，没人能逃得出真香定论。 setupsetup 是新增的一个组件选项，也是使用 Composition API 的入口点。创建组件实例，然后初始化 props ，紧接着就调用setup 函数。从生命周期钩子的角度来看，它会在 beforeCreate之前被调用。setup 中返回的对象会被合并到模板的渲染上下文中。也可以在 setup 返回一个渲染函数。 它和一些响应式 API ，生命周期钩子组合，代替了之前的 data , computed , methods , watch , 生命周期等。在 setup 中将无法在使用 this 。那当我们需要在 setup 使用到 props 或者一些组件内置的方法(比如 this.$emit )时该怎么办呢？ setup 提供了两个参数，分别是 props 和 context 。 setup(props, ctx) &#123;&#125; props 就是由父组件传递给子组件的 props 。它和 react 中函数式组件的 props 类似，但是不要解构 props 因为那样是让 props 失去响应式特性。 context 则代替了之前的 this 。比如 ctx.attrs , ctx.emit 等等。 Q: 为什么将 props 设计为第一个参数，而不是 context 呢？为什么不将 props 和 context 合并呢？ 响应式 API reactive以一个普通对象为参数，传入的对象会经过 Proxy 包装，返回该对象的响应式代理。它与 Vue2 的 Vue.observable() 用法完和作用完全相同。为了避免和 RXJS 的 observable 混淆，改名为 reactive 。const state = reactive(&#123; name: &#x27;qq&#x27;, age: 18 &#125;); refreactive 可以代理对象，但是如果我们只需要用到一个简单的值类型时，比如上面例子的中 count ，该怎么办呢？一种办法是将 count 包装一次层，用 reactive 创建创建响应式数据 :const state = reactive(&#123; count: 0 &#125;); 另一种方法就是用 ref :const countRef = ref(0);console.log(countRef.value); // 0 ref 返回的也是一个响应式对象，拥有一个指向内部值的单一属性 .value 。为了让我们能方便一些，在模板中使用 ref 的值时是不需要通过有 .value 来获取的。&lt;span&gt;&#123;&#123;countRef&#125;&#125;&lt;span&gt; Q: 那什么时候使用 reactive 什么时候使用 ref 呢？ computedcomputed 函数代替了之前的 computed 选项:const count = ref(1);const user = reactive(&#123; name: &#x27;qq&#x27;, age: 18 &#125;);const plusOne = computed(&#123; get: () =&gt; count.value + 1, set: (val) =&gt; &#123; count.value = val - 1; &#125;,&#125;);const userInfo = computed(() =&gt; `我是$&#123;user.name&#125;，今年$&#123;user.age&#125;岁`); 不过和 Vue2 不同的是， computed 返回的值与 ref 一样是一个 ref 对象。原因是一样的，属性计算就可能会返回一个值类型 plusOne , 也可能会返回一个引用类型 userInfo ，为了保证值类型不丢失内部逻辑关系，那就要像 ref 一样包装一层，为了统一起来， computed 一律返回一个 ref 对象。 watchwatch 与之前的 watch 选项完全相同，当需要监听指定值变化并执行一些逻辑的时候可以使用 watch 。const count = ref(1);const bar = ref(&#x27;bar&#x27;);const user = reactive(&#123; name: &#x27;qq&#x27;, age: 18 &#125;);watch( () =&gt; user, (val, oldVal) =&gt; &#123; console.log(&#x27;user&#x27;, val, oldVal); &#125;, &#123; deep: true, immediate: true &#125;,);watch(count, (val, oldVal) =&gt; &#123; console.log(&#x27;count&#x27;, val, oldVal);&#125;);watch([count, bar], ([currentCount, currentBar], [oldCount, oldBar]) =&gt; &#123; console.log(&#x27;count &amp; bar current: &#x27;, currentCount, currentBar); console.log(&#x27;count &amp; bar old: &#x27;, oldCount, oldBar);&#125;);onMounted(() =&gt; &#123; setTimeout(() =&gt; &#123; user.name = &#x27;pp&#x27;; count.value += 1; bar.value = &#x27;foo&#x27;; &#125;, 3 * 1000);&#125;); 与之前不能的是， watch 现在可以监听多个值了， watch 会返回一个用于停止监听的函数，显式的调用该函数，就可以停止监听: const stop = watch(count, (val, oldVal) =&gt; &#123; &#125;);// 停止监听stop(); Q: 在 Vue2 中如何同时监听多个值呢？ watchEffectwatchEffect 与 wacth 的功能类似，不过它不需要像 watch 那样指明被依赖的数据。const count = ref(1);watchEffect(() =&gt; &#123; document.title = `count is $&#123;count.value&#125;`;&#125;);onMounted(() =&gt; &#123; setTimeout(() =&gt; &#123; count.value += 1; &#125;, 3 * 1000);&#125;); 看着是不是和 React.useEffect 很像。那可不可以和 React.useEffect 一样清除副作用呢？当然可以: const count = ref(1);const onResize = () =&gt; &#123; count.value++;&#125;;watchEffect((onInvalidate) =&gt; &#123; window.addEventListener(&#x27;resize&#x27;, onResize, false); onInvalidate(() =&gt; &#123; window.removeEventListener(&#x27;resize&#x27;, onResize, false); &#125;);&#125;); 那清除副作用的函数 清除副作用会在何时调用呢？ readonly用于创建一个只读的代理对象，参数可以是普通对象、代理对象、或者 refconst count = ref(0);const readonlyCount = readonly(count);const config = readonly(&#123; baseURL: &#x27;/api&#x27;, timeout: 15 * 1000,&#125;);const user = reactive(&#123; name: &#x27;qq&#x27;, age: 18 &#125;);const readonlyUser = readonly(user);onMounted(() =&gt; &#123; count.value++; console.log(&#x27;count.value:&#x27;, count.value); console.log(&#x27;readonlyCount.value:&#x27;, readonlyUser.value); readonlyUser.name = &#x27;pp&#x27;; // 无法修改并且发出警告&#125;); Lifecycle HooksVue3 中新增了一些周期钩子，这钩子只能在 setup 期间同步使用(或者在自定义 hook 中使用，但是自定义 hook 最中还是要在 setup 中使用)。为它们依赖于内部的全局状态来定位当前组件实例（正在调用 setup() 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。 beforeCreate -&gt; 使用 setup() created -&gt; 使用 setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted errorCaptured -&gt; onErrorCaptured 新增 onRenderTracked onRenderTriggered 可以用这个钩子进行调试优化。 响应式系统工具集 isRef()检查一个值是否为一个 ref 对象，其实是通过 __v_isRef 来判断的 toRef()为一个 reactive 对象的属性创建一个 ref 。 toRef() 则可以解决这个问题const user = reactive(&#123; name: &#x27;qq&#x27;, age: 18 &#125;);const userNameRef = toRef(user, &#x27;name&#x27;); // userNameRef.value qq toRefs()把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应。const user = reactive(&#123; name: &#x27;qq&#x27;, age: 18 &#125;);const userRef = toRefs(user);onMounted(() =&gt; &#123; setTimeout(() =&gt; &#123; user.name = &#x27;pp&#x27;; userRef.age.value = 16; console.log(userRef.name.value); // pp console.log(user.age); //16 &#125;, 3000);&#125;); unref()如果参数是一个 ref 则返回它的 value，否则返回参数本身。它是 val = isRef(val) ? val.value : val 的语法糖。 isProxy检查一个对象是否是由 reactive 或者 readonly 方法创建的代理。 isReactive检查一个对象是否是由 reactive 创建的响应式代理。如果这个代理是由 readonly 创建的，但是又被 reactive 创建的另一个代理包裹了一层，那么同样也会返回 true。 isReadonly检查一个对象是否是由 readonly 创建的只读代理。 体验 Composition API npm init vite-app vue-vite vue add vue-next npm i @vue&#x2F;composition-api Vue3的其它改动 : react : useRef useCallback useMemo 自定义hook : useRequest useStorage useDebounce useList useForm useModal","categories":[],"tags":[]},{"title":"vue3介绍-参考","slug":"vue3介绍-参考","date":"2020-06-30T06:53:25.000Z","updated":"2024-09-11T03:04:29.038Z","comments":false,"path":"2020/06/30/","permalink":"http://onlymisaky.github.io/2020/06/30/","excerpt":"","text":"minixs hocReact组件间逻辑复用 React组件逻辑复用的那些事儿（Mixins -&gt; HOC+render props -&gt; Hooks） React Mixin 的前世今生 react 放弃mixins设计模式 react为何移除mixins 为何在React中推荐使用HOC，而不是mixins来实现组件复用。但在Vue中，很少有HOC的尝试？ vue中使用 minix 混入 Vue 进阶必学之高阶组件 HOC 探索Vue高阶组件 React高阶组件实践 React 中的高阶组件及其应用场景 深入浅出React高阶组件 如何理解 React 高阶组件(HOC)? react hook精读《Function Component 入门》 精读《Function VS Class 组件》 精读《React Hooks》 React Hooks简介 函数式组件的崛起 一篇看懂 React Hooks 呕心沥血，一文看懂 react hooks React Hooks完全上手指南 终于搞懂 React Hooks了！！！！！ 专栏，介绍react hook 玩法 React Hooks 你真的用对了吗？ 一起围观由React Hooks防抖引发的面试翻车现场 30分钟精通React Hooks React Hooks 最佳实践 React系列-轻松学会Hooks(中) 15 个很有用的自定义 React Hooks 10分钟教你手写8个常用的自定义hooks 请教：是否更推荐model数据细粒度化？ React useEffect的陷阱 react-use-localstorage React Hooks(二): useCallback 之痛 Vue Composition API精读《Vue3.0 Function API》 Vue Composition API 深入理解 Vue3 Reactivity API Vue3 究竟好在哪里？（和 React Hook 的详细对比） 一份vue3-beta相关文集前来报告，请您收下 40行代码把Vue3的响应式集成进React做状态管理 vue 3.x 如何有惊无险地快速入门 [实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香 React Hooks 是否可以改为用类似 Vue 3 Composition API 的方式实现？(https://www.zhihu.com/question/378861485/answer/1125724740) Vue 3.0 全家桶抢先体验 从 0 到 1 实现 useAxios 逻辑复用 Mixin HOC render prop class Component 和 Fuction Component 各自缺陷 hook 诞生 Vue Composition API 介绍和用法 React Hook 与 Vue Hook 对比 用 Vue Hook 造一些轮子","categories":[],"tags":[]},{"title":"Hello RxJS","slug":"Hello-RxJS","date":"2020-05-12T10:47:05.000Z","updated":"2024-09-11T03:04:28.922Z","comments":true,"path":"2020/05/12/","permalink":"http://onlymisaky.github.io/2020/05/12/","excerpt":"","text":"这次来介绍一下 RxJS ，不会过于深入的讲解，因为我自己也是个半吊子，本文旨在让你对 RxJS 有个整体的认识，并能够体会到 RxJS 在部分场景下的优势。 读过我之前的文章应该能了解到，我在介绍一些此类内容的时候，喜欢用 Why 、 What 、 How 这样的方式。不过这次可能要换一种方式了，因为在我看来 RxJS 更多的是一种思维方式的转变，就像在前端没有出现 MV* 框架之前，我们的思维还是拿着数据去更新DOM，而有了这些框架，操作 DOM 的思维方式已经逐渐被替代掉了。 首先我们来看一个例子，给定一个数组 [1, &#39;qq&#39;, 3, &#39;奇奇&#39;, 17, &#39;77&#39;] 将数组中的数字乘以2然后再相加求和，你可能会很快想到下面的解法： const arr: Array&lt;string | number&gt; = [1, &#x27;qq&#x27;, 3, &#x27;奇奇&#x27;, 17, &#x27;77&#x27;];let sum = 0;for (const item of arr) &#123; const n = parseInt(item as string, 10); if (!Number.isNaN(n)) &#123; sum += n * 2 &#125;&#125; 代码很简单，但是可读性就差了很多，我们再用函数式编程的方式改造一下： let sum = arr .map(n =&gt; parseInt(n as string, 10)) .filter(n =&gt; !Number.isNaN(n)) .map(n =&gt; n * 2) .reduce((prve, current) =&gt; prve + current) 第一种方式叫命令式，而第二种则叫声明式。从命令式到声明式，便是一种思维模式的转换。同样的例子还有 SQL 和 ORM。我们通过仔细观察可以发现，在命令式编程中，我们是迫不及待，想尽一切办法的想要得到最终的结果。而在声明式中，我们则是通过一系列的转化，有条不紊的得到最终结果。那这个例子和我们要介绍的 RxJS 又有什么关系呢？请再次阅读我对声明式的评价并理解它，那在接下来的内容中，你就能很好的理解 RxJS 了。 首先简单介绍 RxJS 的由来。2012年微软提出并开源了 ReactiveX(Reactive Extensions) 编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。目前已有 c#、c++、java、JavaScript等多个版本实现。而 RxJS 则是 ReactiveX 的 JavaScript 版本。ReactiveX 有三个非常重要的特点: 观察者模式、Iterator、函数式编程。 https://www.zhihu.com/topic/20036245/top-answershttps://blog.techbridge.cc/2017/12/08/rxjs/https://mcxiaoke.gitbooks.io/rxdocs/content/Intro.htmlhttps://rxjs-cn.github.io/learn-rxjs-operators/https://zhuanlan.zhihu.com/p/23331432https://www.jianshu.com/p/5d01341599e9https://segmentfault.com/a/1190000012252368https://zhuanlan.zhihu.com/p/23331432https://www.jianshu.com/p/16be96d69143 ObservableObserver 操作符分类","categories":[],"tags":[]},{"title":"最近零减一","slug":"最近零减一","date":"2020-04-30T12:44:53.000Z","updated":"2024-09-11T03:04:29.058Z","comments":true,"path":"2020/04/30/","permalink":"http://onlymisaky.github.io/2020/04/30/","excerpt":"","text":"刚过去的一个季度，不是很顺畅。生病了一段时间，加上对疫情的恐惧，很长一段时间里身心都处于一种不正常状态，感情生活也是很糟糕。种种叠加在一起，所以经常陷入人生哲学问题的思考之中，虽然曾经也会这样，不过那时毕竟有“年轻”二字在撑腰。 我觉得我们义务教育中应该加入情绪管理这样一门课程，旨在引导人们如何合适释放自己的情绪，不至于像我这样在此刻用文字胡乱呻吟~~~~ 下一篇见，下一篇会是rxjs吧，对吧","categories":[],"tags":[]},{"title":"我在锤桌子","slug":"我在锤桌子","date":"2020-01-02T12:15:52.000Z","updated":"2024-09-11T03:04:29.058Z","comments":true,"path":"2020/01/02/","permalink":"http://onlymisaky.github.io/2020/01/02/","excerpt":"","text":"css3中的transform是讲究顺序的transform: translate(50%, -50%) rotate(45deg);与transform: rotate(45deg) translate(50%, -50%);效果是不一样的。 nth-last-of-type nth-last-child","categories":[],"tags":[]},{"title":"让vue老项目支持js与ts混用","slug":"让vue老项目支持js与ts混用","date":"2019-12-27T12:28:45.000Z","updated":"2024-09-11T03:04:29.078Z","comments":true,"path":"2019/12/27/","permalink":"http://onlymisaky.github.io/2019/12/27/","excerpt":"","text":"今年国庆前(2019)，终于把我司的一个老项目重构完成(his前端重构经验)，开发体验和效率上都有了质的飞越。不过由于一些不可抗原因(可用于重构时间不够充裕、历史代码量较大)，还是没能将项目由 JavaScript 迁移到 TypeScript。 动机对于喜欢ts好久好久的我来说（没错，我就是馋ts的类型系统，我下贱😝），不用ts我浑身难受。这周也是抽了些时间，让该系统支持ts与js混用了。当然并不是出于个人偏爱ts才做这样的改动，主要的动机有如下几点： 该项目属于中大型的后台项目，确实需要类型系统来提升代码的可维护性和可读性 在多人协作开发中，有类型提示可以减去很多不必要的沟通成本 我司的小程序已经采用ts，未来ts也是我们团队的主要方向之一 如果读者也想对项目进行升级，一定要先确定是否真的有必要，切莫为了满足个人爱好，从而给整个团队带来额外的成本。 项目介绍需要改造的项目是通过 vue-cli3 生成的模板项目，开启了eslint。 升级过程安装 typescript , ts-loadernpm i typescript ts-loader -D 修改 webpack 配置由于 vue-cli3 将 webpack 的配置全部隐藏起来了，只能通过在项目根目录下建立 vue.config.js 来修改配置，这里有两种方式来编写配置 通过直接修改configureWebpack选项，该方式和写webpack配置一样，在编译的时候，这份配置会通过 webpack-merge 合并到最终的配置中 通过 webpack-chain 链式修改配置，vue-cli3 内部也是通过这样的方式来维护 我选择的是第二种方式，因为它有友好的类型提示，不用边写边翻文档，关键的配置如下： // vue.config.jsmodule.exports = &#123; /** 其他与本次改动无关的配置 */ /** * @param &#123;import(&#x27;webpack-chain&#x27;)&#125; config */ chainWebpack: (config) =&gt; &#123; config .resolve.extensions.add(&#x27;.ts&#x27;).add(&#x27;.tsx&#x27;) .end().end() .module .rule(&#x27;typescript&#x27;) .test(/\\.tsx?$/) .use(&#x27;babel-loader&#x27;) .loader(&#x27;babel-loader&#x27;) .end() .use(&#x27;ts-loader&#x27;) .loader(&#x27;ts-loader&#x27;) .options(&#123; transpileOnly: true, appendTsSuffixTo: [ &#x27;\\\\.vue$&#x27;, ], happyPackMode: false, &#125;) .end(); &#125;&#125; 主要的配置就是对于 .ts、.tsx文件先通过 ts-loader 解析，然后再交由babel处理。 如果你的项目是 vue-cli2 生成的话，直接在 build/webpack.base.conf.js 中做相关的修改即可，关键代码如下 // build/webpack.base.conf.jsmodule.exports = &#123; /** 其他与本次改动无关的配置 */ resolve: &#123; /** other code */ extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;, &#x27;.ts&#x27;], // 添加 .ts 扩展名 &#125;, module: &#123; rules: [ /** other code */ &#123; test: /\\.tsx?$/, use: [ &#123; loader: &#x27;babel-loader&#x27; &#125;, &#123; loader: &#x27;ts-loader&#x27;, exclude: /node_modules/, options: &#123; transpileOnly: true, appendTsSuffixTo: [ &#x27;\\\\.vue$&#x27; ], happyPackMode: false &#125; &#125; ] &#125; ] &#125;&#125; 配置 tsconfig.jsonts的编译需要读取 tsconfig.json 文件，在根目录下创建 tsconfig.json 文件 // tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;esnext&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;strict&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;importHelpers&quot;: true, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;experimentalDecorators&quot;: true, &quot;esModuleInterop&quot;: true, &quot;allowSyntheticDefaultImports&quot;: true, &quot;sourceMap&quot;: true, &quot;baseUrl&quot;: &quot;.&quot;, &quot;types&quot;: [ &quot;webpack-env&quot; ], &quot;paths&quot;: &#123; &quot;@/*&quot;: [ &quot;src/*&quot; ] &#125;, &quot;lib&quot;: [ &quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;, &quot;scripthost&quot; ] &#125;, &quot;include&quot;: [ &quot;src/**/*.js&quot;, &quot;src/**/*.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;, &quot;tests/**/*.ts&quot;, &quot;tests/**/*.tsx&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot; ],&#125; 进行到这一步，如果你只是想简单的在项目中混用ts的话(比如在.js、.vue中引入.ts)，配置就算是全部完成了，你可以新建一个 .ts 文件，然后再入口文件中导入开发测试了；如果你还需要eslint进行代码规范、编写类组件等需求的，则需要继续进行下面的步骤 配置eslint因为eslint的生态圈比较繁荣，typescript团队已经放弃了tslint从而转向eslint，所以这里我们也是用eslint作为代码规范校验的工具。需要安装以下工具 npm i @typescript-eslint/eslint-plugin @typescript-eslint/parser @vue/eslint-config-typescript -D 然后修改eslint配置文件 module.exports = &#123; // 关键配置 plugins: [&#x27;@typescript-eslint&#x27;], extends: [ &#x27;plugin:vue/essential&#x27;, &#x27;@vue/airbnb&#x27;, &#x27;@vue/typescript&#x27;, ], parserOptions: &#123; parser: &#x27;@typescript-eslint/parser&#x27;, &#125;,&#125; 支持在ts文件中导入.vue文件默认情况下，typescript是无法识别 .vue 文件，当你需要在ts导入vue的单文件组件时(比如路由配置)，编辑器会报错：找不到模块。为了让ts能将 .vue 当成模块识别，需要在项目中创建shims-vue.d.ts文件，这样ts就会把 .vue 文件当成模块来解析了。 // src/shims-vue.d.tsdeclare module &#x27;*.vue&#x27; &#123; import Vue from &#x27;vue&#x27;; export default Vue;&#125; 用装饰器注册组件(不推荐再使用)npm i vue-property-decorator -S 由于vue的api设计原因，导致其很难使用ts来编写vue组件(无法正确的推导出this)，所以还需要安装vue-property-decorator，通过它提供的一列装饰器，来编写类组件，用起来大有一种angular的感觉，具体可以移步到这里👉 https://github.com/kaorun343/vue-property-decorator，详细的参考demo👉TodoMvc-vue 不过vue官方已经决定放弃这种写法，学习react的hook并推出了composition-api，虽然社区对此颇有不满。所现阶段不推荐装饰器写法，等vue3正式发布后再逐步迁移vue组件吧。 在ts中导入js既然是ts和js混用，那就会存在js中导入ts，或ts中导入js的情况。前者一般情况经过上面的配置，是不会有太多问题出现的。而后者(ts中导入js)可能在编写代码的时候，编辑器可能会提示一些小错误。这时候就需要你为相关的js文件编写类型提示文件了。 // a.jsexport function sum(m, n) &#123; return m + n;&#125; 为了在ts中导入a.js不报错，我们要在相同的目录下创建a.d.ts类型提示文件 export type sum = (m: number, n:number) =&gt; numer; 如果导入的js文件代码量不是很多，建议直接修改源文件。 删除jsconfig.json如果你使用了vscode作为开发工具，并且也配置了jsconfig.json文件。那么在引入ts之后，你完全可以删除这个文件，然后将tsconfig.json中的compilerOptions.allowJs设置为true即可。https://code.visualstudio.com/docs/languages/jsconfig 下一步计划接下来会逐步将所有的 .js 文件加上类型系统，转成 .ts 文件。对于 .vue 单文件组件，继续保持原有写法，等到vue3发布后再做迁移的打算。当然也有可能会迁移到其他的框架，在这期间只要不断弱化 vue 的比重，让它之负责 ui 部分。 总结 安装 typescript、ts-laoder，修改webpack配置，支持对.ts文件的解析 配置 tsconfig.json 配置 eslint 添加 shims-vue.d.ts 支持对 .vue 文件的识别 如果需要编写类组件，安装 vue-property-decorato 为需要导入到ts文件中的js文件编写类型文件，或者直接修改该文件为 .ts 文件","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://onlymisaky.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://onlymisaky.github.io/tags/TypeScript/"},{"name":"vue","slug":"vue","permalink":"http://onlymisaky.github.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://onlymisaky.github.io/tags/webpack/"}]},{"title":"his前端重构经验","slug":"his前端重构经验","date":"2019-09-20T10:30:21.000Z","updated":"2024-09-11T03:04:28.942Z","comments":true,"path":"2019/09/20/","permalink":"http://onlymisaky.github.io/2019/09/20/","excerpt":"","text":"自入职以来，85% 的工作都是在做 HIS:Hospital Information System (医院信息系统)的需求。从前端的角度来看，这是一个很典型的后台管理系统，而且有趣的是，你可以从项目的 git 记录中窥探到近年前端技术的变迁。 在我接手到这项目的时候，它已经稳定运行了有三年多的时间了，而且每月都有至少两个以上新需求需要去完成。这是一个非常好的事情，说明我们一直是稳步前进的，不过对于开发者来说，未必是那么的美好。因为出于项目的稳定性考虑，正在使用的技术可能是很久以前的技术，我并不是狂热新技术推崇者，有经验的人都明白，万金油般的解决方案是不存在的，最优的技术选型还是要由场景来决定。所以这次重构并不是为了重构而重构，而是为了提高项目的可维护性和提升开发效率而做出的决定，因此专门抽出一段时间来做重构，收益是远远大于付出的。 重构前的痛点首先介绍一下重构前的技术方案，当时项目还没有采用目前主流的前后端分离的方式，后端使用的是：Spring Boot + thymeleaf(Java 模板引擎)，前端采用的技术就比较多了： jQuery (操作 Dom，发起 ajax 请求) 基于 jQuery 封装的常用插件(日期选择、表格、select 等等) Handlebars(老牌的前端模板引擎) sass gulp (编译 sass，压缩 js，移动编译后的文件，启动 webpack ) vue1.x webpack1.x (编译 .vue 文件) lodash (仅仅是为了使用 lodash 的 template，所以项目中一共有四套模板语法 thymeleaf、Handlebars、template、vue) 除了以上列举出的这些，还有其它使用频次不太高的js库没有列出。 那这样一个糅合了多种前端技术方案的项目，要如何启动进行开发调试呢？前面提到项目前后端没有分离，所以要想跑起来就必须要配置java开发环境(jdk, maven, mysql, redis…)，和前端开发环境(node, npm, gulp, webpack…)。首先通过 gulp 和 webpack 编译打包前端代码，移动到后端指定的 resource 目录，然后再通过 mvn 启动后端服务(过程比较漫长)。每当前后端代码有改动的时候，则需要重新执行上线的步骤，等待时间极为漫长。讲到这里你可能已经感受了一些痛点了： 上手成本高(前端同学要去了解一些后端，后端同学又要去了解一些前端) 前端部分技术方案老旧(vue1.x, gulp, webpack1.x) 调试成本极高，每当前端代码更新就需要重新打包前端，重启后端服务，无法使用热更新，耗费时间极长 为了解决以上这些痛点，在我入职第二周，项目经理便和我聊了重构的问题，重构的目标就是将项目打造成前后端分离，提高以后的开发效率和代码质量。刚接到这个任务的时候还是比较兴奋的，因为一直写业务代码确实有些厌倦了，想接受新的挑战，做一些重构和架构方面的东西。但是也有几分的惆怅，因为当时整个项目组只有我一个前端，而且明确表示不会有专门的开发周期用于重构。如同项目经理多次提到的那样，我们要做的事情是“给一辆高速行驶中的汽车换轮胎”。当然在重构的最后阶段还是争取到了一周多宝贵的时间用于全身心投入重构工作。 重构前的准备既然没有专门的开发周期用于重构，那只能在日常的需求迭代中一点点做重构，所以技术选型就显得尤为重要。最终在主流的 Angular、React、Vue 三者中选择了 Vue，原因如下： vue使用起来非常灵活。只要在页面中引入 vue.js 即可，然后逐步剥离 jQuery、Handlebars 这些老旧的技术，同时引入 vue 生态内的 router、vuex 等等，项目会向一个单页应用慢慢演变。虽然 Angular 和 React 也可以直接通过 script 标签的方式引入使用，但是这样做的话开发体验上比 vue 差很多。 项目有已经有一下部分页面用使用 vue1.x 编写，如果再选别的框架，在迭代过程中又会加重开发的负担。 PS:如果是停掉所有的新需求专门重构的话，我可能不会选择 Vue，具体原因暂且不表，也莫问。 框架敲定之后，就该对重构过程中的方案进行思考了，这里我直接给出方案的结果，这些都是基于个人的经验总结出来的，未必是最优的仅供参考： 首先就是创建一个全新的目录，用于存放新的代码，可以很好的隔离新代码和老代码。目录结构和目前主流的前端项目大同小异├── 老代码文件夹 ├── v2(新代码文件夹) │ ├── api │ ├── components│ ├── constants│ ├── plugins│ ├── styles│ ├── util├── └── views└── pages(webpack 入口文件) 修改打包脚本。在上面的的目录结构中有一个 pages 文件夹，它是用来存放 webpack 入口文件用的。因为没有前后端分离，所以除了公共的静态资源外，不同的页面也会加载各自的 js&#x2F;css 文件，pages 文件夹下存放的就是每个页面对应的 js 文件，v2&#x2F;views 下面的文件则是每个页面对应的 vue 组件，最后借用 webpack 的多入口功能来打包module.exports = &#123; entry: &#123; foo: &#x27;./pages/foo.js&#x27;, bar: &#x27;./pages/bar.js&#x27; &#125;&#125; 但是这样做有一个缺点，每当添加新的入口文件时，就需要修改一下入口配置。这里可以采用读取 pages 文件，动态创建 entry 对象的方式来解决这个问题：const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const entry = &#123;&#125;;fs.readdirSync(path.resolve(__dirname, &#x27;pages/&#x27;)) .forEach(fileName =&gt; &#123; if (fileName.endsWith(&#x27;.js&#x27;)) &#123; entry[fileName.replace(&#x27;.js&#x27;, &#x27;&#x27;)] = `v2/pages/$&#123;fileName&#125;` &#125; &#125;);module.exports = &#123; entry&#125; 不过最终并没有这样做，因为已经用到了 gulp，所以使用了 webpack-stream 这个插件，他的原理是通过 gulp 把文件转成 stream 传给 webpack-stream 打包编译，这样做也不用再单独启动 webpack 了。const gulp = require(&#x27;gulp&#x27;);const webpack = require(&#x27;webpack-stream&#x27;);const named = require(&#x27;vinyl-named&#x27;);const uglify = require(&#x27;gulp-uglify&#x27;);const webpackConfig = require(&#x27;./webpack.config.js&#x27;);gulp.task(&#x27;webpack&#x27;, function () &#123; return gulp.src([&#x27;js/pages/*.js&#x27;]) .pipe(named()) .pipe(webpack(webpackConfig)) .pipe(uglify()) .pipe(gulp.dest(&#x27;dist/js/&#x27;));&#125;); 对于全新的需求，一律使用vue开发。首先由后端同学定义好后端路由(页面 url )，并且提供对应的空模板页面。对于前端而言，这个空面便是一个单页应用了，你可以在这里任意发挥，所以在替换为前端路由之前，每一个 url 对应的就是一个 spa，最后只要把后端路由替换成前端路由，就成为一个完整的单页应用了。&lt;!-- hello-world.html --&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns:layout=&quot;http://www.ultraq.net.nz/web/thymeleaf/layout&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; layout:decorator=&quot;layout&quot;&gt;&lt;body&gt;&lt;th:block layout:fragment=&quot;css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/hello-world.css&#125;&quot;/&gt;&lt;/th:block&gt;&lt;th:block layout:fragment=&quot;content&quot;&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/th:block&gt;&lt;/body&gt;&lt;th:block layout:fragment=&quot;script&quot;&gt; &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; &lt;script th:src=&quot;@&#123;/js/hello-world.js&#125;&quot;&gt;&lt;/script&gt;&lt;/th:block&gt;&lt;/html&gt; 然后在 pages 下面创建对应的js文件/** hello-world.js */import Vue from &#x27;vue&#x27;;import HelloWorld from &#x27;./v2/views/hello-world/index.vue&#x27;const vm = new Vue(&#123; components: &#123; HelloWorld &#125;, render() &#123; return (&lt;hello-world /&gt;); &#125;&#125;).$mount(&#x27;#app&#x27;); 对于老页面，如果改动比较小，则继续沿用之前的写法；如果改动较大则需要根据工时、风险性、后期收益来评估是用 Vue 重写还是继续沿用之前的开发方式。不过大部分情况下，两种方式是可以并存的。比如某个页面中一部分需要进行较大的改动，便可以将这一部分用 vue 重写，下次再将另一部分用 vue 重写，最终这个页面中可能会有多个 vue 实例，我们只要吧这些实例以组件的形式组织起来，这个页面就算是重构完成了。当然这还要得益于 vue 的灵活性。&lt;!DOCTYPE html&gt;&lt;html xmlns:layout=&quot;http://www.ultraq.net.nz/web/thymeleaf/layout&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; layout:decorator=&quot;layout&quot;&gt;&lt;body&gt;&lt;th:block layout:fragment=&quot;css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/other.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/hello-world.css&#125;&quot;/&gt;&lt;/th:block&gt;&lt;th:block layout:fragment=&quot;content&quot;&gt; &lt;div&gt; &lt;!-- 老的模板 --&gt; &lt;div&gt;xxxx&lt;/div&gt; &lt;!-- 本次的改动 --&gt; &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/th:block&gt;&lt;/body&gt;&lt;th:block layout:fragment=&quot;script&quot;&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/js/other.js&#125;&quot;/&gt; &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; &lt;script th:src=&quot;@&#123;/js/hello-world.js&#125;&quot;&gt;&lt;/script&gt;&lt;/th:block&gt;&lt;/html&gt; 每次改动只要将老的模板用 vue 的方式重写即可，在这个不断替换的过程中，要注意文件的加载顺序。可能会涉及到老的部分和 vue 部分的交互，一般使用事件订阅和 props 的方式都是可以解决的const foo = new Vue(&#123; components: &#123; Foo &#125;, data() &#123; return &#123; bar: &#x27;&#x27; &#125; &#125;, render() &#123; return (&lt;foo onXxx=&#123;($event) =&gt; &#123; this.$emit(&#x27;xxx&#x27;, $event); &#125;&#125; bar=&#123;bar&#125;/&gt;); &#125;&#125;).$mount(&#x27;#foo&#x27;);$(() =&gt; &#123; vm.$on(&#x27;xxx&#x27;, (data) =&gt; &#123; // todo &#125;); // xxx vm.bar = &#x27;xxx&#x27;;&#125;) 重构中遇到的问题和解决方案 让人头疼的版本问题。前面提到部分页面使用了 vue1.x，考虑到 vue1 升级到 vue2 曲线相对平滑一下，所以前期一直想着先把这部分代码升级到 vue2，官方提供了 vue-migration-helper 帮助开发者识别出代码中旧有的特性，并且会告知你给出建议，同时附上关于详细信息的链接。不过当我跑完命令后，这种想法已经减少了一半了，1200多处修改，几乎涉及到了所有的 vue1.x 的代码。即使通过编辑器批量修改，也不能保证修改后可以顺利运行。在我看过部分的代码后，完全取消了直接升级的想法了，原因有二： 大部分组件都使用事件通讯，事件满天飞，光理清里面的业务(事件流)就需要很长的时间 里面有一部分常用组件是自己开发的，重构的版本引入了 element-ui 组件库，这些老的组件都要替换 没有单元测试，升级后之后的代码无法保障正确性所以最终决定这部分代码不升级，当改到具体页面的时候再进行升级重构，(不过这也引发了我的思考，框架在设计的时候一定要设计好对外暴露的 api，没要每次升级，就改一次 api，开发者很痛苦的，说的就是你，AngularJS) 除了框架版本，还有打包工具的版本也困扰着我。项目一开始使用 sass 编写样式的，但是在 vue1.x 中却没有看到使用 sass，所有的样式都是写在单独的 .scss 文件中，然后通过gulp 打包，最后以 link 的方式在页面中引入。为什么不直接写在单文件组件中呢？还可以通过 Scoped CSS 防止样式污染。 于是我就添加了 sass-loader 和 node-sass，但是很遗憾，vue-loader 版本过低，当升级了 vue-loader 后，vue1.x 的代码就无法编译通过了。最后找到了一个可以同时兼容 vue1 和 vue2 的版本，但是他却不支持 webpack1，然后升级 webpack 后，有引发了另外一些问题，我发现版本依赖的问题似乎无法解决了，要么全部升级，包括用 vue1.x 写的代码，这个方案已经在前面被否定调了；要么不用 sass-loader 。最后在尝试使用 less-loader 后，发现没有什问题，最终确定使用 less-loader。 上面所描述的两个版本问题一个没有解决，一个用了替代方案，总体上来说是很失败的，不过倒是从中获取了一些经验： 当升级版本的时遇到较多的改动，而时间又不充裕，且没有单测时，最好不要升级 当遇到版本依赖问题时，最好先想想为什么要升级，不升级是否有替代方案，不然会引发一系列连锁反应 记不住的命令每次调试的时候都要敲好多命令，根本记不住，一开始都是把这些命令记在一个地方，用到的时候就复制粘贴一下。但是还是觉得不爽，后来想到可以用 alias 让这些命令更简洁，比如自定义一些 his-build-fe、his-build-be 这样的命令，好用也好记，同时也激发了我对linux命令的兴趣。 一些失败的尝试前面提到每次代码有变动的时候，都要重新编译打包、重启服务，非常浪费时间。尤其是前端代码改动也要重新打包，作为一个前端不允许这种事情发生，所以就尝试用来 webpack 的 watch 来监听代码，但是由于是通过 webpack-stream 启动的，加了 watch 并没有用。于是就用 gulp-watch 来检测文件变更，虽然可以实现功能，但是 cpu 风扇一直嗡嗡的转，机器发热量也比较大，所以最后还是放弃了这种想法。 重构的一些经验和忠告 首先就是要有平和的心态。重构的过程中要不可避免的和老代码打交道，你可能会看到令你惊叹的奇巧淫技，但更多的是让你头晕眼花的业务逻辑和满口脏话的代码。当遇到这样的情况时，一定要调整好心态，用足够的耐心去梳理其中的逻辑。 尽可能的做到低耦合这一点可能在初期阶段显得不重要，但是到后面做全局性的改动和替换时，你就能感受到他的好处了。举一个例子，在项目中经常有需要从地址栏获取参数做一些业务逻辑的运算，一开始我是将这些参数在组件内部获取并且保存，到后面替换前端路由的时候，很多地址都变了，参数读取的方式也发生了很大的改变，如果当初是把这些值设计成组件的 props，那后期的工作将会减轻很多；同样的还有地址跳转，全局变量等等这些场景。 要对所使用的技术非常熟悉重构和新开项目、重写项目是不同的，经常会遇到需要新老兼容的场景，如果对项目所使用的技术不熟悉，会很难应付这些问题。 尽早的制定规范重构初期的工作都是我一个人在做，后面随着团队的壮大新加入了一些小伙伴，在和他们介绍项目背景和如何开发之后便做各自的任务了。由于一开始没有制定规范，所以大伙的代码风格，编写方式还是比较多样的，这也为后面统一调整的阶段增加了一些额外的工作量，如果一开始就好的代码规范就不会发生这样的事情了。 不定期重构代码在阅读项目中老代码的时候，会见到一些让人啼笑皆非的代码，我想写这段代码的人看到后也会怀疑自己当初是怎么写出这样的代码的，所以重构不是一次性的工作，好的代码就像粥一样，是熬出来。不定期的去重构整理自己曾经写过的代码和业务，不仅能让代码变得更健壮，每一次也是自我的升华。 结语在写这篇文章的时候，HIS 系统已经重构完成为一个纯粹的单页应用了，并且在线上运行了有一个多月的时间，虽然没有收到用户反馈，但是重构后开发体验和效率确实有了很大的提升，切面切换速度也比以前快了很多，所以重构的结果个人还是十分满意的。 本文并没有太多代码和架构层面描述，如果你想了解这些可以留言讨论，我会尽可能的给予答复。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://onlymisaky.github.io/tags/vue/"},{"name":"重构","slug":"重构","permalink":"http://onlymisaky.github.io/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"用vscode remote + wsl在windows上搭建linux开发环境","slug":"用vscode-remote-wsl在windows上搭建linux开发环境","date":"2019-07-09T08:25:17.000Z","updated":"2024-09-11T03:04:29.058Z","comments":true,"path":"2019/07/09/","permalink":"http://onlymisaky.github.io/2019/07/09/","excerpt":"","text":"本文不是安利文章，所以不会介绍任何有关wsl的优点（但是不得不承认，用起来真的很爽），这仅仅是一篇没有感情的操作教程。 简单介绍vscode remote 微软在 PyCon 2019 大会上发布了 VS Code Remote，通过安装Remote Development扩展包，可以在很多情况下代替vim直接远程修改与调试服务器上的代码，同时具备代码高亮与补全功能，就和在本地使用VScode一样。从此告别了 SSH + vim。 wsl Windows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，其目标是使纯正的Ubuntu 14.04 “Trusty Tahr”映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。 简单的说，就是在Windows 10 运行完整的 Linux 系统。 安装wsl 打开控制面板，将查看方式改为类别，点击卸载程序 点击启用或关闭 Windows 功能，在弹窗中勾选 适用于 Linux 的 Windows 子系统，点击确定等待安装 安装完成后重启操作系统 打开Microsoft store，搜索 ubuntu 可以选择其他的Linux发行版本，也可以直接选择Ubuntu安装，这里选择是Ubuntu 安装完成后，会在开始菜单中多出Ubuntu的图标，点击启动，初次进入需要等待安装必要的文件 文件安装完成后设置username和password即可进入Ubuntu子系统 配置UbuntuUbuntu安装完成后，为了更好的使用，做一些简单的配置 更新镜像地址，以获取更快的下载速度 备份源配置文件 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 修改源配置为清华大学开源镜像地址：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/如果对vim操作不是很熟悉，可以打开 C:\\Users\\你的用户名\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs\\etc\\apt 通过 Windows 的文本编辑器或其他文件编辑工具来修改。 更新仓库列表sudo apt-get update 安装 zsh 和 oh-my-zsh该步骤不是必须的，只是个人偏爱zsh，而且zsh相较于Ubuntu自带bash要好用很多 安装zsh、curl、gitsudo apt-get install zsh curl git 从 github 下载安装 oh-my-zshsh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 下载完成后，根据提示进行操作完成后，默认的 shell 会从 bash 修改为 zsh，如果下次启动 Ubuntu 后，默认 shell 还是 bash 可以通过以下命令手动修改默认 shellcat /etc/shells #查看所有shellchsh -s /bin/zsh #设置zsh为默认shell 安装openssh-server需要通过 shh 连接到 Ubuntu，所以这里要安装一下 openssh-serversudo apt-get install openssh-server至此，wsl的安装就结束了，这样你就在你的Windows 10 上面拥有了一个完成的 Ubuntu 系统，你也可以根据的需求，配置不同的开发环境了。 安装Remote Development并连接 WSL 安装 Visual studio Code (这不是废话吗) 在插件市场中搜索 remote , 会出现几个相似的图标和名称，只需要选择 Remote Development 这个插件安装即可，剩下的几个会自动帮我们安装好安装完成后，侧边活动栏会多出一个远程桌面的图标，左下角也会多出一个代码的小图标 在 wsl 上安装 vscode-server，点击左下角的小图标，在弹出命令下拉菜单中选择 Remote-WSL: New Window此时会打开新的vscode窗口，并且在右下角会显示当前的安装状态，耐心等待完成完成 同步本机上的插件到 vscode-server 上面。如果你是一个 vscode 老用户，那你肯定积累很多自己常用的插件。但是本机上的 vscode 插件和 Ubuntu 上面的 vscode 插件时完全独立的，所有需要你单独再安装一次，不过安装过程很简单，在连接上 WSL 后，选择侧边活动的插件市场按钮，会列出本地 vscode 上已经安装的插件，你只需要点击安装按钮，就可以将对应的插件安装到 vscode-server 上面了 在完成以上的操作之后，你就已经完成了所有的配置，下面就可以开始你的开(折)发(腾)之旅了。 连接到远程服务器对于有自己服务器的小伙伴，你也可以通过 vscode remote 远程连接到自己的服务，由于我家境贫寒，买不起自己的服务器，所以没法给你们演示如何连接远程服务器的操作了。不过没关系，我可以把虚拟机中 Ubuntu 当做 远程成服务器来操作演示。这里演示是用 SSH keys 的方式连接的，你也可以用账号密码的方式连接，选择自己喜好的即可。 生成 SSH keysssh-keygen -t rsa 将生成的 key (存放在id_rsa.pub文件中) 添加到远程服务器的 &#x2F;home&#x2F;用户名&#x2F;.ssh&#x2F;authorized_keys 文件中 打开 vscode ，选择侧边活动的 remote 图标，配置服务器信息Host：服务器名称，可以随便填HostName：服务器地址，我的虚拟机地址是192.168.106.128User：用户名其他详细信可以点击这里查看：https://linux.die.net/man/5/ssh_config 配置成功后，点击加号按钮连接。如果是第一连接，也需要安装 vscode-server ，不过都是全自动的，只要耐心等待即可；如果你是通过用户名+密码的方式连接的话，途中需要打开 vscode 的终端，手动输入密码 连接成功后就可以愉快的记性远程调试啦","categories":[],"tags":[]},{"title":"TypeScript","slug":"TypeScript","date":"2019-05-29T11:00:20.000Z","updated":"2024-09-11T03:04:28.922Z","comments":false,"path":"2019/05/29/","permalink":"http://onlymisaky.github.io/2019/05/29/","excerpt":"","text":"TypeScript 分享人： 现任 『企鹅杏仁』 ~~最年轻的~~ 前端工程师 — 奥利安奇 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; What?—-分段—- TypeScript是JavaScript类型的超集，它可以编译成纯JavaScript。—-分段—- TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。—-分段—- 简单的说 Type + JavaScript &#x3D; TypeScript—-分段—- &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Why? 静态类型检查 IDE 智能提示 代码重构 可读性 —-分段—- 倔强的你就是不想用 你需要在 HTML 里大量嵌入 JavaScript 代码，而非 HTML 和 JavaScript 分离 项目中大量依赖了第三方 JavaScript 类库，并且这些类库没有 .d.ts 文件 你是 “微软雅黑” &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 类型var/let/const 变量名: 类型 = 值; —-分段—- numberlet num: number = 18;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; —-分段—- stringlet name: string = &#x27;qq&#x27;;let word: string = `my name is $&#123;word&#125;`; —-分段—- booleanlet isDone: boolean = true; —-分段—- null 和 undefinedlet n: null = null;let u: undefined = undefined; —-分段—- void 空值空类型，表示没有类型，比如无返回值函数的返回值类型 function foo(): void &#123; &#125;let unusable: void = undefined; —-分段—- any任意类型，表示未知类型，比如动态内容（用户输入、或第三方类库）或不知道类型的东西（混合类型数组），可以声明any类型绕过类型检查 let str: any = 1;str = &#x27;1&#x27;; 不要让你的代码成为AnyScript—-分段—- never绝不存在的值的类型，如永远不会返回的函数（必定抛异常的，或函数体有死循环的）的返回值类型 // 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 只有这些怎么够呢？—-分段—- Arraylet nums: number[] = [1, 2, 3];let strs: string[] = [&#x27;你&#x27;, &#x27;好&#x27;, &#x27;呀&#x27; , &#x27;！&#x27;];let baz: Array&lt;any&gt; = [&#x27;你&#x27;, &#x27;好&#x27;, 6 , true]; —-分段—- Tuple元组，表示一组固定数量的元素（不要求元素类型相同），如二元组，三元组 let status: [string, string, number] = [&quot;DONE&quot;, &quot;已结束&quot;, 4]; —-分段—- Enumenum OrderStatus &#123; UNPAID = 0, UNUSED, USING, INVALID, DONE&#125;let state: number = OrderStatus.DONE; 双向索引 let stateStr: string = OrderStatus[OrderStatus[&#x27;DONE&#x27;]]; // DONE —-分段—- 类型断言可以通过类型断言告知TypeScript编译器某个值的确切类型，类似于其它语言里的强制类型转换，区别在于类型断言只是编译时的，不像类型转换一样具有运行时影响 let someValue: any = &quot;this is a string&quot;;// &lt;type&gt;let length1: number = (&lt;string&gt;someValue).length;// as typelet length2: number = (someValue as string).length; —-分段—- 类型推断let myFavoriteNumber = &#x27;seven&#x27;;myFavoriteNumber = 7;// index.ts(2,1): // error TS2322: // Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;. let myFavoriteNumber: string = &#x27;seven&#x27;;myFavoriteNumber = 7; &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 表达能力还是不够 interface —-分段—- TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。—-分段—- 不喜欢看官方的描述？ interface就是用来描述对象的属性和方法，和C语言中的struct更像一些。 —-分段—- let fe1: &#123; name: string, age: number &#125; = &#123; name: &#x27;奥利安奇&#x27;, age: 18&#125;;let fe2: &#123; name: string, age: number &#125; = &#123; name: &#x27;Xeon&#x27;, age: 18&#125;;// other fe... —-分段—- interface IFe &#123; name: string; age: number;&#125; let fe1: IFe = &#123; name: &#x27;奥利安奇&#x27;, age: 18&#125;;let fe2: IFe = &#123; name: &#x27;Xeon&#x27;, age: 18&#125;;// other fe... —-分段—- 可选属性interface IPatient &#123; name: string; phone: string; age: number; idCode?: string &#125; —-分段—- 只读属性interface IPatient &#123; readonly id: number; name: string; phone: string; age: number; idCode?: string&#125; —-分段—- 索引属性（任意属性）有些场景下无法确定属性名称 interface IPatient &#123; name: string; phone: string; idCode?: string; [prop: string]: string;&#125;let patient: IPatient;patient[&#x27;sex&#x27;] = &#x27;男&#x27;; 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集—-分段—- 方法interface Base64 &#123; encode(input: string): string; decode(input: string): string;&#125;let base64: Base64;base64.encode(&#x27;1234&#x27;);base64.decode(&#x27;sxdwwq&#x27;); —-分段—- 骚操作interface GetStrLength &#123; (str: string): number;&#125;let foo: GetStrLength = (s: string) =&gt; s.length;interface Nums &#123; [index: number]: number;&#125;let arr: Nums = [1, 2]; &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 函数function add(x: number, y: number): number &#123; return x + y;&#125; let add: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y; &#125;; —-分段—- 可选参数JavaScript里参数默认都是可选的（不传的默认undefined），而TypeScript认为每个参数都是必填的，除非显式声明可选参数 function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + &quot; &quot; + lastName; else return firstName;&#125;let result1 = buildName(&quot;Bob&quot;);let result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); —-分段—- 默认参数function buildName(firstName: string, lastName = &quot;Smith&quot;) &#123; return firstName + &quot; &quot; + lastName;&#125;buildName(&#x27;Will&#x27;, 123); //error 类型“123”的参数不能赋给类型“string”的参数 带默认值的参数不需要放在必须参数的后面，但必须明确的传入 undefined值来获得默认值 function buildName(firstName = &quot;Will&quot;, lastName: string) &#123; return firstName + &quot; &quot; + lastName;&#125;buildName(undefined, &quot;Smith&quot;); —-分段—- 剩余参数function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125;buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;); —-分段—- 重载$(&#x27;a&#x27;)$(document.querySelector(&#x27;a&#x27;))$([])$(function () &#123; &#125;) &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; Class—-分段—- Minimal Class class Message &#123; static version = &#x27;1.0.0&#x27;; constructor() &#123; this.messages = []; &#125; get hasReads() &#123; return this.messages.filter(item =&gt; !item.read) &#125; add(msg) &#123; this.messages.push(&#123; content: msg, read: false &#125;); &#125; clear() &#123; this.messages = []; &#125;&#125; —-分段—- 访问控制修饰符 public：类的成员属性&#x2F;方法默认都是public，没有访问限制 private：无法在该类声明的外部访问其成员（如无法通过this.xxx访问私有成员） protected：与private类似，但在派生类中也可以访问受保护成员 —-分段—- class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125; protected foo(): void &#123; console.log(this.name); &#125;; public move(distanceInMeters: number) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125; 注意，这些访问控制都只是编译时的限制，运行时并不做强检查。符合TypeScript的设计原则： 不给编译产物增加运行时开销 —-分段—- var Animal = /** @class */ (function () &#123; function Animal(theName) &#123; this.name = theName; &#125; Animal.prototype.foo = function () &#123; console.log(this.name); &#125;; Animal.prototype.move = function (distanceInMeters) &#123; console.log(this.name + &quot; moved &quot; + distanceInMeters + &quot;m.&quot;); &#125;; return Animal;&#125;()); —-分段—- but!!!!class RGBColor &#123; #hex constructor(r, g, b) &#123; #hex = r * 0x10000 + g * 0x100 + b &#125; toString() &#123; return `rgb($&#123;this.red&#125;, $&#123;this.green&#125;, $&#123;this.blue&#125;)` &#125; get red() &#123; return #hex &gt;&gt; 16 &#125; get green() &#123; return (#hex &gt;&gt; 8) &amp; 0xff &#125; get blue() &#123; return #hex &amp; 0xff &#125; static equals(c1, c2) &#123; return c1.#hex === c2.#hex &#125;&#125; Why not use the “private” keyword, like Java or C#? A summary of feedback regarding the # sigil prefix —-分段—- readonly修饰符—-分段—- class Animal &#123; // 声明和赋值合并 constructor(public readonly name: string) &#123; &#125;&#125;let a: Animal = new Animal(&#x27;Tom&#x27;);a.name = &#x27;jerry&#x27;; // Cannot assign to &#x27;name&#x27; because it is a read-only property.ts(2540) —-分段—- 抽象类abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log(&#x27;roaming the earch...&#x27;); &#125;&#125; 接口只能定义抽象方法 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 泛型等等…我还没想好…☺️ 不要问我了！我真不知道😭 —-分段—- import axios from &#x27;axios&#x27;;axios.get(&#x27;/user/1&#x27;).then(response =&gt; &#123; let user = response.data; // user长啥样 🤔🤔&#125;);axios.get(&#x27;/patients&#x27;).then(response =&gt; &#123; let patients = response.data; // patients又长啥样🤔🤔&#125;); —-分段—- 泛型函数function createArray&lt;T&gt;(length: number, value: T): T[] &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; —-分段—- 泛型接口interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125; interface GenericIdentity&lt;T&gt; &#123; id(arg: T): T; idArray(...args: T[]): T[];&#125; —-分段—- 泛型类class Component&lt;IProp, IState&gt;&#123; constructor( public readonly prop: IProp, state: IState ) &#123; &#125;&#125;interface AppProp &#123; name: string;&#125;interface AppState &#123; count: number;&#125;const App = new Component&lt;AppProp, AppState&gt;(&#123; name: &#x27;MyAPP&#x27; &#125;, &#123; count: 1 &#125;); —-分段—- 泛型约束class Component&lt;IProp extends &#123; parentName: string &#125;, IState&gt; &#123; constructor( public readonly prop: IProp, state: IState ) &#123; &#125;&#125; —-分段—- 泛型参数的默认类型function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; TSXTypeScript 也支持JSX，只需 2 步，即可使用 TypeScript 写 JSX： 源码文件用.tsx扩展 开启–jsx选项 —-分段—- —-分段—- preserve：生成.jsx文件，但保留 JSX 语法不转换，交给后续构建环节（如Babel）处理 react：生成.js文件，将 JSX 语法转换成React.createElement react-native：生成.js文件，但保留 JSX 语法不转换—-分段—- class App extends React.Component &#123; render() &#123; return (&lt;div&gt;App&lt;/div&gt; ); &#125;&#125; &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 框架—-分段—- Angular Angular hero 支持最好 开箱即用 工具链丰富—-分段—- import &#123; Component, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; Hero &#125; from &#x27;../hero&#x27;;import &#123; HeroService &#125; from &#x27;../hero.service&#x27;;@Component(&#123; selector: &#x27;app-dashboard&#x27;, templateUrl: &#x27;./dashboard.component.html&#x27;, styleUrls: [ &#x27;./dashboard.component.css&#x27; ]&#125;)export class DashboardComponent implements OnInit &#123; heroes: Hero[] = []; constructor(private heroService: HeroService) &#123; &#125; ngOnInit() &#123; this.getHeroes(); &#125; getHeroes(): void &#123; this.heroService.getHeroes() .subscribe(heroes =&gt; this.heroes = heroes.slice(1, 5)); &#125;&#125; —-分段—- React npm i create-react-app -g create-react-app myApp –typescritp—-分段—- 函数式组件 ----分段---- class组件 ----分段---- ## Vue [vue-class-component](https://github.com/vuejs/vue-class-component)、 [vue-property-decorator](https://github.com/kaorun343/vue-property-decorator)、 [vuex-class](https://github.com/ktsn/vuex-class/)、 [TodoMvc-vue](https://github.com/onlymisaky/TodoMvc-vue) - vue cli 内置了 TypeScript 工具支持 - 在 Vue 的下一个大版本 (3.x) 中也计划了相当多的 TypeScript 支持改进 ----分段---- import &#123; Vue, Component, Watch &#125; from &quot;vue-property-decorator&quot;;import &#123; State &#125; from &quot;vuex-class&quot;;import TodoHeader from &quot;@/components/todo-header.vue&quot;;import TodoMain from &quot;@/components/todo-main.vue&quot;;import TodoFooter from &quot;@/components/todo-footer.vue&quot;;import &#123; saveTodos &#125; from &quot;@/utils/store.ts&quot;;import &#123; Todo &#125; from &quot;@/types/todo&quot;;@Component(&#123; components: &#123; TodoHeader, TodoMain, TodoFooter &#125;&#125;)export default class App extends Vue &#123; @State(state =&gt; state.todo.todoList) todoList!: Todo[]; @Watch(&quot;todoList&quot;, &#123; deep: true, immediate: true &#125;) todoListChange(todos: Todo[]) &#123; saveTodos(todos); &#125;&#125; ----分段---- ## But!! [the Class API proposal is being dropped](https://github.com/vuejs/rfcs/pull/17#issuecomment-494242121) 所以没有折腾精神，追求稳定，还是等Vue3吧 Vue Function-based API RFC—-分段—- nest ----分段---- 用于构建高效且可伸缩的服务端应用程序的渐进式 Node.js 框架。 完美支持 Typescript 面向 AOP 编程 支持 typeorm Node.js 版的 spring 构建微服务应用&#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; BB这么多，到底怎么用？—-分段—- ----分段---- ## tsconfig.js 告诉typescript如何编译ts文件，比如前面提到的`--jsx`选项，编译后的js版本(`target`等等) 如果一个目录下存在一个tsconfig.json文件，那么它意味着这个目录是TypeScript项目的根目录。 tsconfig.json文件中指定了用来编译这个项目的根文件和编译选项。 编译选项—-分段—- webpackmodule.exports = &#123; entry: &quot;./src/index.tsx&quot;, output: &#123; filename: &quot;bundle.js&quot;, path: __dirname + &quot;/dist&quot; &#125;, resolve: &#123; extensions: [&quot;.ts&quot;, &quot;.tsx&quot;, &quot;.js&quot;, &quot;.json&quot;] &#125;, module: &#123; rules: [ &#123; test: /\\.tsx?$/, loader: &quot;ts-loader&quot; &#125;, ] &#125;&#125;; —-分段—- gulpvar gulp = require(&quot;gulp&quot;);var ts = require(&quot;gulp-typescript&quot;);var tsProject = ts.createProject(&quot;tsconfig.json&quot;);gulp.task(&quot;default&quot;, function () &#123; return tsProject.src() .pipe(tsProject()) .js.pipe(gulp.dest(&quot;dist&quot;));&#125;); &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; 声明文件并不是所有的文件都是使用typescript编写的，当使用这些由JavaScript编写的第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。—-分段—- 获取声明文件途径 TypeSearch `@types/react`、 `@types/react-dom` 、`types/react-redux` ... 仓库地址：[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/) —-分段—- 自己动手编写(声明文件编写介绍) declare let jQuery: (selector: string) =&gt; any; 编写声明文件也是学习typescript的一个很好的入门途径 &#x3D;&#x3D;&#x3D;&#x3D;分页&#x3D;&#x3D;&#x3D;&#x3D; JSDOC—-分段—- JSDOC 震惊！JavaScript 竟然可以类型推断！ ====分页==== 谢谢打游戏时拿命在C的奥利安奇","categories":[],"tags":[]},{"title":"最近零事","slug":"最近零事","date":"2018-10-17T07:28:10.000Z","updated":"2024-09-11T03:04:29.058Z","comments":true,"path":"2018/10/17/","permalink":"http://onlymisaky.github.io/2018/10/17/","excerpt":"","text":"看了一下 git 提交记录，已经有两个月没写东西了，主要还是工作太忙了，一周至少有三天时间加班到夜晚9点之后，身体方面很是吃不消，经常感觉浑身不舒服，甚至开始担心自己会猝死。当然灵魂方面也饱受摧残，每天都在填坑，写自己不喜欢的代码。作为一个有代码洁癖的人，这几个月来也算是被折磨的服服帖帖的了。 因为长期处于高强度的工作状态，思考的时间都放在通勤途中的和每日睡前了。大城市是一列停不下来的火车，而我们就是车上的煤，一铲一铲的被扔进锅炉里燃烧，没有任何挣扎也不能挣扎，等年纪大一些了，也就成了煤渣，也该回到原来的故处谋划以后的生计。 作为一块不够黑也不够亮、甚至夹杂一些杂质的煤炭，也想成为这列车上的乘客，站票也无所谓。但是光做眼前的事，好像也不能实现什么。 人生已过二十几载，平凡不可平庸。","categories":[],"tags":[{"name":"闲聊","slug":"闲聊","permalink":"http://onlymisaky.github.io/tags/%E9%97%B2%E8%81%8A/"}]},{"title":"webpack快速上手","slug":"webpack快速上手","date":"2018-07-23T07:32:00.000Z","updated":"2024-09-11T03:04:29.038Z","comments":true,"path":"2018/07/23/","permalink":"http://onlymisaky.github.io/2018/07/23/","excerpt":"","text":"嫌啰嗦想直接看最终的配置请戳这里webpack-workbench 序用两个自问自答来当作序吧： Q：为什么要写这篇文章？ A：因为我在将自己的一个项目 AngularJS-ES6 从 webpack3.x 升级到 4.x 的时候发现，作为一个熟练的 GitHub 搬运工，改起来还是很费力，主要是因为对其没有一个更完整的认知，因此有必要写一篇文章强化认知。 Q：既然是写给自己看的，那对于其他人有帮助吗？ A：如果你对 webpack 有少许的了解（至少知道webpack是干什么用的），那这篇文章应该还是有帮助的。 Why webpack？一个工具的诞生，必然有其诞生的原因，也许是为了简化工作，也许是为了解决某些痛点，也可能是今年的kpi压力很大… 今天的主角 webpack 的诞生就是为了解决前端开发长久以来的痛点：模块化 ，这是也它的前辈 grunt 和 gulp 所不具备的功能。 回想一下那个前端还被称作切图仔的时代，我们是怎么组织多个 .js 文件的： &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;c.js&quot;&gt;&lt;/script&gt; 且不说这样写有多low，就单从代码维护角度来说，b.js 可能使用了 a.js 中的某个方法； c.js 同样如此，可能还用到了 b.js 中的某些方法。单看每个文件，是根本不知道这些方法是哪来的，也不清楚这三个文件之间的依赖关系的。 为了解决的这个问题，requirejs 诞生了，这是一套 AMD 的模块化实现方案。而此时 node 已经出现有些时日，其遵循的是 CommonJS ，同样是 JavaScript 模块化，却有两套实现方案，语法也不一样。于是又出现了 CMD 和其实现 seajs ，它是为了让服务端模块化和浏览器端模块化的差异能够最小化。 以上这些都是前辈们对 JavaScript 模块化的探索，虽然不是标准，但却推动了标准的发展，于是在 ES6 中，终于有了标准的、原生的模块化方案了，然鹅… 浏览器厂商：标准是标准，至于什么时候实现，fucked say (日后再议)。虽然现在大部分浏览器内核都实现了原生的模块化，但是我们不能确保用户都已将浏览器更新至最新了。 所以，在所有浏览器都实现模块化标准之前，我们还是不能够愉快的使用 import 和 export ，于是 webpack 来了，给乡亲们带了希望，让乡亲们再也不用看浏览器脸色，从此过上了没羞没臊幸福的生活了。 简单介绍为了有更好更清晰的认识，建议读者跟着文章一起做一遍，可以先创建一个新的文件夹 learn-webpack ，在该目录中打开命令行，输入 npm init 命令初始化 package.json 文件。 安装npm i webpack webpack-cli -D 可以全局安装，也可以本地安装，建议本地安装，因为 webpack 不同的版本之间还是有一定的差异，为了避免这个问题，我们选择本地。 在上面安装命令中，除了安装了 webpack 外，还安装了 webpack-cli 。那么这个工具是干什么用的？在 webpack4.x 之后，webpack 把命令行单独提取出来了，也就是说，我们想在命令行中执行 webpack xxx 等命令时，就需要先安装 webpack-cli 。 所以如你的使用的4.x版本的 webpack ，还需要额外安装一下 webpack-cli 。 使用webpack 的使用还是比较简单的，并且提供了三种使用方法： 不使用配置文件 webpack &lt;entry&gt; &lt;output&gt; entry：要打包的文件，可以是一个文件，也可以是一组文件。 output：打包后生成的文件。 例如将 ./src/index.js 打包到 dist/app.js webpack ./src/index.js dist/app.js 使用配置文件 不使用配置文件的方式显然不够灵活多变，所以通常都是先编写 webpack 配置文件，然后根据配置文件内容进行打包。在根目录下创建 webpack.config.js 文件，然后在命令行中输入 webpack ，webpack 会自动读取 webpack.config.js 中的配置内容，然后进行打包，下文将会着重介绍如合编写配置文件。 在node中启动 const webpack = require(&#x27;webpack&#x27;);webpack(&#123; /* webpack配置内容 */&#125;, (err, stats) =&gt; &#123; /* 打包后回调 */&#125;); npm script在使用第二种方式的时候，我们也可以将一些配置内容以参数的形式添加在命令后面，比如我们想设置环境为 production ，可以在 webpack.config.js 中将 mode 设置为 production ，也可以在命令后面添加 --mode production ： webpack --mode production 如果还需要其他的配置参数，可有继续在后面添加。这样做的好处是可以将一些多变的参数从配置文件中抽离出来，使用起来很灵活。 但是如果参数太多，每次使用的时候又要敲好多命令，可能还会敲错，为了方便管理我们可以将这些命令全部保存在 package.json 的 scripts 属性中： &#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack --mode development&quot;, &quot;build&quot;: &quot;webpack --mode production&quot; &#125;&#125; 这样就可以通过 npm run build 命令进行打包了。 核心概念经常看到有人抱怨 webpack 太难太复杂了，“我们万事俱备，就差一个webpack配置工程师了”。确实如此，相比于 gulp 简洁的 api ，webpack 确实复杂了许多。 其实仔细的梳理一下，webpack 最重要也就4个核心概念： entry 入口 output 出口 loader 模块转换器 plugins 插件 除了这四个核心的概念，剩下的那些都是为了优化代码、让我们能有更好的开发体验而设计的。 mode开头先讲一个 webpack4 中新增的选项：mode。可能是受 parcel 的刺激，webpack4 终于也可以零配置打包了，主要原因是 webpack 终于明白了一个道理：约定大于配置。 model 的值有三种：production、development、none ，分别表示不同模式。 在 production 模式下，会默认启用下面这些插件： process.env.NODE_ENV 的值设为 production FlagDependencyUsagePlugin：删除无用代码 FlagIncludedChunksPlugin：删除无用代码 ModuleConcatenationPlugin：作用域提升 NoEmitOnErrorsPlugin：编译出现错误，跳过输出阶段 OccurrenceOrderPlugin SideEffectsFlagPlugin UglifyJsPlugin：js代码压缩 在 development 模式下，会默认启用下面这些插件： process.env.NODE_ENV 的值设为 development devtool 设置为 evel NamedChunksPlugin NamedModulesPlugin entry既然是模块化开发，就需要有一个入口文件，相关的模块就可以根据这个入口文件形成一个树形的依赖关系。 当然 webpack 还没有智能到可以自动识别出你的模块依赖关系，所以需要咱们来告诉它，如果你不告诉它，则会默认把 src/index.js(webpack4.x+) 当做入口文件。 入口文件可以是一个文件(string)： // webpack.config.jsmodule.exports = &#123; entry: &#x27;src/main.js&#x27;&#125; 也可以是多个文件(array)： // webpack.config.jsmodule.exports = &#123; entry: [&#x27;src/login.js&#x27;, &#x27;src/logout.js&#x27;]&#125; 甚至也可以是一个对象(object)： // webpack.config.jsmodule.exports = &#123; entry: &#123; login: &#x27;src/login.js&#x27;, logout: &#x27;src/logout.js&#x27;, &#125;&#125; 这三种写法的区别是： 传入一个文件(string)的时候，会把所有具有依赖关系的模块打包生成一个文件; 传入多个文件(array)的时候，还是会打包生成一个文件，webpack会把这些文件合并在一起，但是执行的时候会按照数组内文件的顺序依次执行; 传入对象的时候，则会根据对象key的个数，打包出对应数量的文件; 很显然，传入对象的方式更复杂，但也更利于扩展，同时也适合用来打包多页应用。 output有进必有出，webpack 也需要我们指定打包后的文件存放位置，也叫做出口文件，和 entry 一样，output 也有默认值 dist/main.js(webpack4.x+) 。 下面是 output 常见的配置项： // webpack.config.jsmodule.exports = &#123; output: &#123; path: __dirname + &#x27;/dist&#x27;, filename: &#x27;[name].bundle.js&#x27;, publicPath: &#x27;/assets/&#x27; &#125;&#125; path 指定打包后的文件存放位置，注意这是一个 绝对路径 ！上面的例子中用了 node 内置的常量 __dirname ，该常量表示当前执行文件所在的目录，所以我们打包出的文件就存放在和 webpack 配置文件同级的 dist 目录下面。 filename 打包后的文件名称，该选项有5个可配置项： 配置项 作用 [name] 模块名称，对应 entry 中的 key 值，如果 entry 传入的是 string 或 array 默认为 main [id] 模块id，由 webpack 生成 [hash] 模块的 hash 值，当有文件修改时，这个值就会重新计算并改变 [chunkhash] 这也是一个 hash 值，webpack中每打包生成一个文件，就叫一个chunk ，它是 chunk 本身的 hash ，通常用它来做文件缓存 补充一个小知识，如果 entry 中传入的是对象，且对象的 key 值像这种形式 &quot;a/b&quot; ，并且在 output.filename 中设置了 [name] 那么打包出的文件会存放在 a 文件夹下的 b.js 中（a/b.js）。 publicPath 关于这个配置，笔者曾经纠结了好久，知道它的作用，却总是无法理解，在网上看了很多关于 publicPath 的介绍，包括 webpack 的官网，但一直没有豁然开朗的感觉，直到后来在自己的项目中遇到了一些问题，才算是明白了为什么会有这个选项。 如果不想看下面这些内容，可以直接查看 总结 ，建议第一次阅读的时候跳过下面这一小段，等到了 devServer.publicPath 再回过来看一遍。 这里我们可以反向的分析一下。首先，在设置了 path 和 filename 这两个属性之后，便可以确定打包出的文件在本机存放的具体路径了。然后需要明确一点，打包出的代码需要上传到 Web 服务器上，这些文件中可能有 .css .js .png 等等，它们最终都要以 .html 为载体，假设这个文件是 index.html 就像这样： 注意：index.html 是通过 html-webpack-plugin 插件生成的，下文会介绍到。 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;webpack&lt;/title&gt; &lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;hello.png&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;index.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从这段简单的 html 中我们可以得到一个信息，那就是 index.css、 hello.png、 index.bundle.js 这个三个文件都放在相对于 index.html 的 同一级别下面，就像这样： dist├── index.html├── hello.png├── index.css└── index.bundle.js 如果我们的 webpack 设置是下面这样的： // webpack.config.jsmodule.exports = &#123; entry: &#123; app: &#x27;./src/main.js&#x27;, &#125;, output: &#123; path: __dirname + &#x27;/dist&#x27;, filename: &#x27;[name].bundle.js&#x27; &#125;&#125; 那么打包出来的文件结构应该是和上面的一模一样的，我们按照这个结构上传到 Web 服务器，不需要修改什么就可以直接访问了。 一般公司都有专门的 cdn 服务器，那么你可以把 index.css、 hello.png、 index.bundle.js 这些资源传到 cdn 服务器上，假设你 cdn 地址是 https://mycdn.com 那么你可以通过 https://mycdn.com/index.css 的方式来访问相应的资源。这时候为了使我们的网站不报错，我们就需要将 index.html 中的资源引用方式改为 ： &lt;link href=&quot;https://mycdn.com/index.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;img src=&quot;https://mycdn.com/hello.png&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://mycdn.com/index.bundle.js&quot;&gt;&lt;/script&gt; 很明显，这种打包完成后还需要手动修改的方式很智障，而如果我们不想做这样修改的话，只需要将 output.publicPath 设置为 https://mycdn.com/ ，便会在打包出来的 index.html 文件内自动加上 output.publicPath 设置的值。 还有一种情况，就是笔者所遇到的情况了。假设你的项目还是传统的开发方式，并没有采用前后端分离，用的还是后端模板的方式。而你作为一个前端开发，你想要模块化开发所以引入了 webpack 来打包，后端的哥们跟你说，你把你打包出的文件放在咱们项目的 static 文件夹下面就行了。一开始都没什么问题，但是在做某一个功能的时候，你发现打包出来的文件体积有点大，而且有些代码可以通过按需加载的方式拆分一下，这时候你想到了用 import() 来动态加载，于是除了打包出了 index.js ，还有一些需要动态加载的 .js 文件，你把它们都放进了 static 下面。但是在调试的时候却发现，那些需要按需加载的资源无法加载了，全都是 404 ，咦？怎么回事小老弟！打开控制台看一下，所有 404 的资源地址都是 https://test.com/assets/xxx.js 。干！说好的 static 怎么变成了 /assets/ 了？后端的哥们跟你说，这是后端框架的原因，虽然你是放在 static 下面，但是请求的时候请求的是 相对于当前页面的 /assets/ 这个路径 ，总之 后端没法改，需要前端想办法解决。这个时候，我们只要把 output.publicPath 设置为 /assets/ 就可以解决这个问题了。 总结： 这个选项默认是 &#39;&#39; ，一般情况是不需要修改的。但是在有些情况下，打包出的资源部署上线后，可能会出现 404 访问不到的情况。这个时候就需要配置一下这个选项来解决这个问题了。 如果你将打包后的资源上传到 cdn 上面，那么需要将它设置为可以通过 cdn 方式访问的地址，比如 publicPath: &#39;https://mycdn.com/assets/&#39; ； 如果你的项目在服务器上面目录结构和你打包出的文件结构不一样，比如你打包出来的 .html 和 .js 是平级的，但是在服务器上却把 .js 文件都放在 &#x2F;assets 下面，那你需要设置为 publicPath: /assets/&#39; 。 所以这个值并不会影响你打包出的文件路径，它只是用来设置在线上运行的时候，所请求的资源相对于 服务 &#x2F;html页面 的路径。 简单的说，在线上运行的时候，所请求的资源具体路径是 https://你的域名/publicPath/资源 或者 https://你设置的cdn地址/资源 。 output 的常用配置项就这三个，如果你想用 webpack 把你的代码打包成类库，你还需要配置一下 output.library 、 output.libraryTarget 等，不过笔者建议直接使用 rollup 打包类库。 所以如果有下面这样一份 webpack 配置文件： // webpack.config.jsmodule.exports = &#123; entry: &#123; app: &#x27;./src/main.js&#x27;, &#125;, output: &#123; path: __dirname + &#x27;/dist&#x27;, filename: &#x27;[name].bundle.js&#x27; &#125;&#125; 会打包出如下这些文件： project├── src // 源代码文件夹│ ├── main.js│ ├── login.js│ └── logout.js├── dist // 打包后生成的文件夹│ └── app.bundle.js└── webpack.config.js // webpack 位置文件 loader个人认为 loader 是 webpack 中最厉害的一个功能了，它让我们可以在项目随意 import 各种类型的文件，css scss html img 等等都不在话下，如果有相关的 loader 支持，甚至可以 import 其它语言的代码。 简单的说 loader 就是一个处理器，在 webpack 中配置好相应的 loader 之后，就可以在代码中像加载 JavaScript 模块一样使用 import 把其它类型的代码当做 JavaScript 模块加载。 loader 的用法有三种 在 webpack.config.js 中配置，这种方式是最常用的，下面会着重介绍。 在代码中显示的指定 loader ，下面的代码表示从 styles.css 加载样式文件，用 style-loader 和 css-loader 来处理 css 文件。 import styles from &#x27;style-loader!css-loader?modules!./styles.css&#x27;; 在命令行中为某些类型文件执行 loader 。下面的命令表示在打包过程中，对 .css 文件使用 style-loader 和 css-loader 来处理。 webpack --module-bind &#x27;css=style-loader!css-loader&#x27; loader 的配置loader 的配置其实比较简单，只是提供了太多简写，让新手有点摸不着头脑，首先用 JavaScript、TypeScript、css、scss来展示常用的几种配置方式： // webpack.config.jsmodule.exports = &#123; entry, output, module: &#123; rules: [&#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;env&#x27;] &#125;, include: __dirname + &#x27;/src&#x27; &#125;, &#123; test: /\\.tsx?$/, use: &#x27;ts-loader&#x27; &#125;, &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; test: /\\.scss$/, use: [ &#123; loader: &#x27;style-loader&#x27; &#125;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; modules: true &#125; &#125;, &#123; loader: &#x27;postcss-loader&#x27; &#125;, &#123; loader: &#x27;sass-loader&#x27; &#125; ] &#125;] &#125;&#125; 从上面的代码中我们可以发现，use 这个选项的配置是最没节操了，它可以是字符串、数组、甚至被 loader 这个选项代替，其实这都是简写。rules.loader 和 loader.options 是 rules.use: [ &#123;loader, options&#125; ] 的简写。这些配置项的含义分别是： test: 正则表达式，用来匹配文件的扩展名。 use: 对匹配出的文件使用的 loader 配置，如上面所说，该选项配置灵活，可以简写 loader: loader 名称 options: loader 的额外配置选项 include / exclude: 包括 或 排除 的文件夹，两个选项只能同时出现一个，上面的例子中 include: __dirname + &#39;/src&#39; 表示 babel-loader 只编译 /src 文件下的文件，其它的不做处理；相反的，exclude: __dirname + &#39;/src&#39; 表示不编译 /src 下的文件。 下面就来详细的介绍一下常用的 loader 和其配置。 （题外话，本来是先将 babel-loader 放到第一个介绍的，但是由于篇幅较长，且有些难懂，所以将其放到了后面） 样式处理npm i style-loader css-loader less less-loader node-sass sass-loader postcss-loader autoprefixer -D 对于样式文件的处理，我们（我）通常会用到以下这些 loader ： style-loader css-loader postcss-loader less-loader sass-loader 那么这些 loader 的使用场景和区别是什么呢？ 首先介绍 less-loader 和 sass-loader 。less 和 sass 都是 css预处理器，可以让 css 编写起来更爽，但是不能直接在浏览器中运行，所以需要先将 .less 或 .scss 文件先转换成 css 。这就是 less-loader 和 sass-loader 的作用。 无论是直接编写的 css ，还是由 less 或 sass 转换而来的 css 都不是 JavaScript 模块，这时候就要用到 css-loader ，它的作用就是把 css 转成 JavaScript 模块插入到代码中。 样式文件已经转换好了，但并不会产生任何效果。因为这些样式还没有添加到页面中，这时候就该轮到 style-loader 出场了，它的作用就是把转换后的样式添加到页面中，就像下面这样。 最后还有 postcss-loader 它的作用也很强大，最常用的功能就是帮助我们自动为一些样式属性名添加私有前戳（-moz、-ms、-webkit）。写过 vue 的同学都知道，当我们给 style 标签添加 scope 属性的时候，打包后的类名会自动添加自定义属性（例如 .panel[_v-72f4cef2]），这个功能就是基于 postcss-loader 实现的。 postcss 需要一份配置文件，这份配置文件以写在单独的文件中 (postcss.config.js)，也可以写在 package.json 的 postcss 属性中： &#123; &quot;postcss&quot;: &#123; &quot;plugins&quot;: &#123; &quot;autoprefixer&quot;:&#123;&#125; &#125; &#125;&#125; 对 postcss 感兴趣的同学可以看看这篇文章: PostCSS真的太好用了！ 这些 loader 的执行顺序是 ： sass-loader or less-loader → postcss-loader → css-loader → style-loader 通过对这些 loader 的配置，我们就可以把样式文件当做 js 文件一样引入了。 // styles.css.red &#123; color: red; &#125; // index.jsimport &#x27;./styles.css&#x27;; 这里需要在额外提一下 css module ，这也是一个很好的特性，写 react 的朋友对它应该很熟悉： // index.jsimport styles from &#x27;./styles.css&#x27;;export default () =&gt; ( &lt;h2 className=&#123;styles.red&#125;&gt;css module&lt;/h2&gt;); 从上面的代码中可以看出，我们将样式当做 对象 styles 导入 jsx 中，那么该样式下的所有类名就是 styles 的属性名了。 这样的写法也同样适用于 ES6 的模板字符串： // index.jsimport styles from &#x27;./styles.css&#x27;;const html = `&lt;h2 class=&quot;$&#123;styles.title&#125;&quot;&gt;css module&lt;/h2&gt;`;document.body.innerHTML = html; 只要在 css-loader 的 options 中设置 &#123; modules: true &#125; 既可以开启此功能。 上面的这些配置，可以帮我们将 css 封装成 js对象 ，打包在 .js 文件中，然后运行的时候，以 &lt;style&gt;&lt;/style&gt; 的方式动态插入到页面中，但我们更希望可以将这些样式从 js 文件中抽取出来放到 css 文件，一来这样显得更优雅一些，二来可以减少 js 为文件体积，避免动态创建 style 标签所带来的性能损耗。这个功能需要在 plugins 中进行设置，下面也会讲到。 file-loader、url-loadernpm i file-loader url-loader -D 如果我们在页面中通过相对路径来引入图片、音频、视频、字体等文件资源时，在 webpack 环境中可能出现路径错误404的问题。主要原因是 开发时的目录结构 和 打包后的目录结构 一般都是不一样的，因此导致路径失效，而 file-loader 就是为了解决这个问题的。 file-loader 可以解析页面中引入的资源的路径，然后根据配置，将这些资源拷贝到打包后的目录中。 url-loader 则是对 file-loader 进行了一次封装，如果解析的资源是图片，则可以将改图片转成 base64 从而减少 http 请求一提升性能，同时也可以设置 limit。 只对指定大小的图片进行转换。 同样的也可以在 js 中引入资源 // index.jsimport logo from &#x27;./images/logo.png&#x27;;const img = new Image();img.addEventListener(&#x27;load&#x27;, () =&gt; document.body.appendChild(img));img.src = logo; 下面是 url-loader 的简单配置参考： // webpack.config.jsmodule.exports = &#123; entry, output, module: &#123; rules: [&#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: [&#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, // 10KB 转换为base64 name: &#x27;images/[name].[ext]&#x27; // 拷贝到 images 目录下 &#125; &#125;] &#125;] &#125;&#125; html-loadernpm i html-loader -D 在 Web 开发中，通常会用到很多 html 模板，传统的方式是将模板存在服务端，前端通过 http 请求加载模板，或者在 JavaScript 中拼接字符串，或者在页面中将模板内容写在 &lt;script type=&quot;text/template&quot;&gt;&lt;/script&gt; 内。 而在 webpack 环境下，我们也可以把 html模板 当做 JavaScript 的模块来加载，以 Vue 为例： &lt;!-- template.html --&gt;&lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; // index.jsimport tpl from &#x27;./template.html&#x27;new Vue(&#123; el: &#x27;#app&#x27;, template: tpl, data: &#123; title: &#x27;Hello Webpack&#x27; &#125;&#125;); 在上面代码中，我们将 template.html 的内容以字符串方式导出，这正是 html-loader 的功能，也可以在配置只启用压缩功能。 // webpack.config.jsmodule.exports = &#123; entry, output, module: &#123; rules: [&#123; test: /\\.html$/, use: [&#123; loader: &#x27;html-loader&#x27;, options: &#123; minimize: true // 开启压缩 &#125; &#125;] &#125;] &#125;&#125; babel-loader(重点)npm i @babel/core babel-loader @babel/preset-env @babel/runtime @babel/plugin-transform-runtime -D Babel is a compiler for writing next generation JavaScript. 从官方的简短介绍中可以知道， babel 属于编译器，输入 JavaScript 源码，输出 JavaScript 源码（source to source），其作用就是将目前部分浏览器目前还不支持的 ES2015+ 语法转换为 ES5 语法。 babel-loader 则是让 babel 可以在 webpack 中使用的工具，同理如果你使用的是 gulp ，则需要用到 gulp-babel 这个包。 实际上，如果只是用 babel 的话，输入的代码和编译后输出的代码是相同的（被 webpack 混淆打包的代码与 babel 无关）。因为 babel 的转换工作全都是由 babel 的插件来完成的。 关于 babel 的介绍和使用，仅仅一个小节的篇幅是完全不够，所以这里贴一个链接，有兴趣的读者一点要点进去看一下 一口（很长的）气了解 babel。 babel 也是需要进行配置的，一般有两种方式： 在根目录创建 .babelrc 在 package.json 的 babel 属性中进行配置 我更倾向于在 package.json 进行配置，因为根目录放置太多文件，强迫症实在无法接受。无论是在 .babelrc 还是 package.json 中配置，配置的内容都是一样的，下面以在 package.json 中配置为例： &#123; &quot;babel&quot;: &#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false, &quot;targets&quot;: &#123; &quot;browsers&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot; ] &#125; &#125; ] ], &quot;plugins&quot;: [ &quot;@babel/plugin-transform-runtime&quot;, &quot;@babel/plugin-syntax-dynamic-import&quot; ] &#125;&#125; 在该配置中，presets 和 plugins 对应的值都是数组，同时数组的每一项可以是 string （只指定名字），也可以是 array （指定名字，并进行更具体的配置） plugins 表示用到的插件，比如我们在代码中使用到了 import() 动态加载模块这个语法，那么就要在 plugins 添加 @babel/plugin-syntax-dynamic-import 这个插件了；我们需要对 babel 编译后的代码进行去重，就需要用到 @babel/plugin-transform-runtime 。 当然，这两个插件也是需要单独安装的 npm i @babel/runtime @babel/plugin-transform-runtime @babel/plugin-syntax-dynamic-import -D 。 presets 一组 plugins 的集合。比如我们可以把 @babel&#x2F;plugin-transform-runtime 和 @babel&#x2F;plugin-syntax-dynamic-import 打包到一起，叫 preset-my ，这样我们只需要在 presets 中添加 preset-my 就可以了，省去了对 plugins 的配置 。上面的配置文件只配置一个 @babel/preset-env ，这是最常用的配置，@babel/preset-env 后面的对象是对 @babel/preset-env 具体配置。我们注意到，其中有一个 targets.browsers 属性，指定了浏览器版本，这个属性也可以放在 package.json 的 browserslist 中。 为什么配置了 presets 还需要配置 plugins 呢？很简单，如上面所说， presets 是一组 plugins 的集合，也就说 babel 对不同阶段的语法做了整合，方便我们使用。但是在上面的配置中，我们只使用了 @babel/preset-env 这个集合里的插件，而 import() 处于 stage-3 阶段（记不太清了，也可能是 stage-2），不包含于 @babel/preset-env ，所以就需要在 plugins 单独添加 @babel/plugin-syntax-dynamic-import 插件来对 import() 语法进行转换了。 社区中也提供了一些 presets ，比如 react 的 @babel&#x2F;preset-react ， vue 的 @vue&#x2F;babel-preset-app babel 的执行顺序是： 读取plugins数组 → 按正序执行plugins内插件 → 读取presets数组 → 按倒序执行presets内容 简单的介绍了 babel 后，开始配置 babel-loader ： // webpack.config.jsmodule.exports = &#123; entry, output, module: &#123; rules: [&#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, // options: &#123; presets: [&#x27;env&#x27;] &#125;, 该项的配置和上面babel的配置完全相同，已经在package.json配置过，这里不需要再配置 include: __dirname + &#x27;/src&#x27; // 只对 ./src 目录下的代码进行编译 &#125;] &#125;&#125; ts-loadernpm i typescript ts-loader -D 如果你的项目是用 typescript 开发的，这时候就要样到 ts-loader 了。 ts-loader 的配置比较简单，但是有许多需要注意的细节，详情可以参照这里：https://github.com/TypeStrong/ts-loader/blob/master/README.md#configuration plugins讲完了 entry、output 和 loader，下面开始讲讲 plugins 。细心的读者应该已经发现，还没有提到代码的压缩，而且按照上面的方式打包会把 .css 和 .js 文件打包在一起，并且打包后的文件体积很大，可能还会存在冗余的代码等等一些问题，plugins 就是为了解决这类问题而产生的。 这里不要把 loader 和 plugins 搞混了，laoder 只是把特定的文件类型转换成 JavaScript 模块，plugins 是在打包过程中对所有模块进行特定的操作 。plugins 的值是一个数组，所有的 webpack 都需要手动通过关键字 new 来实例化。 下面就介绍一些常见的插件。 html-webpack-pluginnpm i html-webpack-plugin -D webpack 是对 JavaScript 进行打包的，打包出的只能是 .js 文件。 而 JavaScript 要想在浏览器中运行，那就必须在 html 中通过 script 的方式引入。在没有其他工具帮助的情况下，我们只能手动创建 html 文件，然后再把打包后的 .js 文件和 .css 文件写到这个文件中，这样做很麻烦。这时候可以用 html-webpack-plugin 这个插件来自动完成上面的工作。 html-webpack-plugin 提供了一些配置项，如果不行配置，它会自动帮我创建一个空的 html 文件，然后将打包后的资源插入到这个页面内： // webpack.config.jsconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123; entry, output, plugins: [ new HtmlWebpackPlugin() // 创建 /dist/index.html 文件，并将 index_bundle.js 插入到这个页面中。 ]&#125; 同样，我们也可以为其指定一个模板页： // webpack.config.jsconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123; entry, output, plugins: [ new HtmlWebpackPlugin(&#123; filename: &#x27;index.html&#x27;, // 生成的文件名称，默认为 index.html template: &#x27;src/index.html&#x27;, // 以 src/index.html 为模板文件 inject: &#x27;body&#x27;, // 将打包后的文件注入到 body 区域内 title: &#x27;Hello webpack&#x27;, // 生成文件的标题 minify: &#123; // 对生成的文件进行压缩，可以设置为 true ，也可以是对向，进行更具体的配置 collapseWhitespace: true, // 删除空格 minifyCSS: true, minifyJS: true, removeAttributeQuotes: true, removeComments: true, removeTagWhitespace: true, &#125; &#125;) ]&#125; 插件也可以通过多次实例化来重复使用： // webpack.config.jsconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123; entry, output, plugins: [ new HtmlWebpackPlugin(&#123; filename: &#x27;index.html&#x27;, template: &#x27;src/index.html&#x27;, chunks: [&#x27;index&#x27;, &#x27;vendor&#x27;] // 只注入 index.bundle.js 和 vendor.bundle.js &#125;), new HtmlWebpackPlugin(&#123; filename: &#x27;about.html&#x27;, template: &#x27;src/about.html&#x27;, excludeChunks: [&#x27;index&#x27;] // 将 index.bundle.js 排除，其余的都注入 &#125;) ]&#125; 分离css和js webpack v4npm i mini-css-extract-plugin -D 前面在介绍用 loader 处理样式的时候说到，这些样式最终会被混入到打包后的 .js 文件中，在页面运行的时候，在以 &lt;style&gt;&lt;/style&gt; 的方式动态的插入到 DOM 节点中，这种做法有两个很明显的缺点： js 和 css 糅杂在一起，增加了单个文件的体积。 在页面运行时动态的去创建 style 标签，多多少少会有些性能影响 如果能把这些 css 从打包后的 js 中抽取出来，就可以解决上面的两个问题，这时候就要用到 mini-css-extract-plugin 这个插件了。 // webpack.config.jsconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;);module.exports = &#123; entry, output, module: &#123; rules: [&#123; test: /\\.css$/, use: [MiniCssExtractPlugin.loader, &#x27;css-loader&#x27;] &#125;] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: &#x27;[name].[contenthash].css&#x27;, chunkFilename: &#x27;[id].[contenthash].css&#x27;, &#125;) ]&#125; 从上面的配置中可以看出，mini-css-extract-plugin 并不是单独作为一个 plugin 来使用的，它还充当了 loader 的作用，代替了 style-loader 。前面在介绍 style-loader 的时候提到，它的作用是将转换后的样式插入到页面中，既然我们现在需要将 css 和 js 分离开，所以也就不需要再用到 style-loader 了。 当作为插件使用的时候， mini-css-extract-plugin 可以接受两个可选参数： filename ：分离出的css文件名称，写法和 output 的 filename 选项相同，唯一区别是当你想使用缓存的时候，填写的是 contenthash 而不是 chunkhash chunkFilename ：切割出的css文件块名称，写法和 filename 相同 最近发现 extract-text-webpack-plugin 也支持 webpack4 用法了 mini-css-extract-plugin 完全相同，而且相较于 mini-css-extract-plugin 还多了一些可选的配置 npm i extract-text-webpack-plugin -D // webpack.config.jsconst ExtractCssChunksPlugin = require(&#x27;extract-css-chunks-webpack-plugin&#x27;);module.exports = &#123; entry, output, module: &#123; rules: [&#123; test: /\\.css$/, use: [ExtractCssChunksPlugin.loader, &#x27;style-loader&#x27;] &#125;] &#125;, plugins: [ new ExtractCssChunksPlugin(&#123; filename: &#x27;[name].[contenthash].css&#x27;, chunkFilename: &#x27;[id].[contenthash].css&#x27;, hot: true, //HMR 下面会着重介绍 orderWarning: true, // Disable to remove warnings about conflicting order between imports reloadAll: true, //当启用HMR时，强制重新加载所有css cssModules: true //如果启用了 cssModules 此选项设置为 true &#125;) ]&#125; 压缩cssnpm i optimize-css-assets-webpack-plugin -D 在将 css 从 js 中分离出来不之前，我们是不需要考虑压缩 css 的，因为样式都被打包进了 js 文件中，当我们设置 mode 为 production 时，webpack 会自动压缩 js 文件。但是我们现在将 css 从 js 中分离出来了，webpack 目前还不能自动压缩 css 文件。干！真是麻烦！这时候又要用到插件来帮我压缩分离出来的 css 文件了。 // webpack.config.jsconst OptimizeCssAssetsPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;);module.exports = &#123; entry, output, plugins: [ new OptimizeCssAssetsPlugin() ]&#125; 这里讲一个坑，在 webpack4 之前，压缩都是通过 webpack.optimize.UglifyJsPlugin 这个插件来完成。webpack4 新增了 mode 和 optimization 两个选项，当 mode 设置为 production 时会自动压缩 js 文件(这个已经提过多次了)，其实将 mode 设置为 production 时， optimization.minimize 便会默认设置为 true ，意思就是在打包的时候对 js 进行压缩。而如果你想用第三方压缩插件，你可以将插件写在 plugins 中，也可以写在 optimization.minimizer 中。但是如你将压缩插件写在 optimization.minimizer 中时，webpack 就会默认读取 ptimizatio.minimizer 这个选项了，这也就意味着，这时候如果你不手动的配置 js 压缩插件，js 文件是不会被压缩，这时候又需要寻找压缩 js 的插件，比如 uglifyjs-webpack-plugin ，然后再配置一下，说实话这样真的很烦，所以我直接将压缩的插件配置在了 plugins 中，这样就省去了对 js 压缩插件的配置。webpack 的文档中描述了相关说明 Minimizing For Production 复制静态资源npm i copy-webpack-plugin -D 有时候我们的项目中会有一些静态资源，比如网站的favicon、你从不知道的地方找来的不知名的js插件等等，这些静态资源并不会在项目中通过 import 的方式显式的加载进来，而是在直接写在页面中 ...&lt;link rel=&quot;shortcut icon&quot; href=&quot;static/favicon.ico&quot;&gt;...&lt;script src=&quot;static/xxx.js&quot;&gt;&lt;/script&gt; 对于这些静态资源，webpack 在打包过程中不会对它们进行处理，所有需要我们 copy 到打包后的目录中，从而保证项目不会因为缺少这些静态文件而报错， copy-webpack-plugin 的作用便是 copy 这些静态资源到指定的目录中的。 // webpack.config.jsconst CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;);module.exports = &#123; entry, output, plugins: [ new CopyWebpackPlugin([ &#123; from:&#x27;static/**&#x27;,to: &#x27;dist/static&#x27; &#125; ]) ]&#125; 上面的配置表示将 static 文件夹下所有的文件都复制到 dist&#x2F;static 下面，如果你熟悉 gulp 的话，你会发现这其实就是一个移除了 pipe 的 gulp。 其实对于copy文件这种脏活累活你也可以用你熟悉的方式来完成，比如 gulp、fs-extra 等。 clean-webpack-pluginnpm i clean-webpack-plugin -D 如果我们打包输出的文件使用了 chunkhash 、 hash 等来命名的话，随着文件的变更和打包次数的增加，dist 目录会淤积很多无用的打包文件，这时候便可以借助 clean-webpack-plugin 帮我们清除一些这些无用的文件 // webpack.config.jsconst CleanWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;);module.exports = &#123; entry, output, plugins: [ new CleanWebpackPlugin() ]&#125; 和 copy 文件一样，删除文件这种话不一定非得让 webpack 来做，我们也可以借助其他的方式来完成，比如我要再提一遍的的 gulp ，又或者 rimraf 、 del 等。但是区别是你需要手动的控制一下任务的流程，总不能在打包完成才删除问吧，所以用 webpack 提供的插件是不需要考虑任务流程的问题。 上面介绍了5个 webpack 的 plugin ，主要目的是让大家体会 webpack plugin 的作用基本用法。 实际上 webpack 的 plugin 还有很多很多，几乎可以满足你在项目构建中的各种需求，webpack 官网了列举很多官方推荐的 plugin https://webpack.js.org/plugins/ ，有兴趣的同学可以前往查看。 tree-shakingtree-shaking 这个技术在 webpack2 就已经被添加进来了，作用是在打包过程中，将模块内没有使用的代码删除，从而减小打包后的文件体积。 这个单词表面的意思是，有一棵小树，你去抖动这棵树，那么树上多余没用的树叶就会掉落，那在代码中具体是什么样子呢。假设我们现在将一些常用的方法都封装在了 util.js 这个文件中： // util.js function add(...args) &#123; return args.reduce((prev, currrent, index) =&gt; &#123; return prev + currrent; &#125;, 0);&#125;function multiply(...args) &#123; return args.reduce((prev, currrent, index) =&gt; &#123; return prev * currrent; &#125;, 1);&#125;export &#123; add, multiply&#125; 然后我们在 index.js 中需要用到 add 这方法： // index.jsimport &#123; add &#125; from &#x27;./util.js&#x27;;add(1, 2);add(1, 2, 3); 这样打包后的代码是不含有 multiply 这个函数的，这就是 tree-shaking 的作用。 splitChunk现在我们再回顾一下 webpack 打包过程 以 entry 为起点，将所依赖的模块组织成一个树形的结构 通过不同的 loader 对不同的文件进行编译 使用 plugins 对文件打包后的文件进行特定的操作 根据 output 将打包后的文件输出到指定的位置 如果只有一个入口文件，最终也只会打包出一个文件(下文用 chunk 表示，每打包出的一个文件就叫一个 chunk)（排除动态加载的情况(import())）。这里有一个很明显的缺陷，就是将所有的模块打包成一个文件，打包后的体积一定会很大。同时，如果我们使用了 chunkhash 做文件缓存的话，每次项目修改的时候，无论修改哪个文件，即使是修改了一个换行，chunkhash 的值都会发生改变，那么每次改动上线之后，用户都要重新加载这个巨大的文件，这样用户体验非常糟糕。如果你说我不做文件缓存，那么由于浏览器缓存的原因，用户首次加载的文件会被缓存到本地，下次即使你更新了代码，用户执行的还是首次加载的文件，这样老板会找你聊天的。 为了解决这个问题，我们可以考虑设置多个入口文件，就像在介绍 entry 的例子代码中那样： // webpack.config.jsmodule.exports = &#123; entry: &#123; login: &#x27;src/login.js&#x27;, logout: &#x27;src/logout.js&#x27;, &#125;&#125; 通过这样的配置，我们就可以将 login.js 和 logout.js 打包成两个文件，而且修改其中一个文件不会影响到另一个的 chunkhash。看起来好像已经解决了上面的问题，但是我们再结合实际的项目深入的分析一下，我们通常会在项目中引入一些类库，比如常见的 lodash ，假设 login.js 和 logout.js 中都用到了 lodash ，这就需要在这个两个文件中显式的 import _ from &#39;lodash&#39;; 这样一来，打包出来的两个文件都包含了 lodash ，这就属于重复引用了，另外如果我们的项目是单页应用，理应只有一个入口，在需要的时候再去加载 login.js 或 logout.js 的代码。 所以我们要解决我们一开始的问题，应该从下面两个点出发： 分离代码中公共的部分，打包成一个或多个chunk 将不需要立刻执行的代码分离出来，打包成多个 chunk ，然后通过动态加载的加载这些chunk 针对第一点，我们可以使用 webpack 提供的 SplitChunksPlugin 插件，这个插件和上面介绍的 minimize 一样，需要在 optimization.splitChunks 中配置。在 production 模式下 webpack 会默认做一下代码分离的工作，但是没多大的卵用，所以还是需要我们自己动手配置。 第一步先将来自 node_modules 中的包分离出来，因为这些都是项目所依赖的第三方库，我们是不会改动的（除非升级版本），这些可以做通过 chunkhash 做长期缓存，我们把这写代码打包为 chunk-vendors // webpack.config.jsmodule.exports = &#123; entry, output: &#123; path: &#x27;./dist&#x27;, filename: &#x27;[name].[chunkhash:8].js&#x27; // 只取chunkhash的前8位 &#125;, optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendors: &#123; name: `chunk-vendors`, test: /[\\\\/]node_modules[\\\\/]/, priority: -10, chunks: &#x27;initial&#x27; &#125; &#125; &#125; &#125;&#125; 在上面的配置中，我们用 cacheGroups 将 node_modules 的代码全部分离出来。 cacheGroups 直译成中文就是缓存组，其实就是存放分离代码块规则的对象，第一个对象的 key 值是 vendors ，这个 key 值没什么用，主要还是看对应的 val 。 name：分离后打包出的文件名称。我们设置为 chunk-vendors ，那么打包出来的文件就叫 chunk-vendors.js 。因为在 output.filename 设置了 chunkhash:8，所以最终打包出的文件名称是 chunk-vendors.ac96737b.js 。后面的一串字符就是 chunkhash 的前8位。前面介绍过 chunkhash 是每一个打包出来的文件的 hash ，只要文件的内容没有改变，这个值就不会发生变化，所以只要不对我们依赖的包进行版本升级，或者增加新的包，这个值就不会变动，因此可以用这个办法进行长期缓存。 test：用于匹配的文件位置，test: /[\\\\/]node_modules[\\\\/]/ 表示所有来自 node_modules 下面的代码，可以填写具体的路径 priority：权重，这个值还是很重要的，webpack 会优先分离权重高的 cacheGroups 。 chunks：作用范围，可以设置为 async 表示对异步模块起作用， initial 表示对初始模块起作用， all 则表示对所有模块起作用。 如果打包出的 chunk-vendors 体积很大，而且包含一些经常升级的依赖，那么我们可以继续做拆分 // webpack.config.jsmodule.exports = &#123; entry, output: &#123; path: &#x27;./dist&#x27;, filename: &#x27;[name].[chunkhash:8].js&#x27; &#125;, optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendors: &#123; name: `chunk-vendors`, test: /[\\\\/]node_modules[\\\\/]/, priority: -10, chunks: &#x27;initial&#x27; &#125;, vue: &#123; name: &#x27;chuank-vue&#x27;, test: /[\\\\/]node_modules[\\\\/]vue[\\\\/]/, priority: 10, chunks: &#x27;initial&#x27; &#125; &#125; &#125; &#125;&#125; 这样我就将 vue 分离成单独一个 chunk 了，不仅减小了 chunk-vendors 的体积 ，当我们升级 vue 版本的时候，也不会影响 chunk-vendors 的 chunkhash 。注意：不要忘了设置 priority 。 除了将 node_modules 中的类库分离出来，我们自己写的代码中也有些公共的部分，比如在讲 tree-shaking 提到了 util.js ，作为一个工具方法，跟定会在项目中好多处用到，那么我们也可以将会这个公共代码分离出来： // webpack.config.jsmodule.exports = &#123; entry, output: &#123; path: &#x27;./dist&#x27;, filename: &#x27;[name].[chunkhash:8].js&#x27; &#125;, optimization: &#123; splitChunks: &#123; cacheGroups: &#123; common: &#123; name: `chunk-common`, minChunks: 2, priority: -20, chunks: &#x27;initial&#x27;, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125; 在上面的配置中，我们把被依赖超过两次（minChunks: 2）的 chunk 都分离到了 chunk-common.f4786e34.js 中。 在解决了对公共代码的分离，下一步即使处理动态加载的代码，之一部分相对简单一些，就像在介绍 babel 时提到的那样，通过 import() 来切分动态加载的代码。 webpack 在将我们的代码打包后，也会生成一些在运行时所必须的代码，这些代码默认会打包进主文件中，我们也可以将它分离出来单独打包成一个文件，这需要在 optimization.runtimeChunk 中单独配置： // webpack.config.jsmodule.exports = &#123; entry, output, optimization: &#123; runtimeChunk: &#123; name: &#x27;manifest&#x27; &#125; &#125;&#125; 这样就可以将运行时的代码也分里出来，打包为 manifest.js。 其实代码拆分是需要反复尝试的，一般情况下我们只会将 node_modules 里的包分离成一份（chunk-vendors.js）， 业务中公共的代码分离成一分（chunk-common.js），剩下的都放在了主模块（main.js） 和动态加载的 chunk 中了。但是由于项目的不同，这种方式未必是最好的，所以这需要我们反复的去尝试一各种分离的方式，为了让我们对打包后的代码有更为直观的认识，我们可以借助 webpack-bundle-analyzer 来帮我们很直观的看到打包后每一个 chunk 的大小。 webpack-dev-server在上面的介绍中，都是面向打包的，也就是说我们默认代码是无误可以直接打包上线运行，当然这是不可能滴，实际开中需要配合 Google 和 fuck 来 debug 代码，如果用上面的方法来 debug 我相信不管是谁，都会想砸电脑的，因为每次 debug 都要重新的打包，然后再想办法再本地启动一个web服务，用来托管我们打包出的静态文件。那么 webpack 可不可以帮我做到这两点呢: 监听文件变化，自动重新编译 创建一个web服务，用来托管打包后的静态文件，方便本地调试 为了解决上面两点，webpack 提供了 webpack-dev-server 这个包，它可以轻松的帮助我们实现上面两功能，这个包需要单独安装一下 npm i webpack-dev-server -D 然后在 npm script 中添加一行 ： // package.json&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --mode development&quot;, &quot;build&quot;: &quot;webpack --mode production&quot; &#125;&#125; 这时候在命令行中执行 npm run dev ，便会在本地启动一个Web服务,当命令行中出现 Compiled successfully 便表示服务启动成功，然后打开浏览器，输入 localhost:8080 便可以直接访问项目了。当源代码发生变化时，便会自动重新编译，然后刷新浏览器。 webpack-dev-server 同样也提供了一些配置选项，可以在配置文件的 devServer 中进行配置： // webpack.config.jsmodule.exports = &#123; entry, output, devServer: &#123; port: 8080, // 设置端口为8080，默认就是8080 open: true, // 编译完成后自动打开浏览器 historyApiFallback: true, // 如果你的项目使用了 HTML5 history API ，开启此项可以将所有的跳转将指向index.html &#125;&#125; 这些配置也可以以参数的形式添加在加命令行后面，但是有的配置只能以参数的形式使用，比如我们想查看编译的进度，就需要加上 --progress : // package.json&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --mode development --progress&quot;, &quot;build&quot;: &quot;webpack --mode production&quot; &#125;&#125; 学会了如何使用，在简单的介绍一下 webpack-dev-server 的工作原理，webpack-dev-server 是一个基于 express 封装的 Web 服务，当我们在执行 webpack-dev-server 时候，虽然可以看到打包之后的运行效果，但是实际上并没有生成打包后的文件，这是因为 webpack-dev-server 将打包后的内容放在了内存中，当某一个源代码文件发生变更的时候，它也不会重新的再将所有的文件打包一遍，而是只更新了一部分文件，这样的好处是可以加快重新编译的速度，加大程度的减少了开发模式下的编译时间。 讲到这里，你可能也意识到了，如果是开发模式下，有许多事情都不需要做。比如不需要设置 output ，不需要对代码压缩，不需要分离 css 和 js 等等，如果省去这些工作，首次编译的速度又会有大幅度的提升，这是一个优化点，会在后面讲到。 HMR HMR (hot module replace) 模块热替换，在不刷新页面的情况下更新代码。 在引入了 webpack-dev-server 之后，我们可以做到监听源代码变化，然后刷新浏览器及时看到修改效果。但是在前端开发中，每一步操作往往都伴随着状态和 dom 的变化，比如我们开发一个定外卖的网站，此时正在调试购物车功能，先加了一份煲仔饭，为了满减，再加一份荷包蛋，但是这时候后出现了bug，加了荷包蛋还是没有满减，原来是计算满减的方法写错了，修复这个bug之后，我们发现页面刷新了，回到最开始的样子，于是又要从选择店铺开始在走一遍流程。那可不可以在修复计算满减的方法之后，不要刷新页面也能看到正确的效果呢？这就是 HMR 实现的功能了。 开启 HMR 需要将 devServer.hot 设置为 true ，然后在 plugins 中添加 HotModuleReplacementPlugin 插件，该插件是 webpack 自带的一个插件： // webpack.config.jsmodule.exports = &#123; entry, output, plugins: [ new webpack.HotModuleReplacementPlugin() ] devServer: &#123; hot: true, /* 其他配置 */ /* ... */ &#125;&#125; 还有一种更简便的方法来开启 HRM ，那就是在命令行中添加参数 --hot ，然后在执行 npm run dev 的时候也会自动添加 HotModuleReplacementPlugin 插件。 现在我们在 webpack 中开启了 HMR 功能，webpack 可以将老模块替换为编译后的新模块，但是从浏览器层面考虑，浏览拿到新模块之后，并不知道要做什么处理，就像我们前面举的例子中提到，在修改计算满减方法之后，我们希望重新执行一遍这个方法，很明显这个需求不太现实，浏览名没那么聪明。所有这就需要我们显式的用代码来告诉浏览器来做哪些事情。 我们可以在项目代码中通过 module.hot 来判断是否启用了 HMR ，通过 module.hot.accept 来处理模块更新后的要做的事情，现在假设我们的项目入口文件是 index.js ，还有一个 util.js 里面封装了 add 方法： project├── src │ ├── index.js│ ├── util.js│ └── index.html└── webpack.config.js // util.jsfunction add(...args) &#123; return args.reduce((prev, currrent, index) =&gt; &#123; return prev + currrent; &#125;, 0);&#125;export &#123; add &#125; 然后我们在 index.js 中导入 add 方法，并且将计算结果显示在页面上： // index.jsimport &#123; add &#125; from &#x27;./util.js&#x27;;const h2 = document.createElement(&#x27;h2&#x27;);h2.innerHTML = add(&#x27;1&#x27;, &#x27;2&#x27;);document.body.appendChild(h2); 将项目跑起来之后，发现 add 方法计算的结果错了，经排查发现原来 add 方法忽略了对 string 类型的转换，只要修改一下 util.js 中的 add 函数就好了： // util.jsfunction add(...args) &#123; return args.reduce((prev, currrent, index) =&gt; &#123; return prev + currrent * 1; &#125;, 0);&#125;export &#123; add &#125; 这时候可以发现，页面中虽然显示了正确的结果，但是页面刷新了，而我们希望的是在页面不刷新的情况下显示正确结果，这时候就要在 index.js 添加热更新后需要执行的代码了： // index.jsimport &#123; add &#125; from &#x27;./util.js&#x27;;const h2 = document.createElement(&#x27;h2&#x27;);h2.innerHTML = add(&#x27;1&#x27;, &#x27;2&#x27;);document.body.appendChild(h2);if (module.hot) &#123; module.hot.accept(&#x27;./util.js&#x27;, () =&gt; &#123; h2.innerHTML = add(&#x27;1&#x27;, &#x27;2&#x27;); &#125;);&#125; 这样再去修改 add 方法的时候，h2 显示的内容会发生变化，但是页面却不会刷新，这才是我们想要的热更新。 讲到这里你可能已经发现，实现一个完美的热更新，难点不是在 webpack 的配置，而是在我们的项目代码中，我们要针对所有需要热更新的模块加上热更新之后的回调( module.hot.accept )，不过社区中已经提供了一些 loader 使 HMR 与各种框架平滑地进行交互 https://webpack.js.org/guides/hot-module-replacement/#other-code-and-frameworks ， 如果需要样式热更新的话，我们需要判断当前的环境变量是否为 development ，然后将 MiniCssExtractPlugin.loader 换成 style-loader ，因为 MiniCssExtractPlugin 还不支持 HMR ： // webpack.config.jsconst styleLoader = process.env.NODE_ENV === &#x27;development&#x27; ? &#x27;style-loader&#x27; : MiniCssExtractPlugin.loader;module.exports = &#123; entry, output, module: &#123; rules: [&#123; test: /\\.css$/, use: [styleLoader, &#x27;css-loader&#x27;] &#125;] &#125;&#125; content-base在 plugins 这一章节中，提到了 copy-webpack-plugin 这个插件，它是用来将一些静态资源拷贝到打包后的目录，但是在开发环境下，我们是通过 webpack-dev-server 创建一个 Web 服务，它的根目录默认是配置文件所在的目录，所以在开发模式下，如果需要请求一些静态资源，那么我们就需要设置一下 contentBase 。 假设我们的静态资源放在了项目根目录下的 static 文件夹下面，而且配置文件 webpack.config.js 也放在了项目根目录下，那么我么就可以将 devServer.contentBase 设置为 static ： // webpack.config.jsmodule.exports = &#123; entry, output, devServer: &#123; contentBase: &#x27;static&#x27; &#125;&#125; 假设 static 下面有一个图片 logo.png ，我们就可以通过 localhost:8080&#x2F;logo.png 来访问这张图片了。 public-path在介绍 output.publicPath 的时候提到，这个值并不会影响打包后输出的文件路径，他只是设置在线上运行的时候，所请求的资源路径，当我们在 webpack-dev-server 这个 Web 服务下调试我们的代码的时候，可能也会出现和类型的情况，这时候就需要设置一下 devServer.publicPath 了。它 output.publicPath 的区别的是 一个作用于线上环境，一个作用于我们调试的开发环境。 proxy在开发过程，经常需要调用后端提供的接口，一般情况会把接口部署在测试环境，比如 http://test.api.com 然后我们在项目中通过 ajax 的方式去调用。由于同源策略，我们在开发的时候通过 webpack-dev-server 启动的 Web 服务的域是 localhost:8080 ，很明显跨域了，接口无法调用了。这个时候有两种办法解决，一是在测试上环境上配置 cors ，将我们的 localhost 加入允许跨域的名单；二是我们在本地利用 node 去请求这个接口，然后再将请求内容发送给前端，在整个过程中 node 扮演的角色就是一个可靠的跑腿子，你去把请求交给它，它把请求送给测试环境，测试环境把响应交给它，它再把响应送到你这边。 在 webpack-dev-server 集成了中间件 (http-proxy-middleware)[https://github.com/chimurai/http-proxy-middleware] 可以很轻松的完成接口转发，比如我们想将所有的以 &#x2F;api 开头的请求都转发到 http://test.api.com 只要在 devServer.proxy 像下面这样配置即可： // webpack.config.jsmodule.exports = &#123; entry, output, devServer: &#123; proxy: &#123; &#x27;/api&#x27;: &#x27;http://test.api.com&#x27; &#125; &#125;&#125; devServer.proxy 暴露出的配置项和 (http-proxy-middleware)[https://github.com/chimurai/http-proxy-middleware] 的配置项完全一样，具体可以点击链接查看。 mock后端已经写好的接口我们我们可以用转发的方式调用，而对于还没有写好的接口我们可以通过 mock 的方式来调用，这样可以解决因为接口调用通而导致我们开发不畅的问题。因为 webpacl-dev-server 是基于 express 封装了，并且将 express 的实例暴露在了 devServer.before 和 devServer.after 这两个配置项下面，所以我们完全可以将后端没有写好的接口在 devServer.before 通过 express 去 mock 。假设我们现在需要调用 /api/user/creation 这个接口来创建用户，我们可以这样 mock // webpack.config.jsmodule.exports = &#123; entry, output, devServer: &#123; befor(app) &#123; app.post(&#x27;/api/user/creation&#x27;, (req, res) =&gt; &#123; // some code res.json(&#123;success: true&#125;); &#125;); &#125; &#125;&#125; 如果你需要 mock 的接口后端，那你完全可以像写 express 那样去写接口，当然有些常用的中间件需要我们自己去安装。 其它source-mapswebpack 打包压缩之后的代码可读性几乎为零，同时也不方便调试，这时候可以通过设置 devtool 选项来帮助我们在开发环境调试，具体效果是：在 chrome 中(其它高级浏览器同样支持)打开控制台，我们可以在 Sources 中看到一个以 webpack:// 开头的资源，里面的内容和我们编写代码大致相同(这取决于 devtool 的值)。 由于 devtool 会影响打包的速度和打包后的代码质量，所以在生产环境的构建中，不建议开启此项(默认为none)，只要在开环境设置为 eval-source-map 即可。其它配置和打包速度可以参考 官网 。 alias当项目的目录结构越来越深，模块变得越来越多的时候，模块间的引用会变得很混乱，时常会看到下面这样的代码： import ComponentA from &#x27;../../../../../components/a.component.js&#x27;;import ServiceA from &#x27;../../../../../service/a.service.js&#x27;; 有没有想骂人的冲动？这时候可以使用 webpack 的 alias 选项来解决这个问题，配置文件的内容如下： // webpack.config.jsmodule.exports = &#123; entry, output, resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &quot;src&quot;), &#x27;components&#x27;: path.resolve(__dirname, &quot;src/components&quot;), &#x27;services&#x27;: path.resolve(__dirname, &quot;src/services&quot;), &#125; &#125;&#125; 上面的配置表示为 src、src/components、src/services 分别设置一个别名，我们就可以在代码中用 @ 表示相对路径 src 而不必再使用 ../../ 一层一层的向上查找了。假设我们现在的项目结构是下面这样子: project├── src│ ├── components│ └── services└── webpack.config.js 这样我们可以在任意文件夹下的代码内使用 @ 来表示根目录 src/，使用 components 来表示路径 src/components/ ，所以上面例子中的代码可以在简化为： import ComponentA from &#x27;@/components/a.component.js&#x27;;import ServiceA from &#x27;services/a.service.js&#x27;; 这样配置之后，webpack 在打包编译的时候能识别简化之后的路径，但是编辑器却未必能识别，这又给我们开发带来了一些困扰，如果你是 vscode 用户的话，这个问题可以很好的解决。只要在项目的根目录添加一份配置文件 jsconfig.json 即可，配置文件的内容如下： &#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, // 根目录 &quot;paths&quot;: &#123; &quot;@/*&quot;: [ &quot;./src/*&quot; ], &quot;components/*&quot;: [ &quot;./src/components/*&quot; ], &quot;services/*&quot;: [ &quot;./src/services/*&quot; ], &#125; &#125;&#125; 这个配置文件和 webpack 是没有关系的，它是给 vscode 用的，想请可以查看这里：https://code.visualstudio.com/docs/languages/jsconfig extensions在原生的 JavaScript 中，使用 import 加载一个模块是可以不用写文件的扩展名的，nodejs 中的 require 也是一样，就像这样：import ModuleA from &#39;a&#39; ，现在有了 loader 我们也希望 import 其它类型文件的时候也不写扩展名，比如 import styles from &#x27;@/styles/common&#x27;;import html from &#x27;@/tpl/login&#x27;; 只需在 webpack 中配置 extensions 即可，具体代码如下： // webpack.config.jsmodule.exports = &#123; entry, output, resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.json&#x27;, &#x27;.css&#x27;, &#x27;.html&#x27;] &#125;&#125; 该选项的值是一个数组，默认值为 [&#39;.js&#39;, &#39;.json&#39;] ，当我们手动配置之后，默认值会被覆盖，所以为了不影响之前的写法，要在配置中将 .js 和 .json 也加上。 个人建议不要配置此项，尽量把文件的扩展名写全，这样不仅可以知道引入的文件是什么类型，而且在打包的时候速度也相对快一些。 externals开发一个 Web 项目肯定会用到第三方的类库比如 jQuery、lodash 等，有人会选从 npm 下载，有人会选择从 cdn 加载。这两种方式使用起来都很简单： 从 npm 下载的包只需在用到的时候 import 就行了：import _ from &#39;lodash&#39; 从 cdn 加载类库只要在 html 页面通过 script 引入之后（注意引用顺序），便可以在任何地方使用 但是从 cdn 引入的资源在开发过程有一个很不好的地方：既然已经是模块化开发了，突然冒出一个全局变量会让人觉得很莫名其妙，而且这个变量也不能类型提示。 那可不可以这样子呢： 从 cdn 加载第三方类库（速度快） 在代码中依然使用 import 的方式来引入资源（代码模块清晰） 打包的时候排除从cdn加载的资源（减小打包后的代码体积） 答案是可以的，配置一下 externals 就可以轻松实现，以 jQuery 为例，具体代码如下： // webpack.config.jsmodule.exports = &#123; entry, output, externals: &#123; jquery: &#x27;jQuery&#x27; &#125;&#125; 在代码中就可以这样使用 jQuery : import $ from &#x27;jquery&#x27;;$(() =&gt; &#123; console.log(&#x27;hello jQuery&#x27;);&#125;); 而且打包的时候会自动的把 jquery 排除掉。 从上面的配置中可以看出，externals 是一个对象，它的 key (jquery) 对应的是代码中引入的包名，也就是 from 后面的字符串，它的 val (jQuery) 就是暴露在全局的变量名，jQuery 暴露在全局的变量名为 jQuery 和 $ ，所以这里换成 $ 同样是可以的。 所以上面的代码可以理解为是下面这种写法： const $ = window.jQuery;$(() =&gt; &#123; console.log(&#x27;hello jQuery&#x27;);&#125;); 如果想对这个选项有更多的理解，可以参考这里：https://github.com/zhengweikeng/blog/issues/10 分离配置文件上面的配置中，有的是适用于生产环境的，有的是适用于开发环境的，所以我们要将配置文件做一下分离。在项目中创建 build 文件夹，用来存放我们的构建脚本，在 build 中创建 webpack.common.js 我们可以将一些通用的配置写在这里面，比如 entry、output、loader 等等。然后我们在创建 webpack.prod.js 和 webpack.dev.js 两份配置文件，分别用来编写打包和开发是的脚本，已经在webpack.common.js 中写好的配置，就不需要在写了。然后我们利用 webpack-merge 将通用的配置分别和 dev、prod 的配置合并： // build/webpack.prod.jsconst merge = require(&#x27;webpack-merge&#x27;); const webpackCommonConfig = require(&#x27;./webpack.common&#x27;);module.exports = merge(webpackCommonConfig, &#123;/** 针对打包到生产环境的配置 */&#125;); 最后再利用 npm script 设置不同的脚本 &#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --mode development --color --progress --config build/webpack.dev.js&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125;&#125; 这里我已经写好一份可以直接使用的配置，大家可以参考一下 webpack-workbench","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://onlymisaky.github.io/tags/webpack/"}]},{"title":"震惊！JavaScript竟然可以类型推断！","slug":"震惊！JavaScript竟然可以类型推断！","date":"2018-07-04T07:53:51.000Z","updated":"2024-09-11T03:04:29.086Z","comments":true,"path":"2018/07/04/","permalink":"http://onlymisaky.github.io/2018/07/04/","excerpt":"","text":"作为弱类型的 JavaScript 写起来爽，维护起来更爽。\u0005—— 鲁迅·沃梅硕果 近几年，前端技术的发展可以用 Big Boom 来形容，因此 JavaScript 也被大规模的运用在项目中，由此也产生了代码的维护问题，所谓 动态类型一时爽，代码重构火葬场 。 其实不仅仅是代码重构，在日常开发中也能感受到弱类型语言的不足。举个例子，现在有个函数 renderUserList , 作用是将用户列表显示在界面上 function renderUserList(el, userList) &#123; let html = &#x27;&#x27;; for (const user of userList) &#123; html += ` &lt;div&gt; 姓名：$&#123;user.age&#125; 年龄：$&#123;user.age&#125; &lt;/div&gt; ` &#125; el.innerHTML = html;&#125; 我敢打赌，大家在写这种类型函数的时候，都是在盲写，因为我们不知道传入的 el 和 userList 到底是什么类型。更不知道 el 下面有哪些方法，写的时候都如此费劲，跟别谈维护了。其实我们可以通过一些简单的操作，让这个函数写起来更轻松，就像下面一样： 那么，到底是怎么实现的呢？接下来就要介绍本文的主角 JSDoc 和 VSCode JSDoc是一个根据javascript文件中注释信息，生成JavaScript应用程序或库、模块的API文档 的工具。你可以使用他记录如：命名空间，类，方法，方法参数等。 在 VSCode 中会自动根据 JSDoc 的标注对变量、方法、方法参数等进行类型推断，通过 TypeScript 来进行智能提示，因此从编写注释开始学习 TypeScript 也是一个不错的选择。 变量用 @type 标注变量的类型 基础类型/** * @type &#123;number&#125; */let n;/** @type &#123;boolean&#125; */let flag;/** @type &#123;string&#125; */let str; 联合类型如果一个变量可能是多种类型，则可以使用联合类型 /** * @type &#123;string | boolean&#125; */let x; 自定义类型我们经常用到自定义类型，也就是 JavaScript 中的对象，对于简单的对象，可以用下面的写法 /** * @type &#123;&#123;name: string, age: number&#125;&#125; */let user; 对于键值对比较多的复杂对象，可以使用 @typedef 来定义复杂类型，用 prop 或者 property 来定义对象的属性。 /** * @typedef &#123;Object&#125; goods * @property &#123;string&#125; name * @prop &#123;number&#125; code * @prop &#123;string=&#125; thumbnail 用 = 表示该属性是可能存在，也可能不存在 * @prop &#123;string&#125; [introduction] 也可以给属性名加上 [] 表示这是一个可选属性 * @prop &#123;string[]&#125; label */ /** * @type &#123;goods&#125; */ let phone; 数组可以使用 [] 或者 Array 表示数组 /** * @type &#123;number[]&#125; */let numList;/** * @type &#123;Array&lt;string&gt;&#125; */let strList; 对于已经定义的类型或者已经声明的变量，也是可以直接使用，下面分别声明一个 user 数组和 goods 数组 /** * @type &#123;user[]&#125; */let userList;/** * @type &#123;goods[]&#125; */let goodsList; 如果不确定数组的每一项具体类型，可以使用 any * 或者交叉类型 /** * @type &#123;any[]&#125; */let arr1;/** * @type &#123;*[]&#125; */let arr2;/** * @type &#123;(user | goods)[]&#125; */let arr3 泛型/** * @template T * @param &#123;T&#125; p1 * @return &#123;T&#125; */function gen(p1) &#123; return p1 &#125; 函数用 @name 表示函数的名称 用 @param 表示函数的参数 用 @return 或 @returns 表示函数的返回值 一般函数的写法大致分为两种：声明式函数和函数表达式。 函数表达式/** * @type &#123;function (number, number): number&#125; */var getSum = (n1, n2) =&gt; n1 + n2; 声明式函数/** * @name fn * @param &#123;string&#125; str * @param &#123;boolean&#125; flag * @returns &#123;*[]&#125; */function fn(str, flag) &#123; return [];&#125; 通过上面的注释写法，便可以在函数 fn 内部正确的识别出两个参数的类型，并且该函数返回值类型为数组。 对于函数参数的类型，写法和上面的变量写法一致，区别是将 @type 换成了 @param，函数的返回值也是同样的道理。 对象的方法对函数的注释同样适用于对象的方法 var o = &#123; /** * @param &#123;string&#125; msg * @returns &#123;void&#125; */ say(msg) &#123; console.log(msg); &#125;&#125; 内置类型和其它类型上面的例子只是简单的用到了一些常见的类型，然而在实际开发中，我们用到的不止这些，比如开始文章开头的例子中，有用到了 DOM 对象，那该怎么编写注释呢？其实 VSCode 已经为我们提供了很多的类型了，比如 DOM 对象对应的类型是 HTMLElement , 事件对象对应的类型是 Event，同时 DOM 对象还可以更细化，比如 HTMLCanvasElement 、HTMLImageElement 等等。 同时，我们在开发中也会用到第三方的类库或框架，通常情况下，这些类库都会有一份以 d.ts 结尾的声明文件，该声明文件中包含了所用到类型的所有提示，以最为经典的 jQuery 为例，如果在时在 webpack 环境下，在通过 npm 安装 jQuery 后，需要再单独安装对应的声明文件 @types/jquery ，这样 VSCode 就可以正确的识别 $ 符号，也可以在 JSDoc 中使用 JQuery, JQueryStatic 等这都类型了，就像下面这样 /** * @type &#123;JQuery&#125; */var $btn = $(&#x27;button&#x27;);/** * @param &#123;number&#125; userId * @returns &#123;JQuery.jqXHR&#125; */function getUser(userId) &#123; return $.get(`/user/$&#123;userId&#125;`);&#125; 大部分情况下，通过 npm 发布的包，都会包含其对应的声明文件，如果没有的话，可以通过这个地址 TypeSearch 来搜索一下并安装 ，如果感兴趣可以到这个仓库 DefinitelyTyped 看看。当然你也可以提供一些仓库内目前还没有声明文件，别人会非常感谢你的！ 当然并不是所有的项目都用到了 npm ，仍有很多项目在使用 script 这种方式从 cdn 来引入 .js 文件，这种情况下用不到 webpack ，也用不到 npm ，那这个时候就要从上面所提到的仓库地址 DefinitelyTyped 来下载对应的声明文件了，然后通过 /// &lt;reference path=&quot;&quot; /&gt; 这种形式来引入声明文件，就像下面这样 /// &lt;reference path=&quot;./node_modules/@types/jquery/index.d.ts&quot;/&gt; 个人建议：即使是通过 cdn 方式来引入 .js 文件，也可以通过 npm 来安装 @types/ ，这样和在每个文件中通过 /// &lt;reference path=&quot;&quot; /&gt; 引入声明文件相比，还是方便很多的。 总结以上便是关于利用 JSDoc 实现 JavaScript 的类型提示。当然还有一些更深入的用法，比如全局模板文件，命名空间等，但是这些和 TypeScript 关系更大一些。当有一天你发现 JSDoc 已经不能满足你的时候，便是向着 TypeScript 大举进攻的时候了。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://onlymisaky.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://onlymisaky.github.io/tags/TypeScript/"},{"name":"JSDoc","slug":"JSDoc","permalink":"http://onlymisaky.github.io/tags/JSDoc/"}]},{"title":"记一次node转发接口的配置经历","slug":"记一次node转发接口的配置经历","date":"2018-05-10T09:43:30.000Z","updated":"2024-09-11T03:04:29.078Z","comments":true,"path":"2018/05/10/","permalink":"http://onlymisaky.github.io/2018/05/10/","excerpt":"","text":"最近在对一个老项目前端部分进行重构，由于该项目中有一部分是用 vue 写的，所以重构的技术选型自然而然就是 vue 了。重构的目标是前后端分离，让前端代码可以更好的被维护。 讨论完方案之后，撸起袖子开始干。首先用 vue-cli 快速搭建项目，既然是前后端分离，那接口肯定要做一下转发，这都不算事，webpack 的 devServer 集成了 http-proxy-middleware 这个中间件，转发接口so easy。 由于后端提供的接口不是 restful 风格的，也没有个统一的 prefix ，这样就需要将所有的接口列举出来，然后遍历转发，所以为了让 proxy 配置更加简单，需要在请求的时候做一些处理，如果是 development 环境 ，就统一加上一个 prefix ，如果是 production 环境就不加，vue-cli 已经帮我们集成好了环境变量，所以只要在统一封装的 http 请求中加上一行就好了： const prefix = process.env.NODE_ENV === &#x27;development&#x27; ? &#x27;/api&#x27; : &#x27;&#x27;; webpack 中配置也很简单： // config/index.js/* some config code */proxyTable: &#123; &#x27;/api&#x27;: &#123; target: &#x27;https://xxx.dev.com/&#x27;, changeOrigin: true, pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;/&#x27; &#125; &#125;&#125;/* some config code */ 是的，就是这么简单，npm run dev 跑起来，然而，出现了这一幕： 500 服务器又打盹了？但是这个返回信息不像是服务器返回的信息啊，咋回事？ 会不会是我配置错了？不应该啊，这么简单怎么可能配置错呢？ 是接口的问题？也不可能啊，postman 可以跑的通啊。 难道是后端做了处理，禁止转发？更不可能啊，有这技术还不把爬虫搞死。 要不我用 node 来请求一下试试看吧，但是。。。还是报错了 错误信息：certificate has expired 。虽然我的英语很垃圾，但是还是能猜出来啥意思 证书过期。等等，这个错误在重点里面也出现了： CERT_HAS_EXPIRED 不要慌，既然终端有提示，那咱就点进链接去看看，然而我并没有在提示的链接中找到任何相关的错误信息 这一刻，我感觉我被针对了，但是依旧不能慌，冷静思考一下，证书是啥玩意，好像有点印象，https 需要 SSL 证书，而且我转发的这个接口确实是 https 。真相浮出水面了，当我用浏览器打开转发的这个接口时，也就更加确信了我的想法 最终在 stackoverflow 找到了解决方案 试一下效果 破费！完美解决这个问题！BTW ， 怎么在 webpack 中解决呢，我试了在所有的配置文件中加上这一行神奇的代码，但是都没有效果，甚至借助了 cross-env 这个包在启动时修改环境变量，但最终都无济于事。难道要我去改 webpack 的源码吗？配置都那么头疼了，更别说改了。去给官方提个 issue ？ 一时半会也不会有人回应的。就在穷途末路之时，我有打开了 http-proxy-middleware 的 npm 主页，然后我发现了这一行 一口老血喷了出来。为什么我这么懒不愿意去看文档！为什么我英语这么差读不懂文档！到底为什么！！！！ 总结：** http-proxy-middleware 转发不安全的 https 一定要将 secure 设置为 false** 再总结：程序员已经要好好读文档，好好学英语。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://onlymisaky.github.io/tags/webpack/"},{"name":"node","slug":"node","permalink":"http://onlymisaky.github.io/tags/node/"},{"name":"http-proxy-middleware","slug":"http-proxy-middleware","permalink":"http://onlymisaky.github.io/tags/http-proxy-middleware/"}]},{"title":"JavaScript 和 TypeScript 中的 class","slug":"JS 和 TS 中的 class","date":"2018-04-19T03:33:25.000Z","updated":"2024-09-11T03:04:28.922Z","comments":true,"path":"2018/04/19/","permalink":"http://onlymisaky.github.io/2018/04/19/","excerpt":"","text":"对于一个前端开发者来说，很少用到 class ，因为在 JavaScript 中更多的是 函数式 编程，抬手就是一个 function，几乎不见 class 或 new 的踪影。所以 设计模式 也是大多数前端开发者的一个短板。 最近在学习 Angular 的过程中发现其大量的运用了 class，不得不佩服，Angular 确实是一个优秀的、值得深入研究的 框架。 本文将简单的介绍一下 JavaScript 和 TypeScript 中的 class。 基本概念在介绍 class 之前，要先介绍一些基本的概念。 静态成员 类自身的成员，可以继承，但实例无法访问，一般多见于工具类，比如在jQuery时代最常见的 $.ajax ，ajax 便是 $ 的静态方法，使用方便，不需要再通过 new 或者函数调用的得到一个新实例。 私有成员 类内部的成员，一般是不能继承的，只能在内部使用，实例无法访问，有一点点像闭包内部的变量，但是还是一定的差别，目前 JavaScript 无法直接定义私有成员，只能通过其它方式辅助实现。 getter&#x2F;setter 存取器属性，当我们访问或者修改一个实例的属性的时候，我们可通过存取器属性拦截这两个操作，从而做一些其它的事情，vue正是通过这个api来实现对数据变化的追踪。 实例成员 指 new 出来的实例所具有的成员，可以被继承，也是通过这个特性实现了代码的复用。 抽象类，抽象方法 抽象类指不可以被实例化的类，通过 new 关键字调用会报错，一般都被设计成父类。 抽象方法，只提供方法的名称，参数和返回值，不负责实现，具体的实现由子类去完成，如果一个子类继承于抽象类，那么这个子类必须实现父类所有的抽象方法，否则会报错。 这两个概念在 JavaScript 都无法直接实现，但在 TypeScript 或 其它面向对象语言中可以轻松实现，另外这个特性也是用于实现 多态 的重要手段。 案例介绍为了更好的介绍 class，本文将采用三个 类 来做例子，分别是 Person、Chinese、American。从字面上可以很快的知道： Person 是 父类(基类) ，Chinese 和 American 是 子类(派生类) 。 Person 有 name、age、gender 三个属性，sayHello 方法和 fullName 存取器属性。同时 Person 还有一些 静态成员 和 私有成员 ，由于实在太难想例子了，所以就用 foo、bar、x、y、z 这些来代替吧。 作为子类的 Chinese 和 American 继承了 Person 的实例成员和静态成员。同时它们自身也有一些自己的方法和属性: Chinese 有 kungfu 属性，会习武 martial。 American 有 twitter，还可以 sendTwitter。 接下来我们就分别使用 JavaScript 和 TypeScript 来实现这个案例。 JavaScript 中的 classJavaScript 中的 class 要分开说，在 ES6 中提供了两个关键字 class 和 extends ，虽然它们只是语法糖，底层还是再利用 prototype 实现继承的，但是不能否认，这中写法确实让代码更清晰，更易读。 ES6 中的 classclass Person &#123; // #x = &#x27;私有属性x&#x27;; // static x = &#x27;静态属性x&#x27;; // name; // age; // gender; // 上面的写法还在提案中，并没有成为正式标准，不过变化的可能性已经不大了。 // 顺便吐槽一下，用 # 表示私有成员，真的是很无语. /** * Person的静态方法，可以被子类继承 * 可以通过 this 访问静态成员 */ static foo() &#123; console.log(`类 $&#123;this.name&#125; 有一个 $&#123;this.x&#125;`); &#125; constructor(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; /** * 数据存储器，可以访问实例成员，子类的实例可以继承 * 以通过 this 访问实例成员 */ get fullName() &#123; const suffix = this.gender === &#x27;男&#x27; ? &#x27;先生&#x27; : &#x27;女士&#x27;; return this.name + suffix; &#125; set fullName(value) &#123; console.log(`你已改名为 $&#123;value&#125; `); &#125; /** * Person的实例方法，可以被子类的实例继承 * 可以通过 this 访问实例成员 */ sayHello() &#123; console.log(`你好我是 $&#123;this.fullName&#125; ,我 $&#123;this.age&#125; 岁了`); &#125;&#125;Person.x = &#x27;静态属性x&#x27;; class Chinese extends Person &#123; static bar() &#123; console.log(`类 $&#123;this.name&#125; 的父类是 $&#123;super.name&#125;`); super.foo(); &#125; constructor(name, age, gender, kungfu) &#123; super(name, age, gender); this.kungfu = kungfu; &#125; martial() &#123; console.log(`$&#123;this.name&#125; 正在修炼 $&#123;this.kungfu&#125; `); &#125;&#125; class American extends Person &#123; // static y = &#x27;静态属性y&#x27;; static bar() &#123; console.log(`类 $&#123;this.name&#125; 有自己的 $&#123;this.y&#125; ，还继承了父类 $&#123;super.name&#125; 的 $&#123;super.x&#125;`); &#125; constructor(name, age, gender, twitter) &#123; super(name, age, gender); this.twitter = twitter; &#125; sendTwitter(msg) &#123; console.log(`$&#123;this.name&#125; : `); console.log(` $&#123;msg&#125;`); &#125;&#125;American.y = &#x27;静态属性y&#x27;; Person.x; // 静态属性xPerson.foo(); // 类 Person 有一个 静态属性xChinese.x; // 静态属性xChinese.foo(); // 类 Chinese 有一个 静态属性xChinese.bar(); // 类 Chinese 的父类是 PersonAmerican.x; // 静态属性xAmerican.y; // &#x27;静态属性yAmerican.foo(); // 类 American 有一个 静态属性xAmerican.bar(); // 类 American 有自己的 静态属性y ，还继承了父类 Person 的 静态属性xconst p = new Person(&#x27;Lucy&#x27;, 20, &#x27;女&#x27;);const c = new Chinese(&#x27;韩梅梅&#x27;, 18, &#x27;女&#x27;, &#x27;咏春拳&#x27;);const a = new American(&#x27;特朗普&#x27;, 72, &#x27;男&#x27;, &#x27;Donald J. Trump&#x27;);c.sayHello(); // 你好我是 韩梅梅女士 ,我 18 岁了c.martial(); // 韩梅梅 正在修炼 咏春拳 a.sayHello(); // 你好我是 特朗普先生 ,我 72 岁了a.sendTwitter(&#x27;推特治国&#x27;); // 特朗普 : 推特治国 ES6 之前的 classES5 的继承，实质是先创造子类的实例对象 this， 然后再将父类的方法添加到 this 上面 Parent.apply(this) 。 ES6 的继承机制完全不同，实质是先创造父类的实例对象 this，所以必须先调用 super 方法， 然后再用子类的构造函数修改this。 为了实现继承，我们需要先实现一个 extendsClass 函数，它的作用是让子类继承父类的静态成员和实例成员。 function extendsClass(parent, child) &#123; // 防止子类和父类相同名称的成员被父类覆盖 var flag = false; // 继承静态成员 for (var k in parent) &#123; flag = k in child; if (!flag) &#123; child[k] = parent[k]; &#125; &#125; // 继承父类prototype上的成员 // 用一个新的构造函数切断父类和子类之间的数据共享 var F = function () &#123; &#125; F.prototype = parent.prototype; var o = new F(); for (var k in o) &#123; flag = k in child.prototype; if (!flag) &#123; child.prototype[k] = o[k]; &#125; &#125;&#125; function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = this.gender; // 如果将 getter/setter 写在 prototype 会获取不到 Object.defineProperty(this, &#x27;fullName&#x27;, &#123; get: function () &#123; var suffix = this.gender === &#x27;男&#x27; ? &#x27;先生&#x27; : &#x27;女士&#x27;; return this.name + suffix; &#125;, set: function () &#123; console.log(&#x27;你已改名为 &#x27; + value + &#x27; &#x27;); &#125;, &#125;);&#125;Person.x = &#x27;静态属性x&#x27;;Person.foo = function () &#123; console.log(&#x27;类 &#x27; + this.name + &#x27; 有一个 &#x27; + this.x);&#125;Person.prototype = &#123; constructor: Person, // get fullName() &#123; &#125;, // set fullName(value) &#123; &#125;, sayHello: function () &#123; console.log(&#x27;你好我是 &#x27; + this.fullName + &#x27; ,我 &#x27; + this.age + &#x27; 了&#x27;); &#125;,&#125;; function Chinese(name, age, gender, kungfu) &#123; // 用call改变this指向，实现继承父类的实例属性 Person.call(this, name, age, gender); this.kungfu = kungfu;&#125;Chinese.bar = function () &#123; console.log(&#x27;类 &#x27; + this.name + &#x27; 的父类是 &#x27; + Person.name); Person.foo();&#125;Chinese.prototype = &#123; constructor: Chinese, martial: function () &#123; console.log(this.name + &#x27; 正在修炼 &#x27; + this.kungfu + &#x27; &#x27;); &#125;&#125;;extendsClass(Person, Chinese); function American(name, age, gender, twitter) &#123; Person.call(this, name, age, gender); this.twitter = twitter;&#125;American.y = &#x27;静态属性y&#x27;;American.bar = function () &#123; console.log(&#x27;类 &#x27; + this.name + &#x27; 有自己的 &#x27; + this.y + &#x27; ，还继承了父类 &#x27; + Person.name + &#x27; 的 &#x27; + Person.x);&#125;American.prototype = &#123; constructor: American, sendTwitter: function (msg) &#123; console.log(this.name + &#x27; : &#x27;); console.log(&#x27; &#x27; + msg); &#125;&#125;;extendsClass(Person, American); TypeScript 中的 class讲完了 JavaScript 中的类，还是没有用到 抽象类，抽象方法，私有方法这三个概念，由于 JavaScript 语言的局限性，想要实现这三种概念是很困难的，但是在 TypeScript 可以轻松的实现这一特性。 首先我们稍微修改一下例子中的描述，Person 是抽象类，因为一个正常的人肯定是有国籍的，Person 的 sayHello 方法是抽象方法，因为每个国家打招呼的方式不一样。另外一个人的性别是只能读取，不能修改的，且是确定的是，不是男生就是女生，所以还要借助一下枚举。 enum Gender &#123; female = 0, male = 1&#125;; abstract class Person &#123; private x: string = &#x27;私有属性x，子类和实例都无法访问&#x27;; protected y: string = &#x27;私有属性y，子类可以访问，实例无法访问&#x27;; name: string; public age: number; public readonly gender: Gender; // 用关键字 readonly 表明这是一个只读属性 public static x: string = &#x27;静态属性x&#x27;; public static foo() &#123; console.log(`类 $&#123;this.name&#125; 有一个 $&#123;this.x&#125;`); &#125; constructor(name: string, age: number, gender: Gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; get fullName(): string &#123; const suffix = this.gender === 1 ? &#x27;先生&#x27; : &#x27;女士&#x27;; return this.name + suffix; &#125; set FullName(value: string) &#123; console.log(`你已改名为 $&#123;value&#125; `); &#125; // 抽象方法，具体实现交由子类完成 abstract sayHello(): void;&#125; class Chinese extends Person &#123; public kungfu: string; public static bar() &#123; console.log(`类 $&#123;this.name&#125; 的父类是 $&#123;super.name&#125;`); super.foo(); &#125; public constructor(name: string, age: number, gender: Gender, kungfu: string) &#123; super(name, age, gender); this.kungfu = kungfu; &#125; public sayHello(): void &#123; console.log(`你好我是 $&#123;this.fullName&#125; ,我 $&#123;this.age&#125; 岁了`); &#125; public martial() &#123; console.log(`$&#123;this.name&#125; 正在修炼 $&#123;this.kungfu&#125; `); &#125;&#125; class American extends Person &#123; static y = &#x27;静态属性y&#x27;; public static bar() &#123; console.log(`类 $&#123;this.name&#125; 有自己的 $&#123;this.y&#125; ，还继承了父类 $&#123;super.name&#125; 的 $&#123;super.x&#125;`); &#125; public twitter: string; public constructor(name: string, age: number, gender: Gender, twitter: string) &#123; super(name, age, gender); this.twitter = twitter; &#125; public sayHello(): void &#123; console.log(`Hello, I am $&#123;this.fullName&#125; , I&#x27;m $&#123;this.age&#125; years old`); &#125; public sendTwitter(msg: string): void &#123; console.log(`$&#123;this.name&#125; : `); console.log(` $&#123;msg&#125;`); &#125;&#125; Person.x; // 静态属性xPerson.foo(); // 类 Person 有一个 静态属性xChinese.x; // 静态属性xChinese.foo(); // 类 Chinese 有一个 静态属性xChinese.bar(); // 类 Chinese 的父类是 PersonAmerican.x; // 静态属性xAmerican.y; // &#x27;静态属性yAmerican.foo(); // 类 American 有一个 静态属性xAmerican.bar(); // 类 American 有自己的 静态属性y ，还继承了父类 Person 的 静态属性xconst c: Chinese = new Chinese(&#x27;韩梅梅&#x27;, 18, Gender.female, &#x27;咏春拳&#x27;);const a: American = new American(&#x27;特朗普&#x27;, 72, Gender.male, &#x27;Donald J. Trump&#x27;);c.sayHello(); // 你好我是 韩梅梅女士 ,我 18 岁了c.martial(); // 韩梅梅 正在修炼 咏春拳 a.sayHello(); // Hello, I am 特朗普先生 , I&#x27;m 72 years olda.sendTwitter(&#x27;推特治国&#x27;); // 特朗普 : 推特治国","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://onlymisaky.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://onlymisaky.github.io/tags/TypeScript/"},{"name":"面向对象","slug":"面向对象","permalink":"http://onlymisaky.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Cmder Windows 下的终端神器","slug":"Cmder Windows 下的终端神器","date":"2018-03-08T01:50:12.000Z","updated":"2024-09-11T03:04:28.922Z","comments":true,"path":"2018/03/08/","permalink":"http://onlymisaky.github.io/2018/03/08/","excerpt":"","text":"废话Windows 下常用的终端有两个，古老的 cmd 和功能强大但你记不住函数的 PowerShell ，两者我都用过一段时间，给我的提体验是功能够用，界面丑陋，虽然 win10 下可以通过调整背景颜色、透明度，字体大小、颜色等来让它看起来不那么丑，但是还是丑，而且它不能实现我最想要的功能，多标签，为什么会有这个需求，看了下面这张图你就能体会到我的痛苦了。 期间我也用过 xshell ，但是它给我的感觉怪怪，很僵硬； Git Bash 也用过。说实话，我用它纯粹是因为我不想用 sourcetree 这种图形化的工具，但是又记不住 git 的函数，所以只好借助 Git Bash 的智能感应来补全命令。 直到后来有一天，我偶然间在知乎发现了有人推荐了一款终端 Cmder ！它简直是我的救星。 功能介绍Cmder 是 Windows 下的一款终端软件，它有着许多优点 软件为压缩包，解压即可使用 支持 git、ls、curl等命令 可以自定义终端 提供多种主题，而且可以自定义 支持多标签，分屏 … 安装直接到官网下载压缩包，解压即可使用。强烈建议下载完整版的，完整版内置了 git 工具，非常好用！ 下载完成后解压到任意文件夹即可，这里我解压到了 D:\\Program Files\\Green\\cmder 这个目录，建议路径中不要出现中文。双击 Cmder.exe 文件就可以直接使用了。 文本到此结束，感谢阅读！ 配置不要激动！不要激动！我知道你想要什么，放下你的板砖，请继续往下看。 环境变量首先我们需要配置下环境变量。 变量名 CMDER_HOME 变量值 软件的绝对路径 如果你不会配置，请跟着我的步骤来 右击 此电脑 ，点击 属性 点击左侧 高级系统设置 ，弹出 系统属性窗口 ，点击下方 环境变量 按钮 点击系统变量下的 新建 按钮 变量名里面输入 CMDER_HOME ，变量值里面输入刚才解压的路径 D:\\Program Files\\Green\\cmder 然后点击 确定 在系统环境变量下找到 path ，选中后点击下方的 编辑按钮 在弹窗中点击 新建，然后输入 %CMDER_HOME% 点击确定，便完成了环境变量的配置 如果你想验证有没有配置成功，按下 win + r 键，输入 cmder 。如果配置成功，就能开打 Cmder 的界面。 右键菜单很多时候，我们希望在某个文件直接打开终端，其实我们上面配置环境变量就是为这一步服务的。 以管理员方式打开 cmd 或者 PowerShell ，输入 Cmder.exe /REGISTER ALL 回车执行命令，这样就完成了设置。 我们可以打开任意文件夹，在空白处，便可以看到 Cmder Here 的字样，点击便可以在此处打开 Cmder 基本使用打开 Cmder 后，使用快捷键 Win + Alt + p打开设置界面，或者点击右下角的菜单按钮，选择 Settings 也可进入设置界面。 外观配置如果你英文不好，可以在参照下图设置字体和主题另外还可以通过 Main 选项中的 Tab bar 和 Task bar 来分别设置标签和在任务栏中的显示方式。 设置默认终端如果你有其它的command希望通过 Cmder 打开，可以在 Startup 下的 Tasks 中添加。里面已经默认帮你配置了 Cmder、PowerShell、MinTTY、Git Bash。 默认启动的是 Cmder ，如果你想默认启动其它的command，你可以在 Startup 设置为其它的command 同时还可以快速的切换当前使用的终端，假设你正在使用的 cmd ，这时输入 bash 回车一下，便可以将当前标签页的终端切换成 Git Bash 中文和命令ll支持Cmder 是不支持中文和 ll 命令的，这需要你在 Startup 下的 Environment 中设置一下。将 set LANG=zh_CN.UTF-8 和 alias ll=ls -al --show-control-chars --color $* 添加到 Environment 即可。熟悉 linux 的朋友应该知道 alias 的含义 快捷键很高兴的告诉你， Cmder 的很多快捷键和 Chrome 是一致的，比如 Ctrl + w 是关闭当前标签，Ctrl + Tab 是来回切换标签， Ctrl + t 是新建标签，对了在新建标签的时候你可以通过 New console split 选项来设置分屏。右击某个标签还可以对标签进行重命名。如果默认的快捷键和你正在使用的其它软件冲突了，你可以在 Settings 中的 Key &amp; Macro 修改快捷键。","categories":[],"tags":[{"name":"Cmder","slug":"Cmder","permalink":"http://onlymisaky.github.io/tags/Cmder/"}]},{"title":"git基本使用","slug":"git基本使用","date":"2018-03-07T07:48:46.000Z","updated":"2024-09-11T03:04:28.942Z","comments":true,"path":"2018/03/07/","permalink":"http://onlymisaky.github.io/2018/03/07/","excerpt":"","text":"配置 command 说明 git config –global user.name YourName git config –global user.email YourEmail git config credential.helper store –file&#x3D;git_credentails 记住密码 （win10 默认可以记住） git config –global core.autocrlf true git config –global core.autocrlf input git config –global core.autocrlf false 创建仓库 command 说明 git init touch .gitigonre 创建忽略清单 git init –bare 创建远程仓库 文件夹以 .git 结尾 获取代码Remote → Local command 说明 git clone Repo git pull git pull Repo RemoteBranch git pull Repo RemoteBranch:LocalBranch 添加代码工作区 → 暂存区 command 说明 git add PathName/FileName git add . 保存新的添加和修改，但是不包括删除 git add -u 保存修改和删除，但是不包括新建文件 git add * 全部提交 git add -A 提交代码暂存区 → 分支 command 说明 git commit -m ‘’ 推送代码Local → Remote command 说明 git push git push Repo LocalBranch git pust git push Repo LocalBranch:RemoteBranch 状态 &amp; 记录 command 说明 git status git log git log –graph git reflog 所有操作记录，包括 reset git diff FileName 工作区(work dict)和暂存区(stage)的比较 git diff –cached 暂存区(stage)和分支(master)的比较 git stash 保存当前状态 git stash list 查看所有以保存的状态 git stash pop 恢复状态并删除 git stash apply 恢复状态，状态不会被删除 git stash drop 删除状态 取消修改 command 说明 git checkout – PathName/FileName 取消添加暂存区 → 工作区 command 说明 git reset HEAD PathName/FileName 把暂存区的文件移动到工作区 取消提交分支 → 暂存区 command 说明 git reset –hard head_id 已经commit的代码会丢失 git reset –soft head_id 已经commit的代码会回到暂存区 git reset –mixed head_id 没试 git revert head_id &amp; git push 回滚已经push到远程仓库的代码 注意：git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit，看似达到的效果是一样的,其实完全不同。 上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会 如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里 reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的 远程 command 说明 git remote add origin RemoteRepo git remote add Name RemoteRepo git remote set-url origin NewRemoteRepo git remote -v git remote rm Name 分支 command 说明 git branch BranchName 创建分支 git checkout BranchName 切换分支 git checkout -b BranchName 创建并切换分支 git merge BranchName 合并到当前分支 git branch , git branch -a , git branch -r 查看分支 git branch -m OldBranchName NewBranchName 重命名分支 git push orign BranchName:BranchName 创建远程分支 git branch -d BranchName 删除本地分支 git branch -D BranchName 强制删除没有合并的本地分支 git push orign :RemoteBranchName 删除远程分支 git push origin –delete RemoteBranchName 删除远程分支 git fetch -p 修剪远程分支 创建分支后，只要没有执行commit操作,所做的修改不属于任何一个分支 标签 command 说明 git tag TagName git tag -a TagName -m ‘’ git tag 查看标签 git tag -l TagNameLike 查看制定标签 git ls-remote –tags 查看远程标签 git push origin TagName git push origin –tags 推送所有标签 git tag -d TagName 删除本地标签 git push origin –delete tag TagName 删除远程标签 git push origin :TagName 删除远程标签 Git 里面的 origin 到底代表啥意思? SSHssh-keygen -t rsa # 创建密钥ssh 用户名@主机地址 # ssh连接 密钥保存在C:\\Users\\用户名\\.ssh\\id_rsa.pub文件内","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://onlymisaky.github.io/tags/git/"}]}],"categories":[],"tags":[{"name":"rollup","slug":"rollup","permalink":"http://onlymisaky.github.io/tags/rollup/"},{"name":"打包","slug":"打包","permalink":"http://onlymisaky.github.io/tags/%E6%89%93%E5%8C%85/"},{"name":"构建","slug":"构建","permalink":"http://onlymisaky.github.io/tags/%E6%9E%84%E5%BB%BA/"},{"name":"node","slug":"node","permalink":"http://onlymisaky.github.io/tags/node/"},{"name":"cli","slug":"cli","permalink":"http://onlymisaky.github.io/tags/cli/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://onlymisaky.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"vue","slug":"vue","permalink":"http://onlymisaky.github.io/tags/vue/"},{"name":"自己看","slug":"自己看","permalink":"http://onlymisaky.github.io/tags/%E8%87%AA%E5%B7%B1%E7%9C%8B/"},{"name":"面试题","slug":"面试题","permalink":"http://onlymisaky.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://onlymisaky.github.io/tags/Event-Loop/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://onlymisaky.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://onlymisaky.github.io/tags/TypeScript/"},{"name":"webpack","slug":"webpack","permalink":"http://onlymisaky.github.io/tags/webpack/"},{"name":"重构","slug":"重构","permalink":"http://onlymisaky.github.io/tags/%E9%87%8D%E6%9E%84/"},{"name":"闲聊","slug":"闲聊","permalink":"http://onlymisaky.github.io/tags/%E9%97%B2%E8%81%8A/"},{"name":"JSDoc","slug":"JSDoc","permalink":"http://onlymisaky.github.io/tags/JSDoc/"},{"name":"http-proxy-middleware","slug":"http-proxy-middleware","permalink":"http://onlymisaky.github.io/tags/http-proxy-middleware/"},{"name":"面向对象","slug":"面向对象","permalink":"http://onlymisaky.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Cmder","slug":"Cmder","permalink":"http://onlymisaky.github.io/tags/Cmder/"},{"name":"git","slug":"git","permalink":"http://onlymisaky.github.io/tags/git/"}]}